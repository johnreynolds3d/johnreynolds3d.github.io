!(function () {
  function t() {
    ((this.tolerance = -1),
      (this.faces = []),
      (this.newFaces = []),
      (this.assigned = new i()),
      (this.unassigned = new i()),
      (this.vertices = []));
  }
  function e() {
    ((this.normal = new THREE.Vector3()),
      (this.midpoint = new THREE.Vector3()),
      (this.area = 0),
      (this.constant = 0),
      (this.outside = null),
      (this.mark = s),
      (this.edge = null));
  }
  function n(t, e) {
    ((this.vertex = t), (this.prev = null), (this.next = null), (this.twin = null), (this.face = e));
  }
  function i() {
    ((this.head = null), (this.tail = null));
  }
  var s = 0;
  (Object.assign(t.prototype, {
    setFromPoints: function (t) {
      (!0 !== Array.isArray(t) && console.error('THREE.QuickHull: Points parameter is not an array.'),
        t.length < 4 && console.error('THREE.QuickHull: The algorithm needs at least four points.'),
        this.makeEmpty());
      for (let e = 0, n = t.length; e < n; e++)
        this.vertices.push(
          new (function (t) {
            ((this.point = t), (this.prev = null), (this.next = null), (this.face = null));
          })(t[e])
        );
      return (this.compute(), this);
    },
    setFromObject: function (t) {
      const e = [];
      return (
        t.updateMatrixWorld(!0),
        t.traverse(function (t) {
          let n,
            i,
            s,
            r = t.geometry;
          if (void 0 !== r)
            if (r.isGeometry) {
              const o = r.vertices;
              for (n = 0, i = o.length; n < i; n++) ((s = o[n].clone()).applyMatrix4(t.matrixWorld), e.push(s));
            } else if (r.isBufferGeometry) {
              const a = r.attributes.position;
              if (void 0 !== a)
                for (n = 0, i = a.count; n < i; n++)
                  ((s = new THREE.Vector3()).fromBufferAttribute(a, n).applyMatrix4(t.matrixWorld), e.push(s));
            }
        }),
        this.setFromPoints(e)
      );
    },
    makeEmpty: function () {
      return ((this.faces = []), (this.vertices = []), this);
    },
    addVertexToFace: function (t, e) {
      return (
        (t.face = e),
        null === e.outside ? this.assigned.append(t) : this.assigned.insertBefore(e.outside, t),
        (e.outside = t),
        this
      );
    },
    removeVertexFromFace: function (t, e) {
      return (
        t === e.outside && (null !== t.next && t.next.face === e ? (e.outside = t.next) : (e.outside = null)),
        this.assigned.remove(t),
        this
      );
    },
    removeAllVerticesFromFace: function (t) {
      if (null !== t.outside) {
        for (var e = t.outside, n = t.outside; null !== n.next && n.next.face === t; ) n = n.next;
        return (this.assigned.removeSubList(e, n), (e.prev = n.next = null), (t.outside = null), e);
      }
    },
    deleteFaceVertices: function (t, e) {
      const n = this.removeAllVerticesFromFace(t);
      if (void 0 !== n)
        if (void 0 === e) this.unassigned.appendChain(n);
        else {
          let i = n;
          do {
            const s = i.next;
            (e.distanceToPoint(i.point) > this.tolerance ? this.addVertexToFace(i, e) : this.unassigned.append(i),
              (i = s));
          } while (null !== i);
        }
      return this;
    },
    resolveUnassignedPoints: function (t) {
      if (!1 === this.unassigned.isEmpty()) {
        let e = this.unassigned.first();
        do {
          for (var n = e.next, i = this.tolerance, r = null, o = 0; o < t.length; o++) {
            const a = t[o];
            if (a.mark === s) {
              const h = a.distanceToPoint(e.point);
              if ((h > i && ((i = h), (r = a)), i > 1e3 * this.tolerance)) break;
            }
          }
          (null !== r && this.addVertexToFace(e, r), (e = n));
        } while (null !== e);
      }
      return this;
    },
    computeExtremes: function () {
      let t,
        e,
        n,
        i = new THREE.Vector3(),
        s = new THREE.Vector3(),
        r = [],
        o = [];
      for (t = 0; t < 3; t++) r[t] = o[t] = this.vertices[0];
      for (
        i.copy(this.vertices[0].point), s.copy(this.vertices[0].point), t = 0, e = this.vertices.length;
        t < e;
        t++
      ) {
        const a = this.vertices[t],
          h = a.point;
        for (n = 0; n < 3; n++)
          h.getComponent(n) < i.getComponent(n) && (i.setComponent(n, h.getComponent(n)), (r[n] = a));
        for (n = 0; n < 3; n++)
          h.getComponent(n) > s.getComponent(n) && (s.setComponent(n, h.getComponent(n)), (o[n] = a));
      }
      return (
        (this.tolerance =
          3 *
          Number.EPSILON *
          (Math.max(Math.abs(i.x), Math.abs(s.x)) +
            Math.max(Math.abs(i.y), Math.abs(s.y)) +
            Math.max(Math.abs(i.z), Math.abs(s.z)))),
        { min: r, max: o }
      );
    },
    computeInitialHull: (function () {
      let t, n, i;
      return function () {
        void 0 === t && ((t = new THREE.Line3()), (n = new THREE.Plane()), (i = new THREE.Vector3()));
        let s,
          r,
          o,
          a,
          h,
          u,
          l,
          c,
          d,
          p = this.vertices,
          f = this.computeExtremes(),
          v = f.min,
          g = f.max,
          m = 0,
          x = 0;
        for (u = 0; u < 3; u++) (d = g[u].point.getComponent(u) - v[u].point.getComponent(u)) > m && ((m = d), (x = u));
        for (r = v[x], o = g[x], m = 0, t.set(r.point, o.point), u = 0, l = this.vertices.length; u < l; u++)
          (s = p[u]) !== r &&
            s !== o &&
            (t.closestPointToPoint(s.point, !0, i), (d = i.distanceToSquared(s.point)) > m && ((m = d), (a = s)));
        for (m = -1, n.setFromCoplanarPoints(r.point, o.point, a.point), u = 0, l = this.vertices.length; u < l; u++)
          (s = p[u]) !== r &&
            s !== o &&
            s !== a &&
            (d = Math.abs(n.distanceToPoint(s.point))) > m &&
            ((m = d), (h = s));
        const E = [];
        if (n.distanceToPoint(h.point) < 0)
          for (E.push(e.create(r, o, a), e.create(h, o, r), e.create(h, a, o), e.create(h, r, a)), u = 0; u < 3; u++)
            ((c = (u + 1) % 3),
              E[u + 1].getEdge(2).setTwin(E[0].getEdge(c)),
              E[u + 1].getEdge(1).setTwin(E[c + 1].getEdge(0)));
        else
          for (E.push(e.create(r, a, o), e.create(h, r, o), e.create(h, o, a), e.create(h, a, r)), u = 0; u < 3; u++)
            ((c = (u + 1) % 3),
              E[u + 1].getEdge(2).setTwin(E[0].getEdge((3 - u) % 3)),
              E[u + 1].getEdge(0).setTwin(E[c + 1].getEdge(1)));
        for (u = 0; u < 4; u++) this.faces.push(E[u]);
        for (u = 0, l = p.length; u < l; u++)
          if ((s = p[u]) !== r && s !== o && s !== a && s !== h) {
            m = this.tolerance;
            let T = null;
            for (c = 0; c < 4; c++) (d = this.faces[c].distanceToPoint(s.point)) > m && ((m = d), (T = this.faces[c]));
            null !== T && this.addVertexToFace(s, T);
          }
        return this;
      };
    })(),
    reindexFaces: function () {
      for (var t = [], e = 0; e < this.faces.length; e++) {
        const n = this.faces[e];
        n.mark === s && t.push(n);
      }
      return ((this.faces = t), this);
    },
    nextVertexToAdd: function () {
      if (!1 === this.assigned.isEmpty()) {
        let t,
          e = 0,
          n = this.assigned.first().face,
          i = n.outside;
        do {
          const s = n.distanceToPoint(i.point);
          (s > e && ((e = s), (t = i)), (i = i.next));
        } while (null !== i && i.face === n);
        return t;
      }
    },
    computeHorizon: function (t, e, n, i) {
      (this.deleteFaceVertices(n), (n.mark = 1));
      let r;
      r = null === e ? (e = n.getEdge(0)) : e.next;
      do {
        const o = r.twin,
          a = o.face;
        (a.mark === s && (a.distanceToPoint(t) > this.tolerance ? this.computeHorizon(t, o, a, i) : i.push(r)),
          (r = r.next));
      } while (r !== e);
      return this;
    },
    addAdjoiningFace: function (t, n) {
      const i = e.create(t, n.tail(), n.head());
      return (this.faces.push(i), i.getEdge(-1).setTwin(n.twin), i.getEdge(0));
    },
    addNewFaces: function (t, e) {
      this.newFaces = [];
      for (var n = null, i = null, s = 0; s < e.length; s++) {
        const r = e[s],
          o = this.addAdjoiningFace(t, r);
        (null === n ? (n = o) : o.next.setTwin(i), this.newFaces.push(o.face), (i = o));
      }
      return (n.next.setTwin(i), this);
    },
    addVertexToHull: function (t) {
      const e = [];
      return (
        this.unassigned.clear(),
        this.removeVertexFromFace(t, t.face),
        this.computeHorizon(t.point, null, t.face, e),
        this.addNewFaces(t, e),
        this.resolveUnassignedPoints(this.newFaces),
        this
      );
    },
    cleanup: function () {
      return (this.assigned.clear(), this.unassigned.clear(), (this.newFaces = []), this);
    },
    compute: function () {
      let t;
      for (this.computeInitialHull(); void 0 !== (t = this.nextVertexToAdd()); ) this.addVertexToHull(t);
      return (this.reindexFaces(), this.cleanup(), this);
    },
  }),
    Object.assign(e, {
      create: function (t, i, s) {
        const r = new e(),
          o = new n(t, r),
          a = new n(i, r),
          h = new n(s, r);
        return ((o.next = h.prev = a), (a.next = o.prev = h), (h.next = a.prev = o), (r.edge = o), r.compute());
      },
    }),
    Object.assign(e.prototype, {
      getEdge: function (t) {
        for (var e = this.edge; t > 0; ) ((e = e.next), t--);
        for (; t < 0; ) ((e = e.prev), t++);
        return e;
      },
      compute: (function () {
        let t;
        return function () {
          void 0 === t && (t = new THREE.Triangle());
          const e = this.edge.tail(),
            n = this.edge.head(),
            i = this.edge.next.head();
          return (
            t.set(e.point, n.point, i.point),
            t.normal(this.normal),
            t.midpoint(this.midpoint),
            (this.area = t.area()),
            (this.constant = this.normal.dot(this.midpoint)),
            this
          );
        };
      })(),
      distanceToPoint: function (t) {
        return this.normal.dot(t) - this.constant;
      },
    }),
    Object.assign(n.prototype, {
      head: function () {
        return this.vertex;
      },
      tail: function () {
        return this.prev ? this.prev.vertex : null;
      },
      length: function () {
        const t = this.head(),
          e = this.tail();
        return null !== e ? e.point.distanceTo(t.point) : -1;
      },
      lengthSquared: function () {
        const t = this.head(),
          e = this.tail();
        return null !== e ? e.point.distanceToSquared(t.point) : -1;
      },
      setTwin: function (t) {
        return ((this.twin = t), (t.twin = this), this);
      },
    }),
    Object.assign(i.prototype, {
      first: function () {
        return this.head;
      },
      last: function () {
        return this.tail;
      },
      clear: function () {
        return ((this.head = this.tail = null), this);
      },
      insertBefore: function (t, e) {
        return (
          (e.prev = t.prev),
          (e.next = t),
          null === e.prev ? (this.head = e) : (e.prev.next = e),
          (t.prev = e),
          this
        );
      },
      insertAfter: function (t, e) {
        return (
          (e.prev = t),
          (e.next = t.next),
          null === e.next ? (this.tail = e) : (e.next.prev = e),
          (t.next = e),
          this
        );
      },
      append: function (t) {
        return (
          null === this.head ? (this.head = t) : (this.tail.next = t),
          (t.prev = this.tail),
          (t.next = null),
          (this.tail = t),
          this
        );
      },
      appendChain: function (t) {
        for (null === this.head ? (this.head = t) : (this.tail.next = t), t.prev = this.tail; null !== t.next; )
          t = t.next;
        return ((this.tail = t), this);
      },
      remove: function (t) {
        return (
          null === t.prev ? (this.head = t.next) : (t.prev.next = t.next),
          null === t.next ? (this.tail = t.prev) : (t.next.prev = t.prev),
          this
        );
      },
      removeSubList: function (t, e) {
        return (
          null === t.prev ? (this.head = e.next) : (t.prev.next = e.next),
          null === e.next ? (this.tail = t.prev) : (e.next.prev = t.prev),
          this
        );
      },
      isEmpty: function () {
        return null === this.head;
      },
    }),
    (THREE.QuickHull = t));
})();
