(!(function (t, e) {
  'object' == typeof exports && 'undefined' != typeof module
    ? e(exports)
    : 'function' == typeof define && define.amd
      ? define(['exports'], e)
      : e((t.THREE = {}));
})(this, function (t) {
  'use strict';
  function e() {}
  function i(t, e) {
    ((this.x = t || 0), (this.y = e || 0));
  }
  function n() {
    ((this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      arguments.length > 0 &&
        console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.'));
  }
  function r(t, e, i, n) {
    ((this._x = t || 0), (this._y = e || 0), (this._z = i || 0), (this._w = void 0 !== n ? n : 1));
  }
  function a(t, e, i) {
    ((this.x = t || 0), (this.y = e || 0), (this.z = i || 0));
  }
  function o() {
    ((this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      arguments.length > 0 &&
        console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.'));
  }
  function s(t, e, n, r, a, c, h, l, u, p) {
    (Object.defineProperty(this, 'id', { value: Xa++ }),
      (this.uuid = Wa.generateUUID()),
      (this.name = ''),
      (this.image = void 0 !== t ? t : s.DEFAULT_IMAGE),
      (this.mipmaps = []),
      (this.mapping = void 0 !== e ? e : s.DEFAULT_MAPPING),
      (this.wrapS = void 0 !== n ? n : Yr),
      (this.wrapT = void 0 !== r ? r : Yr),
      (this.magFilter = void 0 !== a ? a : $r),
      (this.minFilter = void 0 !== c ? c : ea),
      (this.anisotropy = void 0 !== u ? u : 1),
      (this.format = void 0 !== h ? h : va),
      (this.type = void 0 !== l ? l : ia),
      (this.offset = new i(0, 0)),
      (this.repeat = new i(1, 1)),
      (this.center = new i(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new o()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.encoding = void 0 !== p ? p : Na),
      (this.version = 0),
      (this.onUpdate = null));
  }
  function c(t, e, i, n) {
    ((this.x = t || 0), (this.y = e || 0), (this.z = i || 0), (this.w = void 0 !== n ? n : 1));
  }
  function h(t, e, i) {
    ((this.uuid = Wa.generateUUID()),
      (this.width = t),
      (this.height = e),
      (this.scissor = new c(0, 0, t, e)),
      (this.scissorTest = !1),
      (this.viewport = new c(0, 0, t, e)),
      void 0 === (i = i || {}).minFilter && (i.minFilter = $r),
      (this.texture = new s(
        void 0,
        void 0,
        i.wrapS,
        i.wrapT,
        i.magFilter,
        i.minFilter,
        i.format,
        i.type,
        i.anisotropy,
        i.encoding
      )),
      (this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer),
      (this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer),
      (this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null));
  }
  function l(t, e, i) {
    (h.call(this, t, e, i), (this.activeCubeFace = 0), (this.activeMipMapLevel = 0));
  }
  function u(t, e, i, n, r, a, o, c, h, l, u, p) {
    (s.call(this, null, a, o, c, h, l, n, r, u, p),
      (this.image = { data: t, width: e, height: i }),
      (this.magFilter = void 0 !== h ? h : Qr),
      (this.minFilter = void 0 !== l ? l : Qr),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1));
  }
  function p(t, e, i, n, r, a, o, c, h, l) {
    (s.call(this, (t = void 0 !== t ? t : []), (e = void 0 !== e ? e : Gr), i, n, r, a, o, c, h, l), (this.flipY = !1));
  }
  function d() {
    ((this.seq = []), (this.map = {}));
  }
  function f(t, e, i) {
    const n = t[0];
    if (n <= 0 || n > 0) return t;
    let r = e * i,
      a = Za[r];
    if ((void 0 === a && ((a = new Float32Array(r)), (Za[r] = a)), 0 !== e)) {
      n.toArray(a, 0);
      for (let o = 1, s = 0; o !== e; ++o) ((s += i), t[o].toArray(a, s));
    }
    return a;
  }
  function m(t, e) {
    let i = Qa[e];
    void 0 === i && ((i = new Int32Array(e)), (Qa[e] = i));
    for (let n = 0; n !== e; ++n) i[n] = t.allocTextureUnit();
    return i;
  }
  function v(t, e) {
    t.uniform2iv(this.addr, e);
  }
  function g(t, e) {
    t.uniform3iv(this.addr, e);
  }
  function y(t, e) {
    t.uniform4iv(this.addr, e);
  }
  function x(t) {
    ((this.id = t), d.call(this));
  }
  function b(t, e) {
    (t.seq.push(e), (t.map[e.id] = e));
  }
  function _(t, e, i) {
    (d.call(this), (this.renderer = i));
    for (let n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), r = 0; r < n; ++r) {
      const a = t.getActiveUniform(e, r),
        o = a.name;
      !(function (t, e, i) {
        const n = t.name,
          r = n.length;
        for ($a.lastIndex = 0; ; ) {
          let a = $a.exec(n),
            o = $a.lastIndex,
            s = a[1],
            c = ']' === a[2],
            h = a[3];
          if ((c && (s |= 0), void 0 === h || ('[' === h && o + 2 === r))) {
            b(
              i,
              void 0 === h
                ? new (function (t, e, i) {
                    ((this.id = t),
                      (this.addr = i),
                      (this.setValue = (function (t) {
                        switch (e.type) {
                          case 5126:
                            return function (t, e) {
                              t.uniform1f(this.addr, e);
                            };
                          case 35664:
                            return function (t, e) {
                              void 0 === e.x ? t.uniform2fv(this.addr, e) : t.uniform2f(this.addr, e.x, e.y);
                            };
                          case 35665:
                            return function (t, e) {
                              void 0 !== e.x
                                ? t.uniform3f(this.addr, e.x, e.y, e.z)
                                : void 0 !== e.r
                                  ? t.uniform3f(this.addr, e.r, e.g, e.b)
                                  : t.uniform3fv(this.addr, e);
                            };
                          case 35666:
                            return function (t, e) {
                              void 0 === e.x ? t.uniform4fv(this.addr, e) : t.uniform4f(this.addr, e.x, e.y, e.z, e.w);
                            };
                          case 35674:
                            return function (t, e) {
                              t.uniformMatrix2fv(this.addr, !1, e.elements || e);
                            };
                          case 35675:
                            return function (t, e) {
                              void 0 === e.elements
                                ? t.uniformMatrix3fv(this.addr, !1, e)
                                : (Ka.set(e.elements), t.uniformMatrix3fv(this.addr, !1, Ka));
                            };
                          case 35676:
                            return function (t, e) {
                              void 0 === e.elements
                                ? t.uniformMatrix4fv(this.addr, !1, e)
                                : (Ja.set(e.elements), t.uniformMatrix4fv(this.addr, !1, Ja));
                            };
                          case 35678:
                          case 36198:
                            return function (t, e, i) {
                              const n = i.allocTextureUnit();
                              (t.uniform1i(this.addr, n), i.setTexture2D(e || qa, n));
                            };
                          case 35680:
                            return function (t, e, i) {
                              const n = i.allocTextureUnit();
                              (t.uniform1i(this.addr, n), i.setTextureCube(e || Ya, n));
                            };
                          case 5124:
                          case 35670:
                            return function (t, e) {
                              t.uniform1i(this.addr, e);
                            };
                          case 35667:
                          case 35671:
                            return v;
                          case 35668:
                          case 35672:
                            return g;
                          case 35669:
                          case 35673:
                            return y;
                        }
                      })()));
                  })(s, t, e)
                : new (function (t, e, i) {
                    ((this.id = t),
                      (this.addr = i),
                      (this.size = e.size),
                      (this.setValue = (function (t) {
                        switch (e.type) {
                          case 5126:
                            return function (t, e) {
                              t.uniform1fv(this.addr, e);
                            };
                          case 35664:
                            return function (t, e) {
                              t.uniform2fv(this.addr, f(e, this.size, 2));
                            };
                          case 35665:
                            return function (t, e) {
                              t.uniform3fv(this.addr, f(e, this.size, 3));
                            };
                          case 35666:
                            return function (t, e) {
                              t.uniform4fv(this.addr, f(e, this.size, 4));
                            };
                          case 35674:
                            return function (t, e) {
                              t.uniformMatrix2fv(this.addr, !1, f(e, this.size, 4));
                            };
                          case 35675:
                            return function (t, e) {
                              t.uniformMatrix3fv(this.addr, !1, f(e, this.size, 9));
                            };
                          case 35676:
                            return function (t, e) {
                              t.uniformMatrix4fv(this.addr, !1, f(e, this.size, 16));
                            };
                          case 35678:
                            return function (t, e, i) {
                              const n = e.length,
                                r = m(i, n);
                              t.uniform1iv(this.addr, r);
                              for (let a = 0; a !== n; ++a) i.setTexture2D(e[a] || qa, r[a]);
                            };
                          case 35680:
                            return function (t, e, i) {
                              const n = e.length,
                                r = m(i, n);
                              t.uniform1iv(this.addr, r);
                              for (let a = 0; a !== n; ++a) i.setTextureCube(e[a] || Ya, r[a]);
                            };
                          case 5124:
                          case 35670:
                            return function (t, e) {
                              t.uniform1iv(this.addr, e);
                            };
                          case 35667:
                          case 35671:
                            return v;
                          case 35668:
                          case 35672:
                            return g;
                          case 35669:
                          case 35673:
                            return y;
                        }
                      })()));
                  })(s, t, e)
            );
            break;
          }
          let l = i.map[s];
          (void 0 === l && b(i, (l = new x(s))), (i = l));
        }
      })(a, t.getUniformLocation(e, o), this);
    }
  }
  function w(t, e, i) {
    return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i);
  }
  function E(t, e) {
    ((this.min = void 0 !== t ? t : new i(1 / 0, 1 / 0)), (this.max = void 0 !== e ? e : new i(-1 / 0, -1 / 0)));
  }
  function M(t, e, i, n, r, a, o, c, h) {
    (s.call(this, t, e, i, n, r, a, o, c, h), (this.needsUpdate = !0));
  }
  function T() {
    (Object.defineProperty(this, 'id', { value: ao++ }),
      (this.uuid = Wa.generateUUID()),
      (this.name = ''),
      (this.type = 'Material'),
      (this.fog = !0),
      (this.lights = !0),
      (this.blending = nr),
      (this.side = Qn),
      (this.flatShading = !1),
      (this.vertexColors = $n),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.blendSrc = gr),
      (this.blendDst = yr),
      (this.blendEquation = cr),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = Ar),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaTest = 0),
      (this.premultipliedAlpha = !1),
      (this.overdraw = 0),
      (this.visible = !0),
      (this.userData = {}),
      (this.needsUpdate = !0));
  }
  function S(t) {
    (T.call(this),
      (this.type = 'MeshDepthMaterial'),
      (this.depthPacking = ka),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      this.setValues(t));
  }
  function A(t) {
    (T.call(this),
      (this.type = 'MeshDistanceMaterial'),
      (this.referencePosition = new a()),
      (this.nearDistance = 1),
      (this.farDistance = 1e3),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.fog = !1),
      (this.lights = !1),
      this.setValues(t));
  }
  function R(t, e) {
    ((this.min = void 0 !== t ? t : new a(1 / 0, 1 / 0, 1 / 0)),
      (this.max = void 0 !== e ? e : new a(-1 / 0, -1 / 0, -1 / 0)));
  }
  function L(t, e) {
    ((this.center = void 0 !== t ? t : new a()), (this.radius = void 0 !== e ? e : 0));
  }
  function P(t, e) {
    ((this.normal = void 0 !== t ? t : new a(1, 0, 0)), (this.constant = void 0 !== e ? e : 0));
  }
  function C(t, e, i, n, r, a) {
    this.planes = [
      void 0 !== t ? t : new P(),
      void 0 !== e ? e : new P(),
      void 0 !== i ? i : new P(),
      void 0 !== n ? n : new P(),
      void 0 !== r ? r : new P(),
      void 0 !== a ? a : new P(),
    ];
  }
  function I(t, e, r) {
    function o(e, i, n, r, a, o) {
      let s = e.geometry,
        c = null,
        h = x,
        l = e.customDepthMaterial;
      if ((n && ((h = b), (l = e.customDistanceMaterial)), l)) c = l;
      else {
        let u = !1;
        (i.morphTargets &&
          (s && s.isBufferGeometry
            ? (u = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0)
            : s && s.isGeometry && (u = s.morphTargets && s.morphTargets.length > 0)),
          e.isSkinnedMesh &&
            !1 === i.skinning &&
            console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', e));
        let p = e.isSkinnedMesh && i.skinning,
          d = 0;
        (u && (d |= v), p && (d |= g), (c = h[d]));
      }
      if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
        let f = c.uuid,
          m = i.uuid,
          y = _[f];
        void 0 === y && ((y = {}), (_[f] = y));
        let w = y[m];
        (void 0 === w && ((w = c.clone()), (y[m] = w)), (c = w));
      }
      ((c.visible = i.visible), (c.wireframe = i.wireframe));
      let E = i.side;
      return (
        D.renderSingleSided && E == Kn && (E = Qn),
        D.renderReverseSided && (E === Qn ? (E = Jn) : E === Jn && (E = Qn)),
        (c.side = E),
        (c.clipShadows = i.clipShadows),
        (c.clippingPlanes = i.clippingPlanes),
        (c.clipIntersection = i.clipIntersection),
        (c.wireframeLinewidth = i.wireframeLinewidth),
        (c.linewidth = i.linewidth),
        n && c.isMeshDistanceMaterial && (c.referencePosition.copy(r), (c.nearDistance = a), (c.farDistance = o)),
        c
      );
    }
    function s(i, n, r, a) {
      if (!1 !== i.visible) {
        if (
          i.layers.test(n.layers) &&
          (i.isMesh || i.isLine || i.isPoints) &&
          i.castShadow &&
          (!i.frustumCulled || l.intersectsObject(i))
        ) {
          i.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, i.matrixWorld);
          const c = e.update(i),
            h = i.material;
          if (Array.isArray(h))
            for (let u = c.groups, p = 0, d = u.length; p < d; p++) {
              const f = u[p],
                v = h[f.materialIndex];
              if (v && v.visible) {
                g = o(i, v, a, m, r.near, r.far);
                t.renderBufferDirect(r, null, c, g, i, f);
              }
            }
          else if (h.visible) {
            var g = o(i, h, a, m, r.near, r.far);
            t.renderBufferDirect(r, null, c, g, i, null);
          }
        }
        for (let y = i.children, x = 0, b = y.length; x < b; x++) s(y[x], n, r, a);
      }
    }
    for (
      var l = new C(),
        u = new n(),
        p = new i(),
        d = new i(r, r),
        f = new a(),
        m = new a(),
        v = 1,
        g = 2,
        y = 1 + (v | g),
        x = new Array(y),
        b = new Array(y),
        _ = {},
        w = [new a(1, 0, 0), new a(-1, 0, 0), new a(0, 0, 1), new a(0, 0, -1), new a(0, 1, 0), new a(0, -1, 0)],
        E = [new a(0, 1, 0), new a(0, 1, 0), new a(0, 1, 0), new a(0, 1, 0), new a(0, 0, 1), new a(0, 0, -1)],
        M = [new c(), new c(), new c(), new c(), new c(), new c()],
        T = 0;
      T !== y;
      ++T
    ) {
      const R = 0 != (T & v),
        L = 0 != (T & g),
        P = new S({ depthPacking: ja, morphTargets: R, skinning: L });
      x[T] = P;
      const I = new A({ morphTargets: R, skinning: L });
      b[T] = I;
    }
    var D = this;
    ((this.enabled = !1),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this.type = Yn),
      (this.renderReverseSided = !0),
      (this.renderSingleSided = !0),
      (this.render = function (e, i, n) {
        if (!1 !== D.enabled && (!1 !== D.autoUpdate || !1 !== D.needsUpdate) && 0 !== e.length) {
          const r = t.context,
            a = t.state;
          (a.disable(r.BLEND), a.buffers.color.setClear(1, 1, 1, 1), a.buffers.depth.setTest(!0), a.setScissorTest(!1));
          for (var o, c = 0, v = e.length; c < v; c++) {
            const g = e[c],
              y = g.shadow,
              x = g && g.isPointLight;
            if (void 0 !== y) {
              const b = y.camera;
              if ((p.copy(y.mapSize), p.min(d), x)) {
                const _ = p.x,
                  T = p.y;
                (M[0].set(2 * _, T, _, T),
                  M[1].set(0, T, _, T),
                  M[2].set(3 * _, T, _, T),
                  M[3].set(_, T, _, T),
                  M[4].set(3 * _, 0, _, T),
                  M[5].set(_, 0, _, T),
                  (p.x *= 4),
                  (p.y *= 2));
              }
              if (null === y.map) {
                const S = { minFilter: Qr, magFilter: Qr, format: va };
                ((y.map = new h(p.x, p.y, S)),
                  (y.map.texture.name = g.name + '.shadowMap'),
                  b.updateProjectionMatrix());
              }
              y.isSpotLightShadow && y.update(g);
              const A = y.map,
                R = y.matrix;
              (m.setFromMatrixPosition(g.matrixWorld),
                b.position.copy(m),
                x
                  ? ((o = 6), R.makeTranslation(-m.x, -m.y, -m.z))
                  : ((o = 1),
                    f.setFromMatrixPosition(g.target.matrixWorld),
                    b.lookAt(f),
                    b.updateMatrixWorld(),
                    R.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
                    R.multiply(b.projectionMatrix),
                    R.multiply(b.matrixWorldInverse)),
                t.setRenderTarget(A),
                t.clear());
              for (let L = 0; L < o; L++) {
                if (x) {
                  (f.copy(b.position), f.add(w[L]), b.up.copy(E[L]), b.lookAt(f), b.updateMatrixWorld());
                  const P = M[L];
                  a.viewport(P);
                }
                (u.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), l.setFromMatrix(u), s(i, n, b, x));
              }
            } else console.warn('THREE.WebGLShadowMap:', g, 'has no shadow.');
          }
          D.needsUpdate = !1;
        }
      }));
  }
  function D(t, e, i, n) {
    ((this._x = t || 0), (this._y = e || 0), (this._z = i || 0), (this._order = n || D.DefaultOrder));
  }
  function O() {
    this.mask = 1;
  }
  function U() {
    (Object.defineProperty(this, 'id', { value: oo++ }),
      (this.uuid = Wa.generateUUID()),
      (this.name = ''),
      (this.type = 'Object3D'),
      (this.parent = null),
      (this.children = []),
      (this.up = U.DefaultUp.clone()));
    const t = new a(),
      e = new D(),
      i = new r(),
      s = new a(1, 1, 1);
    (e.onChange(function () {
      i.setFromEuler(e, !1);
    }),
      i.onChange(function () {
        e.setFromQuaternion(i, void 0, !1);
      }),
      Object.defineProperties(this, {
        position: { enumerable: !0, value: t },
        rotation: { enumerable: !0, value: e },
        quaternion: { enumerable: !0, value: i },
        scale: { enumerable: !0, value: s },
        modelViewMatrix: { value: new n() },
        normalMatrix: { value: new o() },
      }),
      (this.matrix = new n()),
      (this.matrixWorld = new n()),
      (this.matrixAutoUpdate = U.DefaultMatrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new O()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.userData = {}));
  }
  function N() {
    (U.call(this), (this.type = 'Camera'), (this.matrixWorldInverse = new n()), (this.projectionMatrix = new n()));
  }
  function B(t, e, i, n, r, a) {
    (N.call(this),
      (this.type = 'OrthographicCamera'),
      (this.zoom = 1),
      (this.view = null),
      (this.left = t),
      (this.right = e),
      (this.top = i),
      (this.bottom = n),
      (this.near = void 0 !== r ? r : 0.1),
      (this.far = void 0 !== a ? a : 2e3),
      this.updateProjectionMatrix());
  }
  function F(t, e, i, n, r, o) {
    ((this.a = t),
      (this.b = e),
      (this.c = i),
      (this.normal = n && n.isVector3 ? n : new a()),
      (this.vertexNormals = Array.isArray(n) ? n : []),
      (this.color = r && r.isColor ? r : new w()),
      (this.vertexColors = Array.isArray(r) ? r : []),
      (this.materialIndex = void 0 !== o ? o : 0));
  }
  function z() {
    (Object.defineProperty(this, 'id', { value: (so += 2) }),
      (this.uuid = Wa.generateUUID()),
      (this.name = ''),
      (this.type = 'Geometry'),
      (this.vertices = []),
      (this.colors = []),
      (this.faces = []),
      (this.faceVertexUvs = [[]]),
      (this.morphTargets = []),
      (this.morphNormals = []),
      (this.skinWeights = []),
      (this.skinIndices = []),
      (this.lineDistances = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.elementsNeedUpdate = !1),
      (this.verticesNeedUpdate = !1),
      (this.uvsNeedUpdate = !1),
      (this.normalsNeedUpdate = !1),
      (this.colorsNeedUpdate = !1),
      (this.lineDistancesNeedUpdate = !1),
      (this.groupsNeedUpdate = !1));
  }
  function G(t, e, i) {
    if (Array.isArray(t)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    ((this.uuid = Wa.generateUUID()),
      (this.name = ''),
      (this.array = t),
      (this.itemSize = e),
      (this.count = void 0 !== t ? t.length / e : 0),
      (this.normalized = !0 === i),
      (this.dynamic = !1),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.onUploadCallback = function () {}),
      (this.version = 0));
  }
  function H(t, e, i) {
    G.call(this, new Int8Array(t), e, i);
  }
  function V(t, e, i) {
    G.call(this, new Uint8Array(t), e, i);
  }
  function k(t, e, i) {
    G.call(this, new Uint8ClampedArray(t), e, i);
  }
  function j(t, e, i) {
    G.call(this, new Int16Array(t), e, i);
  }
  function W(t, e, i) {
    G.call(this, new Uint16Array(t), e, i);
  }
  function X(t, e, i) {
    G.call(this, new Int32Array(t), e, i);
  }
  function q(t, e, i) {
    G.call(this, new Uint32Array(t), e, i);
  }
  function Y(t, e, i) {
    G.call(this, new Float32Array(t), e, i);
  }
  function Z(t, e, i) {
    G.call(this, new Float64Array(t), e, i);
  }
  function Q() {
    ((this.indices = []),
      (this.vertices = []),
      (this.normals = []),
      (this.colors = []),
      (this.uvs = []),
      (this.uvs2 = []),
      (this.groups = []),
      (this.morphTargets = {}),
      (this.skinWeights = []),
      (this.skinIndices = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.verticesNeedUpdate = !1),
      (this.normalsNeedUpdate = !1),
      (this.colorsNeedUpdate = !1),
      (this.uvsNeedUpdate = !1),
      (this.groupsNeedUpdate = !1));
  }
  function J(t) {
    if (0 === t.length) return -1 / 0;
    for (var e = t[0], i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
    return e;
  }
  function K() {
    (Object.defineProperty(this, 'id', { value: (co += 2) }),
      (this.uuid = Wa.generateUUID()),
      (this.name = ''),
      (this.type = 'BufferGeometry'),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }));
  }
  function $(t, e, i, n, r, a) {
    (z.call(this),
      (this.type = 'BoxGeometry'),
      (this.parameters = { width: t, height: e, depth: i, widthSegments: n, heightSegments: r, depthSegments: a }),
      this.fromBufferGeometry(new tt(t, e, i, n, r, a)),
      this.mergeVertices());
  }
  function tt(t, e, i, n, r, o) {
    function s(t, e, i, n, r, o, s, m, v, g, y) {
      let x,
        b,
        _ = o / v,
        w = s / g,
        E = o / 2,
        M = s / 2,
        T = m / 2,
        S = v + 1,
        A = g + 1,
        R = 0,
        L = 0,
        P = new a();
      for (b = 0; b < A; b++) {
        const C = b * w - M;
        for (x = 0; x < S; x++) {
          const I = x * _ - E;
          ((P[t] = I * n),
            (P[e] = C * r),
            (P[i] = T),
            l.push(P.x, P.y, P.z),
            (P[t] = 0),
            (P[e] = 0),
            (P[i] = m > 0 ? 1 : -1),
            u.push(P.x, P.y, P.z),
            p.push(x / v),
            p.push(1 - b / g),
            (R += 1));
        }
      }
      for (b = 0; b < g; b++)
        for (x = 0; x < v; x++) {
          const D = d + x + S * b,
            O = d + x + S * (b + 1),
            U = d + (x + 1) + S * (b + 1),
            N = d + (x + 1) + S * b;
          (h.push(D, O, N), h.push(O, U, N), (L += 6));
        }
      (c.addGroup(f, L, y), (f += L), (d += R));
    }
    (K.call(this),
      (this.type = 'BoxBufferGeometry'),
      (this.parameters = { width: t, height: e, depth: i, widthSegments: n, heightSegments: r, depthSegments: o }));
    var c = this;
    ((t = t || 1), (e = e || 1), (i = i || 1), (n = Math.floor(n) || 1), (r = Math.floor(r) || 1));
    var h = [],
      l = [],
      u = [],
      p = [],
      d = 0,
      f = 0;
    (s('z', 'y', 'x', -1, -1, i, e, t, (o = Math.floor(o) || 1), r, 0),
      s('z', 'y', 'x', 1, -1, i, e, -t, o, r, 1),
      s('x', 'z', 'y', 1, 1, t, i, e, n, o, 2),
      s('x', 'z', 'y', 1, -1, t, i, -e, n, o, 3),
      s('x', 'y', 'z', 1, -1, t, e, i, n, r, 4),
      s('x', 'y', 'z', -1, -1, t, e, -i, n, r, 5),
      this.setIndex(h),
      this.addAttribute('position', new Y(l, 3)),
      this.addAttribute('normal', new Y(u, 3)),
      this.addAttribute('uv', new Y(p, 2)));
  }
  function et(t, e, i, n) {
    (z.call(this),
      (this.type = 'PlaneGeometry'),
      (this.parameters = { width: t, height: e, widthSegments: i, heightSegments: n }),
      this.fromBufferGeometry(new it(t, e, i, n)),
      this.mergeVertices());
  }
  function it(t, e, i, n) {
    (K.call(this),
      (this.type = 'PlaneBufferGeometry'),
      (this.parameters = { width: t, height: e, widthSegments: i, heightSegments: n }));
    let r,
      a,
      o = (t = t || 1) / 2,
      s = (e = e || 1) / 2,
      c = Math.floor(i) || 1,
      h = Math.floor(n) || 1,
      l = c + 1,
      u = h + 1,
      p = t / c,
      d = e / h,
      f = [],
      m = [],
      v = [],
      g = [];
    for (a = 0; a < u; a++) {
      const y = a * d - s;
      for (r = 0; r < l; r++) {
        const x = r * p - o;
        (m.push(x, -y, 0), v.push(0, 0, 1), g.push(r / c), g.push(1 - a / h));
      }
    }
    for (a = 0; a < h; a++)
      for (r = 0; r < c; r++) {
        const b = r + l * a,
          _ = r + l * (a + 1),
          w = r + 1 + l * (a + 1),
          E = r + 1 + l * a;
        (f.push(b, _, E), f.push(_, w, E));
      }
    (this.setIndex(f),
      this.addAttribute('position', new Y(m, 3)),
      this.addAttribute('normal', new Y(v, 3)),
      this.addAttribute('uv', new Y(g, 2)));
  }
  function nt(t) {
    (T.call(this),
      (this.type = 'MeshBasicMaterial'),
      (this.color = new w(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = Ir),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.lights = !1),
      this.setValues(t));
  }
  function rt(t) {
    (T.call(this),
      (this.type = 'ShaderMaterial'),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.vertexShader =
        'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}'),
      (this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}'),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      (this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }),
      (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }),
      (this.index0AttributeName = void 0),
      void 0 !== t &&
        (void 0 !== t.attributes &&
          console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.'),
        this.setValues(t)));
  }
  function at(t, e) {
    ((this.origin = void 0 !== t ? t : new a()), (this.direction = void 0 !== e ? e : new a()));
  }
  function ot(t, e) {
    ((this.start = void 0 !== t ? t : new a()), (this.end = void 0 !== e ? e : new a()));
  }
  function st(t, e, i) {
    ((this.a = void 0 !== t ? t : new a()),
      (this.b = void 0 !== e ? e : new a()),
      (this.c = void 0 !== i ? i : new a()));
  }
  function ct(t, e) {
    (U.call(this),
      (this.type = 'Mesh'),
      (this.geometry = void 0 !== t ? t : new K()),
      (this.material = void 0 !== e ? e : new nt({ color: 16777215 * Math.random() })),
      (this.drawMode = Da),
      this.updateMorphTargets());
  }
  function ht(t, e, i) {
    const n = t.createShader(e);
    return (
      t.shaderSource(n, i),
      t.compileShader(n),
      !1 === t.getShaderParameter(n, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."),
      '' !== t.getShaderInfoLog(n) &&
        console.warn(
          'THREE.WebGLShader: gl.getShaderInfoLog()',
          e === t.VERTEX_SHADER ? 'vertex' : 'fragment',
          t.getShaderInfoLog(n),
          (function (t) {
            for (var e = t.split('\n'), i = 0; i < e.length; i++) e[i] = i + 1 + ': ' + e[i];
            return e.join('\n');
          })(i)
        ),
      n
    );
  }
  function lt(t) {
    switch (t) {
      case Na:
        return ['Linear', '( value )'];
      case Ba:
        return ['sRGB', '( value )'];
      case za:
        return ['RGBE', '( value )'];
      case Ga:
        return ['RGBM', '( value, 7.0 )'];
      case Ha:
        return ['RGBM', '( value, 16.0 )'];
      case Va:
        return ['RGBD', '( value, 256.0 )'];
      case Fa:
        return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
      default:
        throw new Error('unsupported encoding: ' + t);
    }
  }
  function ut(t, e) {
    const i = lt(e);
    return 'vec4 ' + t + '( vec4 value ) { return ' + i[0] + 'ToLinear' + i[1] + '; }';
  }
  function pt(t) {
    return '' !== t;
  }
  function dt(t, e) {
    return t
      .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
      .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
      .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
      .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
      .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights);
  }
  function ft(t) {
    return t.replace(/^[ \t]*#include +<([\w\d.]+)>/gm, function (t, e) {
      const i = no[e];
      if (void 0 === i) throw new Error('Can not resolve #include <' + e + '>');
      return ft(i);
    });
  }
  function mt(t) {
    return t.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function (t, e, i, n) {
      for (var r = '', a = parseInt(e); a < parseInt(i); a++) r += n.replace(/\[ i \]/g, '[ ' + a + ' ]');
      return r;
    });
  }
  function vt(t, e, i, n) {
    (N.call(this),
      (this.type = 'PerspectiveCamera'),
      (this.fov = void 0 !== t ? t : 50),
      (this.zoom = 1),
      (this.near = void 0 !== i ? i : 0.1),
      (this.far = void 0 !== n ? n : 2e3),
      (this.focus = 10),
      (this.aspect = void 0 !== e ? e : 1),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix());
  }
  function gt(t) {
    (vt.call(this), (this.cameras = t || []));
  }
  function yt(t) {
    function e() {
      if (null !== r && r.isPresenting) {
        const e = r.getEyeParameters('left'),
          n = e.renderWidth,
          a = e.renderHeight;
        ((d = t.getPixelRatio()), (p = t.getSize()), t.setDrawingBufferSize(2 * n, a, 1));
      } else i.enabled && t.setDrawingBufferSize(p.width, p.height, d);
    }
    var i = this,
      r = null,
      a = null,
      o = null;
    'undefined' != typeof window && 'VRFrameData' in window && (a = new window.VRFrameData());
    const s = new n(),
      h = new vt();
    ((h.bounds = new c(0, 0, 0.5, 1)), h.layers.enable(1));
    const l = new vt();
    ((l.bounds = new c(0.5, 0, 0.5, 1)), l.layers.enable(2));
    const u = new gt([h, l]);
    (u.layers.enable(1), u.layers.enable(2));
    let p, d;
    ('undefined' != typeof window && window.addEventListener('vrdisplaypresentchange', e, !1),
      (this.enabled = !1),
      (this.getDevice = function () {
        return r;
      }),
      (this.setDevice = function (t) {
        void 0 !== t && (r = t);
      }),
      (this.setPoseTarget = function (t) {
        void 0 !== t && (o = t);
      }),
      (this.getCamera = function (t) {
        if (null === r) return t;
        ((r.depthNear = t.near), (r.depthFar = t.far), r.getFrameData(a));
        let e,
          i = a.pose;
        if (
          ((e = null !== o ? o : t),
          null !== i.position ? e.position.fromArray(i.position) : e.position.set(0, 0, 0),
          null !== i.orientation && e.quaternion.fromArray(i.orientation),
          e.updateMatrixWorld(),
          !1 === r.isPresenting)
        )
          return t;
        ((h.near = t.near),
          (l.near = t.near),
          (h.far = t.far),
          (l.far = t.far),
          u.matrixWorld.copy(t.matrixWorld),
          u.matrixWorldInverse.copy(t.matrixWorldInverse),
          h.matrixWorldInverse.fromArray(a.leftViewMatrix),
          l.matrixWorldInverse.fromArray(a.rightViewMatrix));
        const n = t.parent;
        (null !== n &&
          (s.getInverse(n.matrixWorld), h.matrixWorldInverse.multiply(s), l.matrixWorldInverse.multiply(s)),
          h.matrixWorld.getInverse(h.matrixWorldInverse),
          l.matrixWorld.getInverse(l.matrixWorldInverse),
          h.projectionMatrix.fromArray(a.leftProjectionMatrix),
          l.projectionMatrix.fromArray(a.rightProjectionMatrix),
          u.projectionMatrix.copy(h.projectionMatrix));
        const c = r.getLayers();
        if (c.length) {
          const p = c[0];
          (null !== p.leftBounds && 4 === p.leftBounds.length && h.bounds.fromArray(p.leftBounds),
            null !== p.rightBounds && 4 === p.rightBounds.length && l.bounds.fromArray(p.rightBounds));
        }
        return u;
      }),
      (this.submitFrame = function () {
        r && r.isPresenting && r.submitFrame();
      }),
      (this.dispose = function () {
        'undefined' != typeof window && window.removeEventListener('vrdisplaypresentchange', e);
      }));
  }
  function xt(t, e) {
    return {
      convert: function (i) {
        let n;
        if (i === qr) return t.REPEAT;
        if (i === Yr) return t.CLAMP_TO_EDGE;
        if (i === Zr) return t.MIRRORED_REPEAT;
        if (i === Qr) return t.NEAREST;
        if (i === Jr) return t.NEAREST_MIPMAP_NEAREST;
        if (i === Kr) return t.NEAREST_MIPMAP_LINEAR;
        if (i === $r) return t.LINEAR;
        if (i === ta) return t.LINEAR_MIPMAP_NEAREST;
        if (i === ea) return t.LINEAR_MIPMAP_LINEAR;
        if (i === ia) return t.UNSIGNED_BYTE;
        if (i === la) return t.UNSIGNED_SHORT_4_4_4_4;
        if (i === ua) return t.UNSIGNED_SHORT_5_5_5_1;
        if (i === pa) return t.UNSIGNED_SHORT_5_6_5;
        if (i === na) return t.BYTE;
        if (i === ra) return t.SHORT;
        if (i === aa) return t.UNSIGNED_SHORT;
        if (i === oa) return t.INT;
        if (i === sa) return t.UNSIGNED_INT;
        if (i === ca) return t.FLOAT;
        if (i === ha && null !== (n = e.get('OES_texture_half_float'))) return n.HALF_FLOAT_OES;
        if (i === fa) return t.ALPHA;
        if (i === ma) return t.RGB;
        if (i === va) return t.RGBA;
        if (i === ga) return t.LUMINANCE;
        if (i === ya) return t.LUMINANCE_ALPHA;
        if (i === ba) return t.DEPTH_COMPONENT;
        if (i === _a) return t.DEPTH_STENCIL;
        if (i === cr) return t.FUNC_ADD;
        if (i === hr) return t.FUNC_SUBTRACT;
        if (i === lr) return t.FUNC_REVERSE_SUBTRACT;
        if (i === dr) return t.ZERO;
        if (i === fr) return t.ONE;
        if (i === mr) return t.SRC_COLOR;
        if (i === vr) return t.ONE_MINUS_SRC_COLOR;
        if (i === gr) return t.SRC_ALPHA;
        if (i === yr) return t.ONE_MINUS_SRC_ALPHA;
        if (i === xr) return t.DST_ALPHA;
        if (i === br) return t.ONE_MINUS_DST_ALPHA;
        if (i === _r) return t.DST_COLOR;
        if (i === wr) return t.ONE_MINUS_DST_COLOR;
        if (i === Er) return t.SRC_ALPHA_SATURATE;
        if ((i === wa || i === Ea || i === Ma || i === Ta) && null !== (n = e.get('WEBGL_compressed_texture_s3tc'))) {
          if (i === wa) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (i === Ea) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (i === Ma) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (i === Ta) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        if ((i === Sa || i === Aa || i === Ra || i === La) && null !== (n = e.get('WEBGL_compressed_texture_pvrtc'))) {
          if (i === Sa) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (i === Aa) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (i === Ra) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (i === La) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (i === Pa && null !== (n = e.get('WEBGL_compressed_texture_etc1'))) return n.COMPRESSED_RGB_ETC1_WEBGL;
        if ((i === ur || i === pr) && null !== (n = e.get('EXT_blend_minmax'))) {
          if (i === ur) return n.MIN_EXT;
          if (i === pr) return n.MAX_EXT;
        }
        return i === da && null !== (n = e.get('WEBGL_depth_texture')) ? n.UNSIGNED_INT_24_8_WEBGL : 0;
      },
    };
  }
  function bt(t) {
    function e() {
      return null === Y ? wt : 1;
    }
    function s() {
      ((Nt = new (function (t) {
        const e = {};
        return {
          get: function (i) {
            if (void 0 !== e[i]) return e[i];
            let n;
            switch (i) {
              case 'WEBGL_depth_texture':
                n =
                  t.getExtension('WEBGL_depth_texture') ||
                  t.getExtension('MOZ_WEBGL_depth_texture') ||
                  t.getExtension('WEBKIT_WEBGL_depth_texture');
                break;
              case 'EXT_texture_filter_anisotropic':
                n =
                  t.getExtension('EXT_texture_filter_anisotropic') ||
                  t.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
                  t.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                break;
              case 'WEBGL_compressed_texture_s3tc':
                n =
                  t.getExtension('WEBGL_compressed_texture_s3tc') ||
                  t.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
                  t.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                break;
              case 'WEBGL_compressed_texture_pvrtc':
                n =
                  t.getExtension('WEBGL_compressed_texture_pvrtc') ||
                  t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                break;
              case 'WEBGL_compressed_texture_etc1':
                n = t.getExtension('WEBGL_compressed_texture_etc1');
                break;
              default:
                n = t.getExtension(i);
            }
            return (
              null === n && console.warn('THREE.WebGLRenderer: ' + i + ' extension not supported.'),
              (e[i] = n),
              n
            );
          },
        };
      })(Ot)).get('WEBGL_depth_texture'),
        Nt.get('OES_texture_float'),
        Nt.get('OES_texture_float_linear'),
        Nt.get('OES_texture_half_float'),
        Nt.get('OES_texture_half_float_linear'),
        Nt.get('OES_standard_derivatives'),
        Nt.get('OES_element_index_uint'),
        Nt.get('ANGLE_instanced_arrays'),
        ($t = new xt(Ot, Nt)),
        (Bt = new (function (t, e, i) {
          function n(e) {
            if ('highp' === e) {
              if (
                t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 &&
                t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0
              )
                return 'highp';
              e = 'mediump';
            }
            return 'mediump' === e &&
              t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 &&
              t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0
              ? 'mediump'
              : 'lowp';
          }
          let r,
            a = void 0 !== i.precision ? i.precision : 'highp',
            o = n(a);
          o !== a && (console.warn('THREE.WebGLRenderer:', a, 'not supported, using', o, 'instead.'), (a = o));
          const s = !0 === i.logarithmicDepthBuffer,
            c = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
            h = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            l = t.getParameter(t.MAX_TEXTURE_SIZE),
            u = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
            p = t.getParameter(t.MAX_VERTEX_ATTRIBS),
            d = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
            f = t.getParameter(t.MAX_VARYING_VECTORS),
            m = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
            v = h > 0,
            g = !!e.get('OES_texture_float');
          return {
            getMaxAnisotropy: function () {
              if (void 0 !== r) return r;
              const i = e.get('EXT_texture_filter_anisotropic');
              return (r = null !== i ? t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0);
            },
            getMaxPrecision: n,
            precision: a,
            logarithmicDepthBuffer: s,
            maxTextures: c,
            maxVertexTextures: h,
            maxTextureSize: l,
            maxCubemapSize: u,
            maxAttributes: p,
            maxVertexUniforms: d,
            maxVaryings: f,
            maxFragmentUniforms: m,
            vertexTextures: v,
            floatFragmentTextures: g,
            floatVertexTextures: v && g,
          };
        })(Ot, Nt, t)),
        (Ft = new (function (t, e, i) {
          function n(e, i, n) {
            const r = new Uint8Array(4),
              a = t.createTexture();
            (t.bindTexture(e, a),
              t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
              t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST));
            for (let o = 0; o < n; o++) t.texImage2D(i + o, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
            return a;
          }
          function r(e) {
            !0 !== x[e] && (t.enable(e), (x[e] = !0));
          }
          function a(e) {
            !1 !== x[e] && (t.disable(e), (x[e] = !1));
          }
          function o(e, n, o, s, c, h, l, u) {
            if ((e !== ir ? r(t.BLEND) : a(t.BLEND), e !== sr)) {
              if (e !== w || u !== L)
                switch (e) {
                  case rr:
                    u
                      ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                        t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE))
                      : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.SRC_ALPHA, t.ONE));
                    break;
                  case ar:
                    u
                      ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                        t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA))
                      : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR));
                    break;
                  case or:
                    u
                      ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                        t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA))
                      : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.SRC_COLOR));
                    break;
                  default:
                    u
                      ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                        t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA))
                      : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                        t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA));
                }
              ((E = null), (M = null), (T = null), (S = null), (A = null), (R = null));
            } else
              ((c = c || n),
                (h = h || o),
                (l = l || s),
                (n === E && c === S) || (t.blendEquationSeparate(i.convert(n), i.convert(c)), (E = n), (S = c)),
                (o === M && s === T && h === A && l === R) ||
                  (t.blendFuncSeparate(i.convert(o), i.convert(s), i.convert(h), i.convert(l)),
                  (M = o),
                  (T = s),
                  (A = h),
                  (R = l)));
            ((w = e), (L = u));
          }
          function s(e) {
            P !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), (P = e));
          }
          function h(e) {
            (e !== jn
              ? (r(t.CULL_FACE),
                e !== C &&
                  (e === Wn ? t.cullFace(t.BACK) : e === Xn ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK)))
              : a(t.CULL_FACE),
              (C = e));
          }
          function l(e, i, n) {
            e
              ? (r(t.POLYGON_OFFSET_FILL), (D === i && O === n) || (t.polygonOffset(i, n), (D = i), (O = n)))
              : a(t.POLYGON_OFFSET_FILL);
          }
          function u(e) {
            (void 0 === e && (e = t.TEXTURE0 + U - 1), F !== e && (t.activeTexture(e), (F = e)));
          }
          var p = new (function () {
              let e = !1,
                i = new c(),
                n = null,
                r = new c(0, 0, 0, 0);
              return {
                setMask: function (i) {
                  n === i || e || (t.colorMask(i, i, i, i), (n = i));
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e, n, a, o, s) {
                  (!0 === s && ((e *= o), (n *= o), (a *= o)),
                    i.set(e, n, a, o),
                    !1 === r.equals(i) && (t.clearColor(e, n, a, o), r.copy(i)));
                },
                reset: function () {
                  ((e = !1), (n = null), r.set(-1, 0, 0, 0));
                },
              };
            })(),
            d = new (function () {
              let e = !1,
                i = null,
                n = null,
                o = null;
              return {
                setTest: function (e) {
                  e ? r(t.DEPTH_TEST) : a(t.DEPTH_TEST);
                },
                setMask: function (n) {
                  i === n || e || (t.depthMask(n), (i = n));
                },
                setFunc: function (e) {
                  if (n !== e) {
                    if (e)
                      switch (e) {
                        case Mr:
                          t.depthFunc(t.NEVER);
                          break;
                        case Tr:
                          t.depthFunc(t.ALWAYS);
                          break;
                        case Sr:
                          t.depthFunc(t.LESS);
                          break;
                        case Ar:
                          t.depthFunc(t.LEQUAL);
                          break;
                        case Rr:
                          t.depthFunc(t.EQUAL);
                          break;
                        case Lr:
                          t.depthFunc(t.GEQUAL);
                          break;
                        case Pr:
                          t.depthFunc(t.GREATER);
                          break;
                        case Cr:
                          t.depthFunc(t.NOTEQUAL);
                          break;
                        default:
                          t.depthFunc(t.LEQUAL);
                      }
                    else t.depthFunc(t.LEQUAL);
                    n = e;
                  }
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e) {
                  o !== e && (t.clearDepth(e), (o = e));
                },
                reset: function () {
                  ((e = !1), (i = null), (n = null), (o = null));
                },
              };
            })(),
            f = new (function () {
              let e = !1,
                i = null,
                n = null,
                o = null,
                s = null,
                c = null,
                h = null,
                l = null,
                u = null;
              return {
                setTest: function (e) {
                  e ? r(t.STENCIL_TEST) : a(t.STENCIL_TEST);
                },
                setMask: function (n) {
                  i === n || e || (t.stencilMask(n), (i = n));
                },
                setFunc: function (e, i, r) {
                  (n === e && o === i && s === r) || (t.stencilFunc(e, i, r), (n = e), (o = i), (s = r));
                },
                setOp: function (e, i, n) {
                  (c === e && h === i && l === n) || (t.stencilOp(e, i, n), (c = e), (h = i), (l = n));
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e) {
                  u !== e && (t.clearStencil(e), (u = e));
                },
                reset: function () {
                  ((e = !1),
                    (i = null),
                    (n = null),
                    (o = null),
                    (s = null),
                    (c = null),
                    (h = null),
                    (l = null),
                    (u = null));
                },
              };
            })(),
            m = t.getParameter(t.MAX_VERTEX_ATTRIBS),
            v = new Uint8Array(m),
            g = new Uint8Array(m),
            y = new Uint8Array(m),
            x = {},
            b = null,
            _ = null,
            w = null,
            E = null,
            M = null,
            T = null,
            S = null,
            A = null,
            R = null,
            L = !1,
            P = null,
            C = null,
            I = null,
            D = null,
            O = null,
            U = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
            N = parseFloat(/^WebGL\ ([0-9])/.exec(t.getParameter(t.VERSION))[1]),
            B = parseFloat(N) >= 1,
            F = null,
            z = {},
            G = new c(),
            H = new c(),
            V = {};
          return (
            (V[t.TEXTURE_2D] = n(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
            (V[t.TEXTURE_CUBE_MAP] = n(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6)),
            p.setClear(0, 0, 0, 1),
            d.setClear(1),
            f.setClear(0),
            r(t.DEPTH_TEST),
            d.setFunc(Ar),
            s(!1),
            h(Wn),
            r(t.CULL_FACE),
            r(t.BLEND),
            o(nr),
            {
              buffers: { color: p, depth: d, stencil: f },
              initAttributes: function () {
                for (let t = 0, e = v.length; t < e; t++) v[t] = 0;
              },
              enableAttribute: function (i) {
                ((v[i] = 1),
                  0 === g[i] && (t.enableVertexAttribArray(i), (g[i] = 1)),
                  0 !== y[i] && (e.get('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(i, 0), (y[i] = 0)));
              },
              enableAttributeAndDivisor: function (i, n) {
                ((v[i] = 1),
                  0 === g[i] && (t.enableVertexAttribArray(i), (g[i] = 1)),
                  y[i] !== n && (e.get('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(i, n), (y[i] = n)));
              },
              disableUnusedAttributes: function () {
                for (let e = 0, i = g.length; e !== i; ++e)
                  g[e] !== v[e] && (t.disableVertexAttribArray(e), (g[e] = 0));
              },
              enable: r,
              disable: a,
              getCompressedTextureFormats: function () {
                if (
                  null === b &&
                  ((b = []),
                  e.get('WEBGL_compressed_texture_pvrtc') ||
                    e.get('WEBGL_compressed_texture_s3tc') ||
                    e.get('WEBGL_compressed_texture_etc1'))
                )
                  for (let i = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), n = 0; n < i.length; n++) b.push(i[n]);
                return b;
              },
              useProgram: function (e) {
                return _ !== e && (t.useProgram(e), (_ = e), !0);
              },
              setBlending: o,
              setMaterial: function (e) {
                (e.side === Kn ? a(t.CULL_FACE) : r(t.CULL_FACE),
                  s(e.side === Jn),
                  !0 === e.transparent
                    ? o(
                        e.blending,
                        e.blendEquation,
                        e.blendSrc,
                        e.blendDst,
                        e.blendEquationAlpha,
                        e.blendSrcAlpha,
                        e.blendDstAlpha,
                        e.premultipliedAlpha
                      )
                    : o(ir),
                  d.setFunc(e.depthFunc),
                  d.setTest(e.depthTest),
                  d.setMask(e.depthWrite),
                  p.setMask(e.colorWrite),
                  l(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits));
              },
              setFlipSided: s,
              setCullFace: h,
              setLineWidth: function (e) {
                e !== I && (B && t.lineWidth(e), (I = e));
              },
              setPolygonOffset: l,
              setScissorTest: function (e) {
                e ? r(t.SCISSOR_TEST) : a(t.SCISSOR_TEST);
              },
              activeTexture: u,
              bindTexture: function (e, i) {
                null === F && u();
                let n = z[F];
                (void 0 === n && ((n = { type: void 0, texture: void 0 }), (z[F] = n)),
                  (n.type === e && n.texture === i) || (t.bindTexture(e, i || V[e]), (n.type = e), (n.texture = i)));
              },
              compressedTexImage2D: function () {
                try {
                  t.compressedTexImage2D.apply(t, arguments);
                } catch (t) {
                  console.error('THREE.WebGLState:', t);
                }
              },
              texImage2D: function () {
                try {
                  t.texImage2D.apply(t, arguments);
                } catch (t) {
                  console.error('THREE.WebGLState:', t);
                }
              },
              scissor: function (e) {
                !1 === G.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), G.copy(e));
              },
              viewport: function (e) {
                !1 === H.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), H.copy(e));
              },
              reset: function () {
                for (let e = 0; e < g.length; e++) 1 === g[e] && (t.disableVertexAttribArray(e), (g[e] = 0));
                ((x = {}),
                  (b = null),
                  (F = null),
                  (z = {}),
                  (_ = null),
                  (w = null),
                  (P = null),
                  (C = null),
                  p.reset(),
                  d.reset(),
                  f.reset());
              },
            }
          );
        })(Ot, Nt, $t)).scissor(st.copy(Mt).multiplyScalar(wt)),
        Ft.viewport(ot.copy(Et).multiplyScalar(wt)),
        (zt = new (function () {
          let t = {};
          return {
            get: function (e) {
              let i = e.uuid,
                n = t[i];
              return (void 0 === n && ((n = {}), (t[i] = n)), n);
            },
            remove: function (e) {
              delete t[e.uuid];
            },
            clear: function () {
              t = {};
            },
          };
        })()),
        (Gt = new (function (t, e, i, n, r, a, o) {
          function s(t, e) {
            if (t.width > e || t.height > e) {
              const i = e / Math.max(t.width, t.height),
                n = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
              return (
                (n.width = Math.floor(t.width * i)),
                (n.height = Math.floor(t.height * i)),
                n.getContext('2d').drawImage(t, 0, 0, t.width, t.height, 0, 0, n.width, n.height),
                console.warn(
                  'THREE.WebGLRenderer: image is too big (' +
                    t.width +
                    'x' +
                    t.height +
                    '). Resized to ' +
                    n.width +
                    'x' +
                    n.height,
                  t
                ),
                n
              );
            }
            return t;
          }
          function c(t) {
            return Wa.isPowerOfTwo(t.width) && Wa.isPowerOfTwo(t.height);
          }
          function h(t, e) {
            return t.generateMipmaps && e && t.minFilter !== Qr && t.minFilter !== $r;
          }
          function l(e) {
            return e === Qr || e === Jr || e === Kr ? t.NEAREST : t.LINEAR;
          }
          function u(e) {
            const i = e.target;
            (i.removeEventListener('dispose', u),
              (function (e) {
                const i = n.get(e);
                if (e.image && i.__image__webglTextureCube) t.deleteTexture(i.__image__webglTextureCube);
                else {
                  if (void 0 === i.__webglInit) return;
                  t.deleteTexture(i.__webglTexture);
                }
                n.remove(e);
              })(i),
              o.textures--);
          }
          function p(e) {
            const i = e.target;
            (i.removeEventListener('dispose', p),
              (function (e) {
                const i = n.get(e),
                  r = n.get(e.texture);
                if (e) {
                  if (
                    (void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture),
                    e.depthTexture && e.depthTexture.dispose(),
                    e.isWebGLRenderTargetCube)
                  )
                    for (let a = 0; a < 6; a++)
                      (t.deleteFramebuffer(i.__webglFramebuffer[a]),
                        i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[a]));
                  else
                    (t.deleteFramebuffer(i.__webglFramebuffer),
                      i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer));
                  (n.remove(e.texture), n.remove(e));
                }
              })(i),
              o.textures--);
          }
          function d(e, l) {
            const p = n.get(e);
            if (e.version > 0 && p.__version !== e.version) {
              const d = e.image;
              if (void 0 === d)
                console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined', e);
              else {
                if (!1 !== d.complete)
                  return void (function (e, n, l) {
                    (void 0 === e.__webglInit &&
                      ((e.__webglInit = !0),
                      n.addEventListener('dispose', u),
                      (e.__webglTexture = t.createTexture()),
                      o.textures++),
                      i.activeTexture(t.TEXTURE0 + l),
                      i.bindTexture(t.TEXTURE_2D, e.__webglTexture),
                      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, n.flipY),
                      t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha),
                      t.pixelStorei(t.UNPACK_ALIGNMENT, n.unpackAlignment));
                    let p = s(n.image, r.maxTextureSize);
                    (function (t) {
                      return t.wrapS !== Yr || t.wrapT !== Yr || (t.minFilter !== Qr && t.minFilter !== $r);
                    })(n) &&
                      !1 === c(p) &&
                      (p = (function (t) {
                        if (
                          t instanceof HTMLImageElement ||
                          t instanceof HTMLCanvasElement ||
                          t instanceof ImageBitmap
                        ) {
                          const e = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                          return (
                            (e.width = Wa.floorPowerOfTwo(t.width)),
                            (e.height = Wa.floorPowerOfTwo(t.height)),
                            e.getContext('2d').drawImage(t, 0, 0, e.width, e.height),
                            console.warn(
                              'THREE.WebGLRenderer: image is not power of two (' +
                                t.width +
                                'x' +
                                t.height +
                                '). Resized to ' +
                                e.width +
                                'x' +
                                e.height,
                              t
                            ),
                            e
                          );
                        }
                        return t;
                      })(p));
                    let d = c(p),
                      m = a.convert(n.format),
                      v = a.convert(n.type);
                    f(t.TEXTURE_2D, n, d);
                    let y,
                      x = n.mipmaps;
                    if (n.isDepthTexture) {
                      let b = t.DEPTH_COMPONENT;
                      if (n.type === ca) {
                        if (!g) throw new Error('Float Depth Texture only supported in WebGL2.0');
                        b = t.DEPTH_COMPONENT32F;
                      } else g && (b = t.DEPTH_COMPONENT16);
                      (n.format === ba &&
                        b === t.DEPTH_COMPONENT &&
                        n.type !== aa &&
                        n.type !== sa &&
                        (console.warn(
                          'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.'
                        ),
                        (n.type = aa),
                        (v = a.convert(n.type))),
                        n.format === _a &&
                          ((b = t.DEPTH_STENCIL),
                          n.type !== da &&
                            (console.warn(
                              'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.'
                            ),
                            (n.type = da),
                            (v = a.convert(n.type)))),
                        i.texImage2D(t.TEXTURE_2D, 0, b, p.width, p.height, 0, m, v, null));
                    } else if (n.isDataTexture)
                      if (x.length > 0 && d) {
                        for (var _ = 0, w = x.length; _ < w; _++)
                          ((y = x[_]), i.texImage2D(t.TEXTURE_2D, _, m, y.width, y.height, 0, m, v, y.data));
                        n.generateMipmaps = !1;
                      } else i.texImage2D(t.TEXTURE_2D, 0, m, p.width, p.height, 0, m, v, p.data);
                    else if (n.isCompressedTexture)
                      for (var _ = 0, w = x.length; _ < w; _++)
                        ((y = x[_]),
                          n.format !== va && n.format !== ma
                            ? i.getCompressedTextureFormats().indexOf(m) > -1
                              ? i.compressedTexImage2D(t.TEXTURE_2D, _, m, y.width, y.height, 0, y.data)
                              : console.warn(
                                  'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                                )
                            : i.texImage2D(t.TEXTURE_2D, _, m, y.width, y.height, 0, m, v, y.data));
                    else if (x.length > 0 && d) {
                      for (var _ = 0, w = x.length; _ < w; _++) ((y = x[_]), i.texImage2D(t.TEXTURE_2D, _, m, m, v, y));
                      n.generateMipmaps = !1;
                    } else i.texImage2D(t.TEXTURE_2D, 0, m, m, v, p);
                    (h(n, d) && t.generateMipmap(t.TEXTURE_2D), (e.__version = n.version), n.onUpdate && n.onUpdate(n));
                  })(p, e, l);
                console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete', e);
              }
            }
            (i.activeTexture(t.TEXTURE0 + l), i.bindTexture(t.TEXTURE_2D, p.__webglTexture));
          }
          function f(i, o, s) {
            let c;
            if (
              (s
                ? (t.texParameteri(i, t.TEXTURE_WRAP_S, a.convert(o.wrapS)),
                  t.texParameteri(i, t.TEXTURE_WRAP_T, a.convert(o.wrapT)),
                  t.texParameteri(i, t.TEXTURE_MAG_FILTER, a.convert(o.magFilter)),
                  t.texParameteri(i, t.TEXTURE_MIN_FILTER, a.convert(o.minFilter)))
                : (t.texParameteri(i, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
                  t.texParameteri(i, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
                  (o.wrapS === Yr && o.wrapT === Yr) ||
                    console.warn(
                      'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.',
                      o
                    ),
                  t.texParameteri(i, t.TEXTURE_MAG_FILTER, l(o.magFilter)),
                  t.texParameteri(i, t.TEXTURE_MIN_FILTER, l(o.minFilter)),
                  o.minFilter !== Qr &&
                    o.minFilter !== $r &&
                    console.warn(
                      'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.',
                      o
                    )),
              (c = e.get('EXT_texture_filter_anisotropic')))
            ) {
              if (o.type === ca && null === e.get('OES_texture_float_linear')) return;
              if (o.type === ha && null === e.get('OES_texture_half_float_linear')) return;
              (o.anisotropy > 1 || n.get(o).__currentAnisotropy) &&
                (t.texParameterf(i, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())),
                (n.get(o).__currentAnisotropy = o.anisotropy));
            }
          }
          function m(e, r, o, s) {
            const c = a.convert(r.texture.format),
              h = a.convert(r.texture.type);
            (i.texImage2D(s, 0, c, r.width, r.height, 0, c, h, null),
              t.bindFramebuffer(t.FRAMEBUFFER, e),
              t.framebufferTexture2D(t.FRAMEBUFFER, o, s, n.get(r.texture).__webglTexture, 0),
              t.bindFramebuffer(t.FRAMEBUFFER, null));
          }
          function v(e, i) {
            (t.bindRenderbuffer(t.RENDERBUFFER, e),
              i.depthBuffer && !i.stencilBuffer
                ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, i.width, i.height),
                  t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e))
                : i.depthBuffer && i.stencilBuffer
                  ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, i.width, i.height),
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e))
                  : t.renderbufferStorage(t.RENDERBUFFER, t.RGBA4, i.width, i.height),
              t.bindRenderbuffer(t.RENDERBUFFER, null));
          }
          var g = 'undefined' != typeof WebGL2RenderingContext && t instanceof window.WebGL2RenderingContext;
          ((this.setTexture2D = d),
            (this.setTextureCube = function (e, l) {
              const p = n.get(e);
              if (6 === e.image.length)
                if (e.version > 0 && p.__version !== e.version) {
                  (p.__image__webglTextureCube ||
                    (e.addEventListener('dispose', u), (p.__image__webglTextureCube = t.createTexture()), o.textures++),
                    i.activeTexture(t.TEXTURE0 + l),
                    i.bindTexture(t.TEXTURE_CUBE_MAP, p.__image__webglTextureCube),
                    t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY));
                  for (
                    var d = e && e.isCompressedTexture, m = e.image[0] && e.image[0].isDataTexture, v = [], g = 0;
                    g < 6;
                    g++
                  )
                    v[g] = d || m ? (m ? e.image[g].image : e.image[g]) : s(e.image[g], r.maxCubemapSize);
                  const y = c(v[0]),
                    x = a.convert(e.format),
                    b = a.convert(e.type);
                  for (f(t.TEXTURE_CUBE_MAP, e, y), g = 0; g < 6; g++)
                    if (d)
                      for (var _, w = v[g].mipmaps, E = 0, M = w.length; E < M; E++)
                        ((_ = w[E]),
                          e.format !== va && e.format !== ma
                            ? i.getCompressedTextureFormats().indexOf(x) > -1
                              ? i.compressedTexImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + g,
                                  E,
                                  x,
                                  _.width,
                                  _.height,
                                  0,
                                  _.data
                                )
                              : console.warn(
                                  'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()'
                                )
                            : i.texImage2D(
                                t.TEXTURE_CUBE_MAP_POSITIVE_X + g,
                                E,
                                x,
                                _.width,
                                _.height,
                                0,
                                x,
                                b,
                                _.data
                              ));
                    else
                      m
                        ? i.texImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + g,
                            0,
                            x,
                            v[g].width,
                            v[g].height,
                            0,
                            x,
                            b,
                            v[g].data
                          )
                        : i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, 0, x, x, b, v[g]);
                  (h(e, y) && t.generateMipmap(t.TEXTURE_CUBE_MAP),
                    (p.__version = e.version),
                    e.onUpdate && e.onUpdate(e));
                } else
                  (i.activeTexture(t.TEXTURE0 + l), i.bindTexture(t.TEXTURE_CUBE_MAP, p.__image__webglTextureCube));
            }),
            (this.setTextureCubeDynamic = function (e, r) {
              (i.activeTexture(t.TEXTURE0 + r), i.bindTexture(t.TEXTURE_CUBE_MAP, n.get(e).__webglTexture));
            }),
            (this.setupRenderTarget = function (e) {
              const r = n.get(e),
                a = n.get(e.texture);
              (e.addEventListener('dispose', p), (a.__webglTexture = t.createTexture()), o.textures++);
              const s = !0 === e.isWebGLRenderTargetCube,
                l = c(e);
              if (s) for (r.__webglFramebuffer = [], u = 0; u < 6; u++) r.__webglFramebuffer[u] = t.createFramebuffer();
              else r.__webglFramebuffer = t.createFramebuffer();
              if (s) {
                (i.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture), f(t.TEXTURE_CUBE_MAP, e.texture, l));
                for (var u = 0; u < 6; u++)
                  m(r.__webglFramebuffer[u], e, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + u);
                (h(e.texture, l) && t.generateMipmap(t.TEXTURE_CUBE_MAP), i.bindTexture(t.TEXTURE_CUBE_MAP, null));
              } else
                (i.bindTexture(t.TEXTURE_2D, a.__webglTexture),
                  f(t.TEXTURE_2D, e.texture, l),
                  m(r.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D),
                  h(e.texture, l) && t.generateMipmap(t.TEXTURE_2D),
                  i.bindTexture(t.TEXTURE_2D, null));
              e.depthBuffer &&
                (function (e) {
                  const i = n.get(e),
                    r = !0 === e.isWebGLRenderTargetCube;
                  if (e.depthTexture) {
                    if (r) throw new Error('target.depthTexture not supported in Cube render targets');
                    !(function (e, i) {
                      if (i && i.isWebGLRenderTargetCube)
                        throw new Error('Depth Texture with cube render targets is not supported');
                      if ((t.bindFramebuffer(t.FRAMEBUFFER, e), !i.depthTexture || !i.depthTexture.isDepthTexture))
                        throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
                      ((n.get(i.depthTexture).__webglTexture &&
                        i.depthTexture.image.width === i.width &&
                        i.depthTexture.image.height === i.height) ||
                        ((i.depthTexture.image.width = i.width),
                        (i.depthTexture.image.height = i.height),
                        (i.depthTexture.needsUpdate = !0)),
                        d(i.depthTexture, 0));
                      const r = n.get(i.depthTexture).__webglTexture;
                      if (i.depthTexture.format === ba)
                        t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, r, 0);
                      else {
                        if (i.depthTexture.format !== _a) throw new Error('Unknown depthTexture format');
                        t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, r, 0);
                      }
                    })(i.__webglFramebuffer, e);
                  } else if (r) {
                    i.__webglDepthbuffer = [];
                    for (let a = 0; a < 6; a++)
                      (t.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer[a]),
                        (i.__webglDepthbuffer[a] = t.createRenderbuffer()),
                        v(i.__webglDepthbuffer[a], e));
                  } else
                    (t.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer),
                      (i.__webglDepthbuffer = t.createRenderbuffer()),
                      v(i.__webglDepthbuffer, e));
                  t.bindFramebuffer(t.FRAMEBUFFER, null);
                })(e);
            }),
            (this.updateRenderTargetMipmap = function (e) {
              const r = e.texture;
              if (h(r, c(e))) {
                const a = e.isWebGLRenderTargetCube ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                  o = n.get(r).__webglTexture;
                (i.bindTexture(a, o), t.generateMipmap(a), i.bindTexture(a, null));
              }
            }));
        })(Ot, Nt, Ft, zt, Bt, $t, It)),
        (Ht = new (function (t) {
          const e = {};
          return {
            get: function (t) {
              return (t.isInterleavedBufferAttribute && (t = t.data), e[t.uuid]);
            },
            remove: function (i) {
              i.isInterleavedBufferAttribute && (i = i.data);
              const n = e[i.uuid];
              n && (t.deleteBuffer(n.buffer), delete e[i.uuid]);
            },
            update: function (i, n) {
              i.isInterleavedBufferAttribute && (i = i.data);
              const r = e[i.uuid];
              void 0 === r
                ? (e[i.uuid] = (function (e, i) {
                    const n = e.array,
                      r = e.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW,
                      a = t.createBuffer();
                    (t.bindBuffer(i, a), t.bufferData(i, n, r), e.onUploadCallback());
                    let o = t.FLOAT;
                    return (
                      n instanceof Float32Array
                        ? (o = t.FLOAT)
                        : n instanceof Float64Array
                          ? console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.')
                          : n instanceof Uint16Array
                            ? (o = t.UNSIGNED_SHORT)
                            : n instanceof Int16Array
                              ? (o = t.SHORT)
                              : n instanceof Uint32Array
                                ? (o = t.UNSIGNED_INT)
                                : n instanceof Int32Array
                                  ? (o = t.INT)
                                  : n instanceof Int8Array
                                    ? (o = t.BYTE)
                                    : n instanceof Uint8Array && (o = t.UNSIGNED_BYTE),
                      { buffer: a, type: o, bytesPerElement: n.BYTES_PER_ELEMENT, version: e.version }
                    );
                  })(i, n))
                : r.version < i.version &&
                  ((function (e, i, n) {
                    const r = i.array,
                      a = i.updateRange;
                    (t.bindBuffer(n, e),
                      !1 === i.dynamic
                        ? t.bufferData(n, r, t.STATIC_DRAW)
                        : -1 === a.count
                          ? t.bufferSubData(n, 0, r)
                          : 0 === a.count
                            ? console.error(
                                'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.'
                              )
                            : (t.bufferSubData(
                                n,
                                a.offset * r.BYTES_PER_ELEMENT,
                                r.subarray(a.offset, a.offset + a.count)
                              ),
                              (a.count = -1)));
                  })(r.buffer, i, n),
                  (r.version = i.version));
            },
          };
        })(Ot)),
        (Vt = new (function (t, e, i) {
          function n(t) {
            const o = t.target,
              s = r[o.id];
            null !== s.index && e.remove(s.index);
            for (const c in s.attributes) e.remove(s.attributes[c]);
            (o.removeEventListener('dispose', n), delete r[o.id]);
            let h = a[o.id];
            (h && (e.remove(h), delete a[o.id]), (h = a[s.id]) && (e.remove(h), delete a[s.id]), i.geometries--);
          }
          var r = {},
            a = {};
          return {
            get: function (t, e) {
              let a = r[e.id];
              return (
                a ||
                (e.addEventListener('dispose', n),
                e.isBufferGeometry
                  ? (a = e)
                  : e.isGeometry &&
                    (void 0 === e._bufferGeometry && (e._bufferGeometry = new K().setFromObject(t)),
                    (a = e._bufferGeometry)),
                (r[e.id] = a),
                i.geometries++,
                a)
              );
            },
            update: function (i) {
              const n = i.index,
                r = i.attributes;
              null !== n && e.update(n, t.ELEMENT_ARRAY_BUFFER);
              for (var a in r) e.update(r[a], t.ARRAY_BUFFER);
              const o = i.morphAttributes;
              for (var a in o) for (let s = o[a], c = 0, h = s.length; c < h; c++) e.update(s[c], t.ARRAY_BUFFER);
            },
            getWireframeAttribute: function (i) {
              let n = a[i.id];
              if (n) return n;
              const r = [],
                o = i.index,
                s = i.attributes;
              if (null !== o)
                for (var c = 0, h = (d = o.array).length; c < h; c += 3) {
                  var l = d[c + 0],
                    u = d[c + 1],
                    p = d[c + 2];
                  r.push(l, u, u, p, p, l);
                }
              else
                for (var d = s.position.array, c = 0, h = d.length / 3 - 1; c < h; c += 3) {
                  var l = c + 0,
                    u = c + 1,
                    p = c + 2;
                  r.push(l, u, u, p, p, l);
                }
              return ((n = new (J(r) > 65535 ? q : W)(r, 1)), e.update(n, t.ELEMENT_ARRAY_BUFFER), (a[i.id] = n), n);
            },
          };
        })(Ot, Ht, It)),
        (kt = new (function (t, e) {
          let i = {};
          return {
            update: function (n) {
              const r = e.frame,
                a = n.geometry,
                o = t.get(n, a);
              return (i[o.id] !== r && (a.isGeometry && o.updateFromObject(n), t.update(o), (i[o.id] = r)), o);
            },
            clear: function () {
              i = {};
            },
          };
        })(Vt, Dt)),
        (Yt = new (function (t) {
          const e = {},
            i = new Float32Array(8);
          return {
            update: function (n, r, a, o) {
              let s = n.morphTargetInfluences,
                c = s.length,
                h = e[r.id];
              if (void 0 === h) {
                for (h = [], p = 0; p < c; p++) h[p] = [p, 0];
                e[r.id] = h;
              }
              for (
                var l = a.morphTargets && r.morphAttributes.position,
                  u = a.morphNormals && r.morphAttributes.normal,
                  p = 0;
                p < c;
                p++
              )
                0 !== (d = h[p])[1] &&
                  (l && r.removeAttribute('morphTarget' + p), u && r.removeAttribute('morphNormal' + p));
              for (p = 0; p < c; p++) (((d = h[p])[0] = p), (d[1] = s[p]));
              for (
                h.sort(function (t, e) {
                  return Math.abs(e[1]) - Math.abs(t[1]);
                }),
                  p = 0;
                p < 8;
                p++
              ) {
                var d = h[p];
                if (d) {
                  const f = d[0],
                    m = d[1];
                  if (m) {
                    (l && r.addAttribute('morphTarget' + p, l[f]),
                      u && r.addAttribute('morphNormal' + p, u[f]),
                      (i[p] = m));
                    continue;
                  }
                }
                i[p] = 0;
              }
              o.getUniforms().setValue(t, 'morphTargetInfluences', i);
            },
          };
        })(Ot)),
        (Wt = new (function (t, e, i) {
          function n(t, e) {
            let i;
            return (
              t
                ? t.isTexture
                  ? (i = t.encoding)
                  : t.isWebGLRenderTarget &&
                    (console.warn(
                      "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                    ),
                    (i = t.texture.encoding))
                : (i = Na),
              i === Na && e && (i = Fa),
              i
            );
          }
          const r = [],
            a = {
              MeshDepthMaterial: 'depth',
              MeshDistanceMaterial: 'distanceRGBA',
              MeshNormalMaterial: 'normal',
              MeshBasicMaterial: 'basic',
              MeshLambertMaterial: 'lambert',
              MeshPhongMaterial: 'phong',
              MeshToonMaterial: 'phong',
              MeshStandardMaterial: 'physical',
              MeshPhysicalMaterial: 'physical',
              LineBasicMaterial: 'basic',
              LineDashedMaterial: 'dashed',
              PointsMaterial: 'points',
              ShadowMaterial: 'shadow',
            },
            o = [
              'precision',
              'supportsVertexTextures',
              'map',
              'mapEncoding',
              'envMap',
              'envMapMode',
              'envMapEncoding',
              'lightMap',
              'aoMap',
              'emissiveMap',
              'emissiveMapEncoding',
              'bumpMap',
              'normalMap',
              'displacementMap',
              'specularMap',
              'roughnessMap',
              'metalnessMap',
              'gradientMap',
              'alphaMap',
              'combine',
              'vertexColors',
              'fog',
              'useFog',
              'fogExp',
              'flatShading',
              'sizeAttenuation',
              'logarithmicDepthBuffer',
              'skinning',
              'maxBones',
              'useVertexTexture',
              'morphTargets',
              'morphNormals',
              'maxMorphTargets',
              'maxMorphNormals',
              'premultipliedAlpha',
              'numDirLights',
              'numPointLights',
              'numSpotLights',
              'numHemiLights',
              'numRectAreaLights',
              'shadowMapEnabled',
              'shadowMapType',
              'toneMapping',
              'physicallyCorrectLights',
              'alphaTest',
              'doubleSided',
              'flipSided',
              'numClippingPlanes',
              'numClipIntersection',
              'depthPacking',
              'dithering',
            ];
          ((this.getParameters = function (e, r, o, s, c, h, l) {
            let u = a[e.type],
              p = l.isSkinnedMesh
                ? (function (t) {
                    const e = t.skeleton.bones;
                    if (i.floatVertexTextures) return 1024;
                    const n = i.maxVertexUniforms,
                      r = Math.floor((n - 20) / 4),
                      a = Math.min(r, e.length);
                    return a < e.length
                      ? (console.warn(
                          'THREE.WebGLRenderer: Skeleton has ' + e.length + ' bones. This GPU supports ' + a + '.'
                        ),
                        0)
                      : a;
                  })(l)
                : 0,
              d = i.precision;
            null !== e.precision &&
              (d = i.getMaxPrecision(e.precision)) !== e.precision &&
              console.warn('THREE.WebGLProgram.getParameters:', e.precision, 'not supported, using', d, 'instead.');
            const f = t.getRenderTarget();
            return {
              shaderID: u,
              precision: d,
              supportsVertexTextures: i.vertexTextures,
              outputEncoding: n(f ? f.texture : null, t.gammaOutput),
              map: !!e.map,
              mapEncoding: n(e.map, t.gammaInput),
              envMap: !!e.envMap,
              envMapMode: e.envMap && e.envMap.mapping,
              envMapEncoding: n(e.envMap, t.gammaInput),
              envMapCubeUV: !!e.envMap && (e.envMap.mapping === Wr || e.envMap.mapping === Xr),
              lightMap: !!e.lightMap,
              aoMap: !!e.aoMap,
              emissiveMap: !!e.emissiveMap,
              emissiveMapEncoding: n(e.emissiveMap, t.gammaInput),
              bumpMap: !!e.bumpMap,
              normalMap: !!e.normalMap,
              displacementMap: !!e.displacementMap,
              roughnessMap: !!e.roughnessMap,
              metalnessMap: !!e.metalnessMap,
              specularMap: !!e.specularMap,
              alphaMap: !!e.alphaMap,
              gradientMap: !!e.gradientMap,
              combine: e.combine,
              vertexColors: e.vertexColors,
              fog: !!s,
              useFog: e.fog,
              fogExp: s && s.isFogExp2,
              flatShading: e.flatShading,
              sizeAttenuation: e.sizeAttenuation,
              logarithmicDepthBuffer: i.logarithmicDepthBuffer,
              skinning: e.skinning && p > 0,
              maxBones: p,
              useVertexTexture: i.floatVertexTextures,
              morphTargets: e.morphTargets,
              morphNormals: e.morphNormals,
              maxMorphTargets: t.maxMorphTargets,
              maxMorphNormals: t.maxMorphNormals,
              numDirLights: r.directional.length,
              numPointLights: r.point.length,
              numSpotLights: r.spot.length,
              numRectAreaLights: r.rectArea.length,
              numHemiLights: r.hemi.length,
              numClippingPlanes: c,
              numClipIntersection: h,
              dithering: e.dithering,
              shadowMapEnabled: t.shadowMap.enabled && l.receiveShadow && o.length > 0,
              shadowMapType: t.shadowMap.type,
              toneMapping: t.toneMapping,
              physicallyCorrectLights: t.physicallyCorrectLights,
              premultipliedAlpha: e.premultipliedAlpha,
              alphaTest: e.alphaTest,
              doubleSided: e.side === Kn,
              flipSided: e.side === Jn,
              depthPacking: void 0 !== e.depthPacking && e.depthPacking,
            };
          }),
            (this.getProgramCode = function (e, i) {
              const n = [];
              if (
                (i.shaderID ? n.push(i.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)),
                void 0 !== e.defines)
              )
                for (const r in e.defines) (n.push(r), n.push(e.defines[r]));
              for (let a = 0; a < o.length; a++) n.push(i[o[a]]);
              return (n.push(e.onBeforeCompile.toString()), n.push(t.gammaOutput), n.join());
            }),
            (this.acquireProgram = function (i, n, a, o) {
              for (var s, c = 0, h = r.length; c < h; c++) {
                const l = r[c];
                if (l.code === o) {
                  ++(s = l).usedTimes;
                  break;
                }
              }
              return (
                void 0 === s &&
                  ((s = new (function (t, e, i, n, r, a) {
                    let o = t.context,
                      s = n.defines,
                      c = r.vertexShader,
                      h = r.fragmentShader,
                      l = 'SHADOWMAP_TYPE_BASIC';
                    a.shadowMapType === Yn
                      ? (l = 'SHADOWMAP_TYPE_PCF')
                      : a.shadowMapType === Zn && (l = 'SHADOWMAP_TYPE_PCF_SOFT');
                    let u = 'ENVMAP_TYPE_CUBE',
                      p = 'ENVMAP_MODE_REFLECTION',
                      d = 'ENVMAP_BLENDING_MULTIPLY';
                    if (a.envMap) {
                      switch (n.envMap.mapping) {
                        case Gr:
                        case Hr:
                          u = 'ENVMAP_TYPE_CUBE';
                          break;
                        case Wr:
                        case Xr:
                          u = 'ENVMAP_TYPE_CUBE_UV';
                          break;
                        case Vr:
                        case kr:
                          u = 'ENVMAP_TYPE_EQUIREC';
                          break;
                        case jr:
                          u = 'ENVMAP_TYPE_SPHERE';
                      }
                      switch (n.envMap.mapping) {
                        case Hr:
                        case kr:
                          p = 'ENVMAP_MODE_REFRACTION';
                      }
                      switch (n.combine) {
                        case Ir:
                          d = 'ENVMAP_BLENDING_MULTIPLY';
                          break;
                        case Dr:
                          d = 'ENVMAP_BLENDING_MIX';
                          break;
                        case Or:
                          d = 'ENVMAP_BLENDING_ADD';
                      }
                    }
                    let f,
                      m,
                      v = t.gammaFactor > 0 ? t.gammaFactor : 1,
                      g = (function (t, e, i) {
                        return [
                          (t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap || e.flatShading
                            ? '#extension GL_OES_standard_derivatives : enable'
                            : '',
                          (t.fragDepth || e.logarithmicDepthBuffer) && i.get('EXT_frag_depth')
                            ? '#extension GL_EXT_frag_depth : enable'
                            : '',
                          t.drawBuffers && i.get('WEBGL_draw_buffers')
                            ? '#extension GL_EXT_draw_buffers : require'
                            : '',
                          (t.shaderTextureLOD || e.envMap) && i.get('EXT_shader_texture_lod')
                            ? '#extension GL_EXT_shader_texture_lod : enable'
                            : '',
                        ]
                          .filter(pt)
                          .join('\n');
                      })(n.extensions, a, e),
                      y = (function (t) {
                        const e = [];
                        for (const i in t) {
                          const n = t[i];
                          !1 !== n && e.push('#define ' + i + ' ' + n);
                        }
                        return e.join('\n');
                      })(s),
                      x = o.createProgram();
                    (n.isRawShaderMaterial
                      ? ((f = [y].filter(pt).join('\n')).length > 0 && (f += '\n'),
                        (m = [g, y].filter(pt).join('\n')).length > 0 && (m += '\n'))
                      : ((f = [
                          'precision ' + a.precision + ' float;',
                          'precision ' + a.precision + ' int;',
                          '#define SHADER_NAME ' + r.name,
                          y,
                          a.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
                          '#define GAMMA_FACTOR ' + v,
                          '#define MAX_BONES ' + a.maxBones,
                          a.useFog && a.fog ? '#define USE_FOG' : '',
                          a.useFog && a.fogExp ? '#define FOG_EXP2' : '',
                          a.map ? '#define USE_MAP' : '',
                          a.envMap ? '#define USE_ENVMAP' : '',
                          a.envMap ? '#define ' + p : '',
                          a.lightMap ? '#define USE_LIGHTMAP' : '',
                          a.aoMap ? '#define USE_AOMAP' : '',
                          a.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                          a.bumpMap ? '#define USE_BUMPMAP' : '',
                          a.normalMap ? '#define USE_NORMALMAP' : '',
                          a.displacementMap && a.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
                          a.specularMap ? '#define USE_SPECULARMAP' : '',
                          a.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                          a.metalnessMap ? '#define USE_METALNESSMAP' : '',
                          a.alphaMap ? '#define USE_ALPHAMAP' : '',
                          a.vertexColors ? '#define USE_COLOR' : '',
                          a.flatShading ? '#define FLAT_SHADED' : '',
                          a.skinning ? '#define USE_SKINNING' : '',
                          a.useVertexTexture ? '#define BONE_TEXTURE' : '',
                          a.morphTargets ? '#define USE_MORPHTARGETS' : '',
                          a.morphNormals && !1 === a.flatShading ? '#define USE_MORPHNORMALS' : '',
                          a.doubleSided ? '#define DOUBLE_SIDED' : '',
                          a.flipSided ? '#define FLIP_SIDED' : '',
                          '#define NUM_CLIPPING_PLANES ' + a.numClippingPlanes,
                          a.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                          a.shadowMapEnabled ? '#define ' + l : '',
                          a.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
                          a.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                          a.logarithmicDepthBuffer && e.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',
                          'uniform mat4 modelMatrix;',
                          'uniform mat4 modelViewMatrix;',
                          'uniform mat4 projectionMatrix;',
                          'uniform mat4 viewMatrix;',
                          'uniform mat3 normalMatrix;',
                          'uniform vec3 cameraPosition;',
                          'attribute vec3 position;',
                          'attribute vec3 normal;',
                          'attribute vec2 uv;',
                          '#ifdef USE_COLOR',
                          '\tattribute vec3 color;',
                          '#endif',
                          '#ifdef USE_MORPHTARGETS',
                          '\tattribute vec3 morphTarget0;',
                          '\tattribute vec3 morphTarget1;',
                          '\tattribute vec3 morphTarget2;',
                          '\tattribute vec3 morphTarget3;',
                          '\t#ifdef USE_MORPHNORMALS',
                          '\t\tattribute vec3 morphNormal0;',
                          '\t\tattribute vec3 morphNormal1;',
                          '\t\tattribute vec3 morphNormal2;',
                          '\t\tattribute vec3 morphNormal3;',
                          '\t#else',
                          '\t\tattribute vec3 morphTarget4;',
                          '\t\tattribute vec3 morphTarget5;',
                          '\t\tattribute vec3 morphTarget6;',
                          '\t\tattribute vec3 morphTarget7;',
                          '\t#endif',
                          '#endif',
                          '#ifdef USE_SKINNING',
                          '\tattribute vec4 skinIndex;',
                          '\tattribute vec4 skinWeight;',
                          '#endif',
                          '\n',
                        ]
                          .filter(pt)
                          .join('\n')),
                        (m = [
                          g,
                          'precision ' + a.precision + ' float;',
                          'precision ' + a.precision + ' int;',
                          '#define SHADER_NAME ' + r.name,
                          y,
                          a.alphaTest ? '#define ALPHATEST ' + a.alphaTest : '',
                          '#define GAMMA_FACTOR ' + v,
                          a.useFog && a.fog ? '#define USE_FOG' : '',
                          a.useFog && a.fogExp ? '#define FOG_EXP2' : '',
                          a.map ? '#define USE_MAP' : '',
                          a.envMap ? '#define USE_ENVMAP' : '',
                          a.envMap ? '#define ' + u : '',
                          a.envMap ? '#define ' + p : '',
                          a.envMap ? '#define ' + d : '',
                          a.lightMap ? '#define USE_LIGHTMAP' : '',
                          a.aoMap ? '#define USE_AOMAP' : '',
                          a.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                          a.bumpMap ? '#define USE_BUMPMAP' : '',
                          a.normalMap ? '#define USE_NORMALMAP' : '',
                          a.specularMap ? '#define USE_SPECULARMAP' : '',
                          a.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                          a.metalnessMap ? '#define USE_METALNESSMAP' : '',
                          a.alphaMap ? '#define USE_ALPHAMAP' : '',
                          a.vertexColors ? '#define USE_COLOR' : '',
                          a.gradientMap ? '#define USE_GRADIENTMAP' : '',
                          a.flatShading ? '#define FLAT_SHADED' : '',
                          a.doubleSided ? '#define DOUBLE_SIDED' : '',
                          a.flipSided ? '#define FLIP_SIDED' : '',
                          '#define NUM_CLIPPING_PLANES ' + a.numClippingPlanes,
                          '#define UNION_CLIPPING_PLANES ' + (a.numClippingPlanes - a.numClipIntersection),
                          a.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                          a.shadowMapEnabled ? '#define ' + l : '',
                          a.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
                          a.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
                          a.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                          a.logarithmicDepthBuffer && e.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',
                          a.envMap && e.get('EXT_shader_texture_lod') ? '#define TEXTURE_LOD_EXT' : '',
                          'uniform mat4 viewMatrix;',
                          'uniform vec3 cameraPosition;',
                          a.toneMapping !== Ur ? '#define TONE_MAPPING' : '',
                          a.toneMapping !== Ur ? no.tonemapping_pars_fragment : '',
                          a.toneMapping !== Ur
                            ? (function (t, e) {
                                let i;
                                switch (e) {
                                  case Nr:
                                    i = 'Linear';
                                    break;
                                  case Br:
                                    i = 'Reinhard';
                                    break;
                                  case Fr:
                                    i = 'Uncharted2';
                                    break;
                                  case zr:
                                    i = 'OptimizedCineon';
                                    break;
                                  default:
                                    throw new Error('unsupported toneMapping: ' + e);
                                }
                                return 'vec3 ' + t + '( vec3 color ) { return ' + i + 'ToneMapping( color ); }';
                              })('toneMapping', a.toneMapping)
                            : '',
                          a.dithering ? '#define DITHERING' : '',
                          a.outputEncoding || a.mapEncoding || a.envMapEncoding || a.emissiveMapEncoding
                            ? no.encodings_pars_fragment
                            : '',
                          a.mapEncoding ? ut('mapTexelToLinear', a.mapEncoding) : '',
                          a.envMapEncoding ? ut('envMapTexelToLinear', a.envMapEncoding) : '',
                          a.emissiveMapEncoding ? ut('emissiveMapTexelToLinear', a.emissiveMapEncoding) : '',
                          a.outputEncoding
                            ? (function (t, e) {
                                const i = lt(a.outputEncoding);
                                return 'vec4 ' + t + '( vec4 value ) { return LinearTo' + i[0] + i[1] + '; }';
                              })('linearToOutputTexel')
                            : '',
                          a.depthPacking ? '#define DEPTH_PACKING ' + n.depthPacking : '',
                          '\n',
                        ]
                          .filter(pt)
                          .join('\n'))),
                      (c = dt((c = ft(c)), a)),
                      (h = dt((h = ft(h)), a)),
                      n.isShaderMaterial || ((c = mt(c)), (h = mt(h))));
                    const b = f + c,
                      w = m + h,
                      E = ht(o, o.VERTEX_SHADER, b),
                      M = ht(o, o.FRAGMENT_SHADER, w);
                    (o.attachShader(x, E),
                      o.attachShader(x, M),
                      void 0 !== n.index0AttributeName
                        ? o.bindAttribLocation(x, 0, n.index0AttributeName)
                        : !0 === a.morphTargets && o.bindAttribLocation(x, 0, 'position'),
                      o.linkProgram(x));
                    let T = o.getProgramInfoLog(x),
                      S = o.getShaderInfoLog(E),
                      A = o.getShaderInfoLog(M),
                      R = !0,
                      L = !0;
                    (!1 === o.getProgramParameter(x, o.LINK_STATUS)
                      ? ((R = !1),
                        console.error(
                          'THREE.WebGLProgram: shader error: ',
                          o.getError(),
                          'gl.VALIDATE_STATUS',
                          o.getProgramParameter(x, o.VALIDATE_STATUS),
                          'gl.getProgramInfoLog',
                          T,
                          S,
                          A
                        ))
                      : '' !== T
                        ? console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', T)
                        : ('' !== S && '' !== A) || (L = !1),
                      L &&
                        (this.diagnostics = {
                          runnable: R,
                          material: n,
                          programLog: T,
                          vertexShader: { log: S, prefix: f },
                          fragmentShader: { log: A, prefix: m },
                        }),
                      o.deleteShader(E),
                      o.deleteShader(M));
                    let P;
                    this.getUniforms = function () {
                      return (void 0 === P && (P = new _(o, x, t)), P);
                    };
                    let C;
                    return (
                      (this.getAttributes = function () {
                        return (
                          void 0 === C &&
                            (C = (function (t, e) {
                              for (var i = {}, n = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), r = 0; r < n; r++) {
                                const a = t.getActiveAttrib(e, r).name;
                                i[a] = t.getAttribLocation(e, a);
                              }
                              return i;
                            })(o, x)),
                          C
                        );
                      }),
                      (this.destroy = function () {
                        (o.deleteProgram(x), (this.program = void 0));
                      }),
                      Object.defineProperties(this, {
                        uniforms: {
                          get: function () {
                            return (
                              console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().'),
                              this.getUniforms()
                            );
                          },
                        },
                        attributes: {
                          get: function () {
                            return (
                              console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().'),
                              this.getAttributes()
                            );
                          },
                        },
                      }),
                      (this.id = ho++),
                      (this.code = i),
                      (this.usedTimes = 1),
                      (this.program = x),
                      (this.vertexShader = E),
                      (this.fragmentShader = M),
                      this
                    );
                  })(t, e, o, i, n, a)),
                  r.push(s)),
                s
              );
            }),
            (this.releaseProgram = function (t) {
              if (0 == --t.usedTimes) {
                const e = r.indexOf(t);
                ((r[e] = r[r.length - 1]), r.pop(), t.destroy());
              }
            }),
            (this.programs = r));
        })(j, Nt, Bt)),
        (jt = new (function () {
          const t = new (function () {
              const t = {};
              return {
                get: function (e) {
                  if (void 0 !== t[e.id]) return t[e.id];
                  let n;
                  switch (e.type) {
                    case 'DirectionalLight':
                      n = {
                        direction: new a(),
                        color: new w(),
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new i(),
                      };
                      break;
                    case 'SpotLight':
                      n = {
                        position: new a(),
                        direction: new a(),
                        color: new w(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new i(),
                      };
                      break;
                    case 'PointLight':
                      n = {
                        position: new a(),
                        color: new w(),
                        distance: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new i(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3,
                      };
                      break;
                    case 'HemisphereLight':
                      n = { direction: new a(), skyColor: new w(), groundColor: new w() };
                      break;
                    case 'RectAreaLight':
                      n = { color: new w(), position: new a(), halfWidth: new a(), halfHeight: new a() };
                  }
                  return ((t[e.id] = n), n);
                },
              };
            })(),
            e = {
              hash: '',
              ambient: [0, 0, 0],
              directional: [],
              directionalShadowMap: [],
              directionalShadowMatrix: [],
              spot: [],
              spotShadowMap: [],
              spotShadowMatrix: [],
              rectArea: [],
              point: [],
              pointShadowMap: [],
              pointShadowMatrix: [],
              hemi: [],
            },
            r = new a(),
            o = new n(),
            s = new n();
          return {
            setup: function (i, n, a) {
              for (
                var c = 0,
                  h = 0,
                  l = 0,
                  u = 0,
                  p = 0,
                  d = 0,
                  f = 0,
                  m = 0,
                  v = a.matrixWorldInverse,
                  g = 0,
                  y = i.length;
                g < y;
                g++
              ) {
                const x = i[g],
                  b = x.color,
                  _ = x.intensity,
                  w = x.distance,
                  E = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
                if (x.isAmbientLight) ((c += b.r * _), (h += b.g * _), (l += b.b * _));
                else if (x.isDirectionalLight)
                  ((T = t.get(x)).color.copy(x.color).multiplyScalar(x.intensity),
                    T.direction.setFromMatrixPosition(x.matrixWorld),
                    r.setFromMatrixPosition(x.target.matrixWorld),
                    T.direction.sub(r),
                    T.direction.transformDirection(v),
                    (T.shadow = x.castShadow),
                    x.castShadow &&
                      ((M = x.shadow),
                      (T.shadowBias = M.bias),
                      (T.shadowRadius = M.radius),
                      (T.shadowMapSize = M.mapSize)),
                    (e.directionalShadowMap[u] = E),
                    (e.directionalShadowMatrix[u] = x.shadow.matrix),
                    (e.directional[u] = T),
                    u++);
                else if (x.isSpotLight)
                  ((T = t.get(x)).position.setFromMatrixPosition(x.matrixWorld),
                    T.position.applyMatrix4(v),
                    T.color.copy(b).multiplyScalar(_),
                    (T.distance = w),
                    T.direction.setFromMatrixPosition(x.matrixWorld),
                    r.setFromMatrixPosition(x.target.matrixWorld),
                    T.direction.sub(r),
                    T.direction.transformDirection(v),
                    (T.coneCos = Math.cos(x.angle)),
                    (T.penumbraCos = Math.cos(x.angle * (1 - x.penumbra))),
                    (T.decay = 0 === x.distance ? 0 : x.decay),
                    (T.shadow = x.castShadow),
                    x.castShadow &&
                      ((M = x.shadow),
                      (T.shadowBias = M.bias),
                      (T.shadowRadius = M.radius),
                      (T.shadowMapSize = M.mapSize)),
                    (e.spotShadowMap[d] = E),
                    (e.spotShadowMatrix[d] = x.shadow.matrix),
                    (e.spot[d] = T),
                    d++);
                else if (x.isRectAreaLight)
                  ((T = t.get(x)).color.copy(b).multiplyScalar(_ / (x.width * x.height)),
                    T.position.setFromMatrixPosition(x.matrixWorld),
                    T.position.applyMatrix4(v),
                    s.identity(),
                    o.copy(x.matrixWorld),
                    o.premultiply(v),
                    s.extractRotation(o),
                    T.halfWidth.set(0.5 * x.width, 0, 0),
                    T.halfHeight.set(0, 0.5 * x.height, 0),
                    T.halfWidth.applyMatrix4(s),
                    T.halfHeight.applyMatrix4(s),
                    (e.rectArea[f] = T),
                    f++);
                else if (x.isPointLight) {
                  if (
                    ((T = t.get(x)).position.setFromMatrixPosition(x.matrixWorld),
                    T.position.applyMatrix4(v),
                    T.color.copy(x.color).multiplyScalar(x.intensity),
                    (T.distance = x.distance),
                    (T.decay = 0 === x.distance ? 0 : x.decay),
                    (T.shadow = x.castShadow),
                    x.castShadow)
                  ) {
                    var M = x.shadow;
                    ((T.shadowBias = M.bias),
                      (T.shadowRadius = M.radius),
                      (T.shadowMapSize = M.mapSize),
                      (T.shadowCameraNear = M.camera.near),
                      (T.shadowCameraFar = M.camera.far));
                  }
                  ((e.pointShadowMap[p] = E), (e.pointShadowMatrix[p] = x.shadow.matrix), (e.point[p] = T), p++);
                } else if (x.isHemisphereLight) {
                  var T = t.get(x);
                  (T.direction.setFromMatrixPosition(x.matrixWorld),
                    T.direction.transformDirection(v),
                    T.direction.normalize(),
                    T.skyColor.copy(x.color).multiplyScalar(_),
                    T.groundColor.copy(x.groundColor).multiplyScalar(_),
                    (e.hemi[m] = T),
                    m++);
                }
              }
              ((e.ambient[0] = c),
                (e.ambient[1] = h),
                (e.ambient[2] = l),
                (e.directional.length = u),
                (e.spot.length = d),
                (e.rectArea.length = f),
                (e.point.length = p),
                (e.hemi.length = m),
                (e.hash = u + ',' + p + ',' + d + ',' + f + ',' + m + ',' + n.length));
            },
            state: e,
          };
        })()),
        (Xt = new (function () {
          let t = {};
          return {
            get: function (e, i) {
              let n = e.id + ',' + i.id,
                r = t[n];
              return (
                void 0 === r &&
                  ((r = new (function () {
                    let t = [],
                      e = 0,
                      i = [],
                      n = [];
                    return {
                      opaque: i,
                      transparent: n,
                      init: function () {
                        ((e = 0), (i.length = 0), (n.length = 0));
                      },
                      push: function (r, a, o, s, c) {
                        let h = t[e];
                        (void 0 === h
                          ? ((h = {
                              id: r.id,
                              object: r,
                              geometry: a,
                              material: o,
                              program: o.program,
                              renderOrder: r.renderOrder,
                              z: s,
                              group: c,
                            }),
                            (t[e] = h))
                          : ((h.id = r.id),
                            (h.object = r),
                            (h.geometry = a),
                            (h.material = o),
                            (h.program = o.program),
                            (h.renderOrder = r.renderOrder),
                            (h.z = s),
                            (h.group = c)),
                          (!0 === o.transparent ? n : i).push(h),
                          e++);
                      },
                      sort: function () {
                        (i.length > 1 &&
                          i.sort(function (t, e) {
                            return t.renderOrder !== e.renderOrder
                              ? t.renderOrder - e.renderOrder
                              : t.program && e.program && t.program !== e.program
                                ? t.program.id - e.program.id
                                : t.material.id !== e.material.id
                                  ? t.material.id - e.material.id
                                  : t.z !== e.z
                                    ? t.z - e.z
                                    : t.id - e.id;
                          }),
                          n.length > 1 &&
                            n.sort(function (t, e) {
                              return t.renderOrder !== e.renderOrder
                                ? t.renderOrder - e.renderOrder
                                : t.z !== e.z
                                  ? e.z - t.z
                                  : t.id - e.id;
                            }));
                      },
                    };
                  })()),
                  (t[n] = r)),
                r
              );
            },
            dispose: function () {
              t = {};
            },
          };
        })()),
        (qt = new (function (t, e, i, n) {
          function r(t, i) {
            e.buffers.color.setClear(t.r, t.g, t.b, i, n);
          }
          let a,
            o,
            s,
            c = new w(0),
            h = 0;
          return {
            getClearColor: function () {
              return c;
            },
            setClearColor: function (t, e) {
              (c.set(t), r(c, (h = void 0 !== e ? e : 1)));
            },
            getClearAlpha: function () {
              return h;
            },
            setClearAlpha: function (t) {
              r(c, (h = t));
            },
            render: function (e, n, l, u) {
              const p = n.background;
              (null === p ? r(c, h) : p && p.isColor && (r(p, 1), (u = !0)),
                (t.autoClear || u) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                p && p.isCubeTexture
                  ? (void 0 === s &&
                      ((s = new ct(
                        new tt(1, 1, 1),
                        new rt({
                          uniforms: ro.cube.uniforms,
                          vertexShader: ro.cube.vertexShader,
                          fragmentShader: ro.cube.fragmentShader,
                          side: Jn,
                          depthTest: !0,
                          depthWrite: !1,
                          fog: !1,
                        })
                      )).geometry.removeAttribute('normal'),
                      s.geometry.removeAttribute('uv'),
                      (s.onBeforeRender = function (t, e, i) {
                        this.matrixWorld.copyPosition(i.matrixWorld);
                      }),
                      i.update(s.geometry)),
                    (s.material.uniforms.tCube.value = p),
                    e.push(s, s.geometry, s.material, 0, null))
                  : p &&
                    p.isTexture &&
                    (void 0 === a &&
                      ((a = new B(-1, 1, 1, -1, 0, 1)),
                      (o = new ct(new it(2, 2), new nt({ depthTest: !1, depthWrite: !1, fog: !1 }))),
                      i.update(o.geometry)),
                    (o.material.map = p),
                    t.renderBufferDirect(a, null, o.geometry, o.material, o, null)));
            },
          };
        })(j, Ft, Vt, N)),
        (Zt = new (function (t, e, i) {
          let n;
          ((this.setMode = function (t) {
            n = t;
          }),
            (this.render = function (e, r) {
              (t.drawArrays(n, e, r),
                i.calls++,
                (i.vertices += r),
                n === t.TRIANGLES ? (i.faces += r / 3) : n === t.POINTS && (i.points += r));
            }),
            (this.renderInstances = function (r, a, o) {
              const s = e.get('ANGLE_instanced_arrays');
              if (null !== s) {
                const c = r.attributes.position;
                (c.isInterleavedBufferAttribute
                  ? ((o = c.data.count), s.drawArraysInstancedANGLE(n, 0, o, r.maxInstancedCount))
                  : s.drawArraysInstancedANGLE(n, a, o, r.maxInstancedCount),
                  i.calls++,
                  (i.vertices += o * r.maxInstancedCount),
                  n === t.TRIANGLES
                    ? (i.faces += (r.maxInstancedCount * o) / 3)
                    : n === t.POINTS && (i.points += r.maxInstancedCount * o));
              } else
                console.error(
                  'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
                );
            }));
        })(Ot, Nt, Dt)),
        (Qt = new (function (t, e, i) {
          let n, r, a;
          ((this.setMode = function (t) {
            n = t;
          }),
            (this.setIndex = function (t) {
              ((r = t.type), (a = t.bytesPerElement));
            }),
            (this.render = function (e, o) {
              (t.drawElements(n, o, r, e * a),
                i.calls++,
                (i.vertices += o),
                n === t.TRIANGLES ? (i.faces += o / 3) : n === t.POINTS && (i.points += o));
            }),
            (this.renderInstances = function (o, s, c) {
              const h = e.get('ANGLE_instanced_arrays');
              null !== h
                ? (h.drawElementsInstancedANGLE(n, c, r, s * a, o.maxInstancedCount),
                  i.calls++,
                  (i.vertices += c * o.maxInstancedCount),
                  n === t.TRIANGLES
                    ? (i.faces += (o.maxInstancedCount * c) / 3)
                    : n === t.POINTS && (i.points += o.maxInstancedCount * c))
                : console.error(
                    'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
                  );
            }));
        })(Ot, Nt, Dt)),
        (Jt = new (function (t, e, n, r, o) {
          let s, c, h, l, u, p, d, f;
          this.render = function (t, m, v, g) {
            if (0 !== t.length) {
              let y = new a(),
                x = g.w / g.z,
                b = 0.5 * g.z,
                _ = 0.5 * g.w,
                w = 16 / g.w,
                M = new i(w * x, w),
                T = new a(1, 1, 0),
                S = new i(1, 1),
                A = new E();
              (A.min.set(g.x, g.y),
                A.max.set(g.x + (g.z - 16), g.y + (g.w - 16)),
                void 0 === l &&
                  (function () {
                    const t = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
                      i = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    ((s = e.createBuffer()),
                      (c = e.createBuffer()),
                      e.bindBuffer(e.ARRAY_BUFFER, s),
                      e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW),
                      e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, c),
                      e.bufferData(e.ELEMENT_ARRAY_BUFFER, i, e.STATIC_DRAW),
                      (d = e.createTexture()),
                      (f = e.createTexture()),
                      n.bindTexture(e.TEXTURE_2D, d),
                      e.texImage2D(e.TEXTURE_2D, 0, e.RGB, 16, 16, 0, e.RGB, e.UNSIGNED_BYTE, null),
                      e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                      e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
                      e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
                      e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
                      n.bindTexture(e.TEXTURE_2D, f),
                      e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 16, 16, 0, e.RGBA, e.UNSIGNED_BYTE, null),
                      e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                      e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
                      e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
                      e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
                      (h = {
                        vertexShader: [
                          'uniform lowp int renderType;',
                          'uniform vec3 screenPosition;',
                          'uniform vec2 scale;',
                          'uniform float rotation;',
                          'uniform sampler2D occlusionMap;',
                          'attribute vec2 position;',
                          'attribute vec2 uv;',
                          'varying vec2 vUV;',
                          'varying float vVisibility;',
                          'void main() {',
                          '\tvUV = uv;',
                          '\tvec2 pos = position;',
                          '\tif ( renderType == 2 ) {',
                          '\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',
                          '\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',
                          '\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',
                          '\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',
                          '\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',
                          '\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',
                          '\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',
                          '\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',
                          '\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',
                          '\t\tvVisibility =        visibility.r / 9.0;',
                          '\t\tvVisibility *= 1.0 - visibility.g / 9.0;',
                          '\t\tvVisibility *=       visibility.b / 9.0;',
                          '\t\tvVisibility *= 1.0 - visibility.a / 9.0;',
                          '\t\tpos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',
                          '\t\tpos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',
                          '\t}',
                          '\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',
                          '}',
                        ].join('\n'),
                        fragmentShader: [
                          'uniform lowp int renderType;',
                          'uniform sampler2D map;',
                          'uniform float opacity;',
                          'uniform vec3 color;',
                          'varying vec2 vUV;',
                          'varying float vVisibility;',
                          'void main() {',
                          '\tif ( renderType == 0 ) {',
                          '\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );',
                          '\t} else if ( renderType == 1 ) {',
                          '\t\tgl_FragColor = texture2D( map, vUV );',
                          '\t} else {',
                          '\t\tvec4 texture = texture2D( map, vUV );',
                          '\t\ttexture.a *= opacity * vVisibility;',
                          '\t\tgl_FragColor = texture;',
                          '\t\tgl_FragColor.rgb *= color;',
                          '\t}',
                          '}',
                        ].join('\n'),
                      }),
                      (l = (function (t) {
                        const i = e.createProgram(),
                          n = e.createShader(e.FRAGMENT_SHADER),
                          r = e.createShader(e.VERTEX_SHADER),
                          a = 'precision ' + o.precision + ' float;\n';
                        return (
                          e.shaderSource(n, a + t.fragmentShader),
                          e.shaderSource(r, a + t.vertexShader),
                          e.compileShader(n),
                          e.compileShader(r),
                          e.attachShader(i, n),
                          e.attachShader(i, r),
                          e.linkProgram(i),
                          i
                        );
                      })(h)),
                      (u = { vertex: e.getAttribLocation(l, 'position'), uv: e.getAttribLocation(l, 'uv') }),
                      (p = {
                        renderType: e.getUniformLocation(l, 'renderType'),
                        map: e.getUniformLocation(l, 'map'),
                        occlusionMap: e.getUniformLocation(l, 'occlusionMap'),
                        opacity: e.getUniformLocation(l, 'opacity'),
                        color: e.getUniformLocation(l, 'color'),
                        scale: e.getUniformLocation(l, 'scale'),
                        rotation: e.getUniformLocation(l, 'rotation'),
                        screenPosition: e.getUniformLocation(l, 'screenPosition'),
                      }));
                  })(),
                n.useProgram(l),
                n.initAttributes(),
                n.enableAttribute(u.vertex),
                n.enableAttribute(u.uv),
                n.disableUnusedAttributes(),
                e.uniform1i(p.occlusionMap, 0),
                e.uniform1i(p.map, 1),
                e.bindBuffer(e.ARRAY_BUFFER, s),
                e.vertexAttribPointer(u.vertex, 2, e.FLOAT, !1, 16, 0),
                e.vertexAttribPointer(u.uv, 2, e.FLOAT, !1, 16, 8),
                e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, c),
                n.disable(e.CULL_FACE),
                n.buffers.depth.setMask(!1));
              for (let R = 0, L = t.length; R < L; R++) {
                ((w = 16 / g.w), M.set(w * x, w));
                const P = t[R];
                if (
                  (y.set(P.matrixWorld.elements[12], P.matrixWorld.elements[13], P.matrixWorld.elements[14]),
                  y.applyMatrix4(v.matrixWorldInverse),
                  y.applyMatrix4(v.projectionMatrix),
                  T.copy(y),
                  (S.x = g.x + T.x * b + b - 8),
                  (S.y = g.y + T.y * _ + _ - 8),
                  !0 === A.containsPoint(S))
                ) {
                  (n.activeTexture(e.TEXTURE0),
                    n.bindTexture(e.TEXTURE_2D, null),
                    n.activeTexture(e.TEXTURE1),
                    n.bindTexture(e.TEXTURE_2D, d),
                    e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGB, S.x, S.y, 16, 16, 0),
                    e.uniform1i(p.renderType, 0),
                    e.uniform2f(p.scale, M.x, M.y),
                    e.uniform3f(p.screenPosition, T.x, T.y, T.z),
                    n.disable(e.BLEND),
                    n.enable(e.DEPTH_TEST),
                    e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0),
                    n.activeTexture(e.TEXTURE0),
                    n.bindTexture(e.TEXTURE_2D, f),
                    e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, S.x, S.y, 16, 16, 0),
                    e.uniform1i(p.renderType, 1),
                    n.disable(e.DEPTH_TEST),
                    n.activeTexture(e.TEXTURE1),
                    n.bindTexture(e.TEXTURE_2D, d),
                    e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0),
                    P.positionScreen.copy(T),
                    P.customUpdateCallback ? P.customUpdateCallback(P) : P.updateLensFlares(),
                    e.uniform1i(p.renderType, 2),
                    n.enable(e.BLEND));
                  for (let C = 0, I = P.lensFlares.length; C < I; C++) {
                    const D = P.lensFlares[C];
                    D.opacity > 0.001 &&
                      D.scale > 0.001 &&
                      ((T.x = D.x),
                      (T.y = D.y),
                      (T.z = D.z),
                      (w = (D.size * D.scale) / g.w),
                      (M.x = w * x),
                      (M.y = w),
                      e.uniform3f(p.screenPosition, T.x, T.y, T.z),
                      e.uniform2f(p.scale, M.x, M.y),
                      e.uniform1f(p.rotation, D.rotation),
                      e.uniform1f(p.opacity, D.opacity),
                      e.uniform3f(p.color, D.color.r, D.color.g, D.color.b),
                      n.setBlending(D.blending, D.blendEquation, D.blendSrc, D.blendDst),
                      r.setTexture2D(D.texture, 1),
                      e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0));
                  }
                }
              }
              (n.enable(e.CULL_FACE), n.enable(e.DEPTH_TEST), n.buffers.depth.setMask(!0), n.reset());
            }
          };
        })(j, Ot, Ft, Gt, Bt)),
        (Kt = new (function (t, e, i, n, o) {
          let s,
            c,
            h,
            l,
            u,
            p,
            d = new a(),
            f = new r(),
            m = new a();
          this.render = function (r, a, v) {
            if (0 !== r.length) {
              (void 0 === h &&
                (function () {
                  const t = new Float32Array([-0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0, 0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1]),
                    i = new Uint16Array([0, 1, 2, 0, 2, 3]);
                  ((s = e.createBuffer()),
                    (c = e.createBuffer()),
                    e.bindBuffer(e.ARRAY_BUFFER, s),
                    e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW),
                    e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, c),
                    e.bufferData(e.ELEMENT_ARRAY_BUFFER, i, e.STATIC_DRAW),
                    (h = (function () {
                      const t = e.createProgram(),
                        i = e.createShader(e.VERTEX_SHADER),
                        n = e.createShader(e.FRAGMENT_SHADER);
                      return (
                        e.shaderSource(
                          i,
                          [
                            'precision ' + o.precision + ' float;',
                            '#define SHADER_NAME SpriteMaterial',
                            'uniform mat4 modelViewMatrix;',
                            'uniform mat4 projectionMatrix;',
                            'uniform float rotation;',
                            'uniform vec2 scale;',
                            'uniform vec2 uvOffset;',
                            'uniform vec2 uvScale;',
                            'attribute vec2 position;',
                            'attribute vec2 uv;',
                            'varying vec2 vUV;',
                            'varying float fogDepth;',
                            'void main() {',
                            '\tvUV = uvOffset + uv * uvScale;',
                            '\tvec2 alignedPosition = position * scale;',
                            '\tvec2 rotatedPosition;',
                            '\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
                            '\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
                            '\tvec4 mvPosition;',
                            '\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
                            '\tmvPosition.xy += rotatedPosition;',
                            '\tgl_Position = projectionMatrix * mvPosition;',
                            '\tfogDepth = - mvPosition.z;',
                            '}',
                          ].join('\n')
                        ),
                        e.shaderSource(
                          n,
                          [
                            'precision ' + o.precision + ' float;',
                            '#define SHADER_NAME SpriteMaterial',
                            'uniform vec3 color;',
                            'uniform sampler2D map;',
                            'uniform float opacity;',
                            'uniform int fogType;',
                            'uniform vec3 fogColor;',
                            'uniform float fogDensity;',
                            'uniform float fogNear;',
                            'uniform float fogFar;',
                            'uniform float alphaTest;',
                            'varying vec2 vUV;',
                            'varying float fogDepth;',
                            'void main() {',
                            '\tvec4 texture = texture2D( map, vUV );',
                            '\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
                            '\tif ( gl_FragColor.a < alphaTest ) discard;',
                            '\tif ( fogType > 0 ) {',
                            '\t\tfloat fogFactor = 0.0;',
                            '\t\tif ( fogType == 1 ) {',
                            '\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );',
                            '\t\t} else {',
                            '\t\t\tconst float LOG2 = 1.442695;',
                            '\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );',
                            '\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
                            '\t\t}',
                            '\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );',
                            '\t}',
                            '}',
                          ].join('\n')
                        ),
                        e.compileShader(i),
                        e.compileShader(n),
                        e.attachShader(t, i),
                        e.attachShader(t, n),
                        e.linkProgram(t),
                        t
                      );
                    })()),
                    (l = { position: e.getAttribLocation(h, 'position'), uv: e.getAttribLocation(h, 'uv') }),
                    (u = {
                      uvOffset: e.getUniformLocation(h, 'uvOffset'),
                      uvScale: e.getUniformLocation(h, 'uvScale'),
                      rotation: e.getUniformLocation(h, 'rotation'),
                      scale: e.getUniformLocation(h, 'scale'),
                      color: e.getUniformLocation(h, 'color'),
                      map: e.getUniformLocation(h, 'map'),
                      opacity: e.getUniformLocation(h, 'opacity'),
                      modelViewMatrix: e.getUniformLocation(h, 'modelViewMatrix'),
                      projectionMatrix: e.getUniformLocation(h, 'projectionMatrix'),
                      fogType: e.getUniformLocation(h, 'fogType'),
                      fogDensity: e.getUniformLocation(h, 'fogDensity'),
                      fogNear: e.getUniformLocation(h, 'fogNear'),
                      fogFar: e.getUniformLocation(h, 'fogFar'),
                      fogColor: e.getUniformLocation(h, 'fogColor'),
                      fogDepth: e.getUniformLocation(h, 'fogDepth'),
                      alphaTest: e.getUniformLocation(h, 'alphaTest'),
                    }));
                  const n = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                  ((n.width = 8), (n.height = 8));
                  const r = n.getContext('2d');
                  ((r.fillStyle = 'white'), r.fillRect(0, 0, 8, 8), (p = new M(n)));
                })(),
                i.useProgram(h),
                i.initAttributes(),
                i.enableAttribute(l.position),
                i.enableAttribute(l.uv),
                i.disableUnusedAttributes(),
                i.disable(e.CULL_FACE),
                i.enable(e.BLEND),
                e.bindBuffer(e.ARRAY_BUFFER, s),
                e.vertexAttribPointer(l.position, 2, e.FLOAT, !1, 16, 0),
                e.vertexAttribPointer(l.uv, 2, e.FLOAT, !1, 16, 8),
                e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, c),
                e.uniformMatrix4fv(u.projectionMatrix, !1, v.projectionMatrix.elements),
                i.activeTexture(e.TEXTURE0),
                e.uniform1i(u.map, 0));
              let g = 0,
                y = 0,
                x = a.fog;
              x
                ? (e.uniform3f(u.fogColor, x.color.r, x.color.g, x.color.b),
                  x.isFog
                    ? (e.uniform1f(u.fogNear, x.near),
                      e.uniform1f(u.fogFar, x.far),
                      e.uniform1i(u.fogType, 1),
                      (g = 1),
                      (y = 1))
                    : x.isFogExp2 &&
                      (e.uniform1f(u.fogDensity, x.density), e.uniform1i(u.fogType, 2), (g = 2), (y = 2)))
                : (e.uniform1i(u.fogType, 0), (g = 0), (y = 0));
              for (var b = 0, _ = r.length; b < _; b++)
                ((E = r[b]).modelViewMatrix.multiplyMatrices(v.matrixWorldInverse, E.matrixWorld),
                  (E.z = -E.modelViewMatrix.elements[14]));
              r.sort(function (t, e) {
                return t.renderOrder !== e.renderOrder
                  ? t.renderOrder - e.renderOrder
                  : t.z !== e.z
                    ? e.z - t.z
                    : e.id - t.id;
              });
              for (var w = [], b = 0, _ = r.length; b < _; b++) {
                var E = r[b],
                  T = E.material;
                if (!1 !== T.visible) {
                  (E.onBeforeRender(t, a, v, void 0, T, void 0),
                    e.uniform1f(u.alphaTest, T.alphaTest),
                    e.uniformMatrix4fv(u.modelViewMatrix, !1, E.modelViewMatrix.elements),
                    E.matrixWorld.decompose(d, f, m),
                    (w[0] = m.x),
                    (w[1] = m.y));
                  let S = 0;
                  (a.fog && T.fog && (S = y),
                    g !== S && (e.uniform1i(u.fogType, S), (g = S)),
                    null !== T.map
                      ? (e.uniform2f(u.uvOffset, T.map.offset.x, T.map.offset.y),
                        e.uniform2f(u.uvScale, T.map.repeat.x, T.map.repeat.y))
                      : (e.uniform2f(u.uvOffset, 0, 0), e.uniform2f(u.uvScale, 1, 1)),
                    e.uniform1f(u.opacity, T.opacity),
                    e.uniform3f(u.color, T.color.r, T.color.g, T.color.b),
                    e.uniform1f(u.rotation, T.rotation),
                    e.uniform2fv(u.scale, w),
                    i.setBlending(
                      T.blending,
                      T.blendEquation,
                      T.blendSrc,
                      T.blendDst,
                      T.blendEquationAlpha,
                      T.blendSrcAlpha,
                      T.blendDstAlpha,
                      T.premultipliedAlpha
                    ),
                    i.buffers.depth.setTest(T.depthTest),
                    i.buffers.depth.setMask(T.depthWrite),
                    i.buffers.color.setMask(T.colorWrite),
                    n.setTexture2D(T.map || p, 0),
                    e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0),
                    E.onAfterRender(t, a, v, void 0, T, void 0));
                }
              }
              (i.enable(e.CULL_FACE), i.reset());
            }
          };
        })(j, Ot, Ft, Gt, Bt)),
        (j.info.programs = Wt.programs),
        (j.context = Ot),
        (j.capabilities = Bt),
        (j.extensions = Nt),
        (j.properties = zt),
        (j.renderLists = Xt),
        (j.state = Ft));
    }
    function h(t) {
      (t.preventDefault(), console.log('THREE.WebGLRenderer: Context Lost.'), (X = !0));
    }
    function l() {
      (console.log('THREE.WebGLRenderer: Context Restored.'), (X = !1), s());
    }
    function p(t) {
      const e = t.target;
      (e.removeEventListener('dispose', p),
        (function (t) {
          (d(t), zt.remove(t));
        })(e));
    }
    function d(t) {
      const e = zt.get(t).program;
      ((t.program = void 0), void 0 !== e && Wt.releaseProgram(e));
    }
    function f(t) {
      null !== ne && ne(t);
      const e = te.getDevice();
      e && e.isPresenting ? e.requestAnimationFrame(f) : window.requestAnimationFrame(f);
    }
    function m(t, e, i) {
      if (!1 !== t.visible) {
        if (t.layers.test(e.layers))
          if (t.isLight) (z.push(t), t.castShadow && G.push(t));
          else if (t.isSprite) (t.frustumCulled && !St.intersectsSprite(t)) || V.push(t);
          else if (t.isLensFlare) k.push(t);
          else if (t.isImmediateRenderObject)
            (i && Ct.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Pt), H.push(t, null, t.material, Ct.z, null));
          else if (
            (t.isMesh || t.isLine || t.isPoints) &&
            (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || St.intersectsObject(t))
          ) {
            i && Ct.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Pt);
            const n = kt.update(t),
              r = t.material;
            if (Array.isArray(r))
              for (var a = n.groups, o = 0, s = a.length; o < s; o++) {
                const c = a[o],
                  h = r[c.materialIndex];
                h && h.visible && H.push(t, n, h, Ct.z, c);
              }
            else r.visible && H.push(t, n, r, Ct.z, null);
          }
        for (var l = t.children, o = 0, s = l.length; o < s; o++) m(l[o], e, i);
      }
    }
    function v(t, e, i, n) {
      for (let r = 0, a = t.length; r < a; r++) {
        const o = t[r],
          s = o.object,
          c = o.geometry,
          h = void 0 === n ? o.material : n,
          l = o.group;
        if (i.isArrayCamera) {
          at = i;
          for (let u = i.cameras, p = 0, d = u.length; p < d; p++) {
            const f = u[p];
            if (s.layers.test(f.layers)) {
              const m = f.bounds,
                v = m.x * bt,
                y = m.y * _t,
                x = m.z * bt,
                b = m.w * _t;
              (Ft.viewport(ot.set(v, y, x, b).multiplyScalar(wt)), g(s, e, f, c, h, l));
            }
          }
        } else ((at = null), g(s, e, i, c, h, l));
      }
    }
    function g(t, e, i, n, r, a) {
      if (
        (t.onBeforeRender(j, e, i, n, r, a),
        t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld),
        t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
        t.isImmediateRenderObject)
      ) {
        Ft.setMaterial(r);
        const o = x(i, e.fog, r, t);
        (($ = ''),
          (function (t, e, i) {
            t.render(function (t) {
              j.renderBufferImmediate(t, e, i);
            });
          })(t, o, r));
      } else j.renderBufferDirect(i, e.fog, n, r, t, a);
      t.onAfterRender(j, e, i, n, r, a);
    }
    function y(t, e, i) {
      let n = zt.get(t),
        r = Wt.getParameters(t, jt.state, G, e, At.numPlanes, At.numIntersection, i),
        a = Wt.getProgramCode(t, r),
        o = n.program,
        s = !0;
      if (void 0 === o) t.addEventListener('dispose', p);
      else if (o.code !== a) d(t);
      else {
        if (void 0 !== r.shaderID) return;
        s = !1;
      }
      if (s) {
        if (r.shaderID) {
          const c = ro[r.shaderID];
          n.shader = {
            name: t.type,
            uniforms: io.clone(c.uniforms),
            vertexShader: c.vertexShader,
            fragmentShader: c.fragmentShader,
          };
        } else
          n.shader = {
            name: t.type,
            uniforms: t.uniforms,
            vertexShader: t.vertexShader,
            fragmentShader: t.fragmentShader,
          };
        (t.onBeforeCompile(n.shader), (o = Wt.acquireProgram(t, n.shader, r, a)), (n.program = o), (t.program = o));
      }
      const h = o.getAttributes();
      if (t.morphTargets) {
        t.numSupportedMorphTargets = 0;
        for (l = 0; l < j.maxMorphTargets; l++) h['morphTarget' + l] >= 0 && t.numSupportedMorphTargets++;
      }
      if (t.morphNormals) {
        t.numSupportedMorphNormals = 0;
        for (var l = 0; l < j.maxMorphNormals; l++) h['morphNormal' + l] >= 0 && t.numSupportedMorphNormals++;
      }
      const u = n.shader.uniforms;
      (((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
        ((n.numClippingPlanes = At.numPlanes),
        (n.numIntersection = At.numIntersection),
        (u.clippingPlanes = At.uniform)),
        (n.fog = e),
        (n.lightsHash = jt.state.hash),
        t.lights &&
          ((u.ambientLightColor.value = jt.state.ambient),
          (u.directionalLights.value = jt.state.directional),
          (u.spotLights.value = jt.state.spot),
          (u.rectAreaLights.value = jt.state.rectArea),
          (u.pointLights.value = jt.state.point),
          (u.hemisphereLights.value = jt.state.hemi),
          (u.directionalShadowMap.value = jt.state.directionalShadowMap),
          (u.directionalShadowMatrix.value = jt.state.directionalShadowMatrix),
          (u.spotShadowMap.value = jt.state.spotShadowMap),
          (u.spotShadowMatrix.value = jt.state.spotShadowMatrix),
          (u.pointShadowMap.value = jt.state.pointShadowMap),
          (u.pointShadowMatrix.value = jt.state.pointShadowMatrix)));
      const f = n.program.getUniforms(),
        m = _.seqWithValue(f.seq, u);
      n.uniformsList = m;
    }
    function x(t, e, i, n) {
      gt = 0;
      const r = zt.get(i);
      if (Rt && (Lt || t !== et)) {
        const a = t === et && i.id === Q;
        At.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, r, a);
      }
      (!1 === i.needsUpdate &&
        (void 0 === r.program
          ? (i.needsUpdate = !0)
          : i.fog && r.fog !== e
            ? (i.needsUpdate = !0)
            : i.lights && r.lightsHash !== jt.state.hash
              ? (i.needsUpdate = !0)
              : void 0 === r.numClippingPlanes ||
                (r.numClippingPlanes === At.numPlanes && r.numIntersection === At.numIntersection) ||
                (i.needsUpdate = !0)),
        i.needsUpdate && (y(i, e, n), (i.needsUpdate = !1)));
      let o = !1,
        s = !1,
        c = !1,
        h = r.program,
        l = h.getUniforms(),
        p = r.shader.uniforms;
      if (
        (Ft.useProgram(h.program) && ((o = !0), (s = !0), (c = !0)),
        i.id !== Q && ((Q = i.id), (s = !0)),
        o || t !== et)
      ) {
        if (
          (l.setValue(Ot, 'projectionMatrix', t.projectionMatrix),
          Bt.logarithmicDepthBuffer && l.setValue(Ot, 'logDepthBufFC', 2 / (Math.log(t.far + 1) / Math.LN2)),
          et !== (at || t) && ((et = at || t), (s = !0), (c = !0)),
          i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap)
        ) {
          const d = l.map.cameraPosition;
          void 0 !== d && d.setValue(Ot, Ct.setFromMatrixPosition(t.matrixWorld));
        }
        (i.isMeshPhongMaterial ||
          i.isMeshLambertMaterial ||
          i.isMeshBasicMaterial ||
          i.isMeshStandardMaterial ||
          i.isShaderMaterial ||
          i.skinning) &&
          l.setValue(Ot, 'viewMatrix', t.matrixWorldInverse);
      }
      if (i.skinning) {
        (l.setOptional(Ot, n, 'bindMatrix'), l.setOptional(Ot, n, 'bindMatrixInverse'));
        const f = n.skeleton;
        if (f) {
          const m = f.bones;
          if (Bt.floatVertexTextures) {
            if (void 0 === f.boneTexture) {
              let v = Math.sqrt(4 * m.length);
              ((v = Wa.ceilPowerOfTwo(v)), (v = Math.max(v, 4)));
              const g = new Float32Array(v * v * 4);
              g.set(f.boneMatrices);
              const x = new u(g, v, v, va, ca);
              ((f.boneMatrices = g), (f.boneTexture = x), (f.boneTextureSize = v));
            }
            (l.setValue(Ot, 'boneTexture', f.boneTexture), l.setValue(Ot, 'boneTextureSize', f.boneTextureSize));
          } else l.setOptional(Ot, f, 'boneMatrices');
        }
      }
      return (
        s &&
          (l.setValue(Ot, 'toneMappingExposure', j.toneMappingExposure),
          l.setValue(Ot, 'toneMappingWhitePoint', j.toneMappingWhitePoint),
          i.lights &&
            (function (t, e) {
              ((t.ambientLightColor.needsUpdate = e),
                (t.directionalLights.needsUpdate = e),
                (t.pointLights.needsUpdate = e),
                (t.spotLights.needsUpdate = e),
                (t.rectAreaLights.needsUpdate = e),
                (t.hemisphereLights.needsUpdate = e));
            })(p, c),
          e &&
            i.fog &&
            (function (t, e) {
              ((t.fogColor.value = e.color),
                e.isFog
                  ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                  : e.isFogExp2 && (t.fogDensity.value = e.density));
            })(p, e),
          i.isMeshBasicMaterial
            ? b(p, i)
            : i.isMeshLambertMaterial
              ? (b(p, i),
                (function (t, e) {
                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                })(p, i))
              : i.isMeshPhongMaterial
                ? (b(p, i),
                  i.isMeshToonMaterial
                    ? (function (t, e) {
                        (T(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap));
                      })(p, i)
                    : T(p, i))
                : i.isMeshStandardMaterial
                  ? (b(p, i),
                    i.isMeshPhysicalMaterial
                      ? (function (t, e) {
                          ((t.clearCoat.value = e.clearCoat),
                            (t.clearCoatRoughness.value = e.clearCoatRoughness),
                            S(t, e));
                        })(p, i)
                      : S(p, i))
                  : i.isMeshDepthMaterial
                    ? (b(p, i),
                      (function (t, e) {
                        e.displacementMap &&
                          ((t.displacementMap.value = e.displacementMap),
                          (t.displacementScale.value = e.displacementScale),
                          (t.displacementBias.value = e.displacementBias));
                      })(p, i))
                    : i.isMeshDistanceMaterial
                      ? (b(p, i),
                        (function (t, e) {
                          e.displacementMap &&
                            ((t.displacementMap.value = e.displacementMap),
                            (t.displacementScale.value = e.displacementScale),
                            (t.displacementBias.value = e.displacementBias));
                          (t.referencePosition.value.copy(e.referencePosition),
                            (t.nearDistance.value = e.nearDistance),
                            (t.farDistance.value = e.farDistance));
                        })(p, i))
                      : i.isMeshNormalMaterial
                        ? (b(p, i),
                          (function (t, e) {
                            e.bumpMap && ((t.bumpMap.value = e.bumpMap), (t.bumpScale.value = e.bumpScale));
                            e.normalMap && ((t.normalMap.value = e.normalMap), t.normalScale.value.copy(e.normalScale));
                            e.displacementMap &&
                              ((t.displacementMap.value = e.displacementMap),
                              (t.displacementScale.value = e.displacementScale),
                              (t.displacementBias.value = e.displacementBias));
                          })(p, i))
                        : i.isLineBasicMaterial
                          ? ((function (t, e) {
                              ((t.diffuse.value = e.color), (t.opacity.value = e.opacity));
                            })(p, i),
                            i.isLineDashedMaterial &&
                              (function (t, e) {
                                ((t.dashSize.value = e.dashSize),
                                  (t.totalSize.value = e.dashSize + e.gapSize),
                                  (t.scale.value = e.scale));
                              })(p, i))
                          : i.isPointsMaterial
                            ? (function (t, e) {
                                if (
                                  ((t.diffuse.value = e.color),
                                  (t.opacity.value = e.opacity),
                                  (t.size.value = e.size * wt),
                                  (t.scale.value = 0.5 * _t),
                                  (t.map.value = e.map),
                                  null !== e.map)
                                ) {
                                  if (!0 === e.map.matrixAutoUpdate) {
                                    const i = e.map.offset,
                                      n = e.map.repeat,
                                      r = e.map.rotation,
                                      a = e.map.center;
                                    e.map.matrix.setUvTransform(i.x, i.y, n.x, n.y, r, a.x, a.y);
                                  }
                                  t.uvTransform.value.copy(e.map.matrix);
                                }
                              })(p, i)
                            : i.isShadowMaterial && ((p.color.value = i.color), (p.opacity.value = i.opacity)),
          void 0 !== p.ltcMat && (p.ltcMat.value = eo.LTC_MAT_TEXTURE),
          void 0 !== p.ltcMag && (p.ltcMag.value = eo.LTC_MAG_TEXTURE),
          _.upload(Ot, r.uniformsList, p, j)),
        l.setValue(Ot, 'modelViewMatrix', n.modelViewMatrix),
        l.setValue(Ot, 'normalMatrix', n.normalMatrix),
        l.setValue(Ot, 'modelMatrix', n.matrixWorld),
        h
      );
    }
    function b(t, e) {
      ((t.opacity.value = e.opacity),
        e.color && (t.diffuse.value = e.color),
        e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity),
        e.map && (t.map.value = e.map),
        e.alphaMap && (t.alphaMap.value = e.alphaMap),
        e.specularMap && (t.specularMap.value = e.specularMap),
        e.envMap &&
          ((t.envMap.value = e.envMap),
          (t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1),
          (t.reflectivity.value = e.reflectivity),
          (t.refractionRatio.value = e.refractionRatio)),
        e.lightMap && ((t.lightMap.value = e.lightMap), (t.lightMapIntensity.value = e.lightMapIntensity)),
        e.aoMap && ((t.aoMap.value = e.aoMap), (t.aoMapIntensity.value = e.aoMapIntensity)));
      let i;
      if (
        (e.map
          ? (i = e.map)
          : e.specularMap
            ? (i = e.specularMap)
            : e.displacementMap
              ? (i = e.displacementMap)
              : e.normalMap
                ? (i = e.normalMap)
                : e.bumpMap
                  ? (i = e.bumpMap)
                  : e.roughnessMap
                    ? (i = e.roughnessMap)
                    : e.metalnessMap
                      ? (i = e.metalnessMap)
                      : e.alphaMap
                        ? (i = e.alphaMap)
                        : e.emissiveMap && (i = e.emissiveMap),
        void 0 !== i)
      ) {
        if ((i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate)) {
          const n = i.offset,
            r = i.repeat,
            a = i.rotation,
            o = i.center;
          i.matrix.setUvTransform(n.x, n.y, r.x, r.y, a, o.x, o.y);
        }
        t.uvTransform.value.copy(i.matrix);
      }
    }
    function T(t, e) {
      ((t.specular.value = e.specular),
        (t.shininess.value = Math.max(e.shininess, 1e-4)),
        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
        e.bumpMap && ((t.bumpMap.value = e.bumpMap), (t.bumpScale.value = e.bumpScale)),
        e.normalMap && ((t.normalMap.value = e.normalMap), t.normalScale.value.copy(e.normalScale)),
        e.displacementMap &&
          ((t.displacementMap.value = e.displacementMap),
          (t.displacementScale.value = e.displacementScale),
          (t.displacementBias.value = e.displacementBias)));
    }
    function S(t, e) {
      ((t.roughness.value = e.roughness),
        (t.metalness.value = e.metalness),
        e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
        e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
        e.bumpMap && ((t.bumpMap.value = e.bumpMap), (t.bumpScale.value = e.bumpScale)),
        e.normalMap && ((t.normalMap.value = e.normalMap), t.normalScale.value.copy(e.normalScale)),
        e.displacementMap &&
          ((t.displacementMap.value = e.displacementMap),
          (t.displacementScale.value = e.displacementScale),
          (t.displacementBias.value = e.displacementBias)),
        e.envMap && (t.envMapIntensity.value = e.envMapIntensity));
    }
    console.log('THREE.WebGLRenderer', kn);
    var A =
        void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
      R = void 0 !== t.context ? t.context : null,
      L = void 0 !== t.alpha && t.alpha,
      D = void 0 === t.depth || t.depth,
      O = void 0 === t.stencil || t.stencil,
      U = void 0 !== t.antialias && t.antialias,
      N = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
      F = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
      z = [],
      G = [],
      H = null,
      V = [],
      k = [];
    ((this.domElement = A),
      (this.context = null),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.gammaFactor = 2),
      (this.gammaInput = !1),
      (this.gammaOutput = !1),
      (this.physicallyCorrectLights = !1),
      (this.toneMapping = Nr),
      (this.toneMappingExposure = 1),
      (this.toneMappingWhitePoint = 1),
      (this.maxMorphTargets = 8),
      (this.maxMorphNormals = 4));
    var j = this,
      X = !1,
      Y = null,
      Z = null,
      Q = -1,
      $ = '',
      et = null,
      at = null,
      ot = new c(),
      st = new c(),
      vt = null,
      gt = 0,
      bt = A.width,
      _t = A.height,
      wt = 1,
      Et = new c(0, 0, bt, _t),
      Mt = new c(0, 0, bt, _t),
      Tt = !1,
      St = new C(),
      At = new (function () {
        function t() {
          (l.value !== n && ((l.value = n), (l.needsUpdate = r > 0)), (i.numPlanes = r), (i.numIntersection = 0));
        }
        function e(t, e, n, r) {
          let a = null !== t ? t.length : 0,
            o = null;
          if (0 !== a) {
            if (((o = l.value), !0 !== r || null === o)) {
              const s = n + 4 * a,
                u = e.matrixWorldInverse;
              (h.getNormalMatrix(u), (null === o || o.length < s) && (o = new Float32Array(s)));
              for (let p = 0, d = n; p !== a; ++p, d += 4)
                (c.copy(t[p]).applyMatrix4(u, h), c.normal.toArray(o, d), (o[d + 3] = c.constant));
            }
            ((l.value = o), (l.needsUpdate = !0));
          }
          return ((i.numPlanes = a), o);
        }
        var i = this,
          n = null,
          r = 0,
          a = !1,
          s = !1,
          c = new P(),
          h = new o(),
          l = { value: null, needsUpdate: !1 };
        ((this.uniform = l),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (t, i, o) {
            const s = 0 !== t.length || i || 0 !== r || a;
            return ((a = i), (n = e(t, o, 0)), (r = t.length), s);
          }),
          (this.beginShadows = function () {
            ((s = !0), e(null));
          }),
          (this.endShadows = function () {
            ((s = !1), t());
          }),
          (this.setState = function (i, o, c, h, u, p) {
            if (!a || null === i || 0 === i.length || (s && !c)) s ? e(null) : t();
            else {
              let d = s ? 0 : r,
                f = 4 * d,
                m = u.clippingState || null;
              ((l.value = m), (m = e(i, h, f, p)));
              for (let v = 0; v !== f; ++v) m[v] = n[v];
              ((u.clippingState = m), (this.numIntersection = o ? this.numPlanes : 0), (this.numPlanes += d));
            }
          }));
      })(),
      Rt = !1,
      Lt = !1,
      Pt = new n(),
      Ct = new a(),
      It = { geometries: 0, textures: 0 },
      Dt = { frame: 0, calls: 0, vertices: 0, faces: 0, points: 0 };
    this.info = { render: Dt, memory: It, programs: null };
    let Ot;
    try {
      const Ut = { alpha: L, depth: D, stencil: O, antialias: U, premultipliedAlpha: N, preserveDrawingBuffer: F };
      if (null === (Ot = R || A.getContext('webgl', Ut) || A.getContext('experimental-webgl', Ut)))
        throw null !== A.getContext('webgl')
          ? 'Error creating WebGL context with your selected attributes.'
          : 'Error creating WebGL context.';
      (void 0 === Ot.getShaderPrecisionFormat &&
        (Ot.getShaderPrecisionFormat = function () {
          return { rangeMin: 1, rangeMax: 1, precision: 1 };
        }),
        A.addEventListener('webglcontextlost', h, !1),
        A.addEventListener('webglcontextrestored', l, !1));
    } catch (t) {
      console.error('THREE.WebGLRenderer: ' + t);
    }
    let Nt, Bt, Ft, zt, Gt, Ht, Vt, kt, jt, Wt, Xt, qt, Yt, Zt, Qt, Jt, Kt, $t;
    s();
    var te = new yt(j);
    this.vr = te;
    const ee = new I(j, kt, Bt.maxTextureSize);
    ((this.shadowMap = ee),
      (this.getContext = function () {
        return Ot;
      }),
      (this.getContextAttributes = function () {
        return Ot.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const t = Nt.get('WEBGL_lose_context');
        t && t.loseContext();
      }),
      (this.forceContextRestore = function () {
        const t = Nt.get('WEBGL_lose_context');
        t && t.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return wt;
      }),
      (this.setPixelRatio = function (t) {
        void 0 !== t && ((wt = t), this.setSize(bt, _t, !1));
      }),
      (this.getSize = function () {
        return { width: bt, height: _t };
      }),
      (this.setSize = function (t, e, i) {
        const n = te.getDevice();
        n && n.isPresenting
          ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.")
          : ((bt = t),
            (_t = e),
            (A.width = t * wt),
            (A.height = e * wt),
            !1 !== i && ((A.style.width = t + 'px'), (A.style.height = e + 'px')),
            this.setViewport(0, 0, t, e));
      }),
      (this.getDrawingBufferSize = function () {
        return { width: bt * wt, height: _t * wt };
      }),
      (this.setDrawingBufferSize = function (t, e, i) {
        ((bt = t), (_t = e), (wt = i), (A.width = t * i), (A.height = e * i), this.setViewport(0, 0, t, e));
      }),
      (this.setViewport = function (t, e, i, n) {
        (Et.set(t, _t - e - n, i, n), Ft.viewport(ot.copy(Et).multiplyScalar(wt)));
      }),
      (this.setScissor = function (t, e, i, n) {
        (Mt.set(t, _t - e - n, i, n), Ft.scissor(st.copy(Mt).multiplyScalar(wt)));
      }),
      (this.setScissorTest = function (t) {
        Ft.setScissorTest((Tt = t));
      }),
      (this.getClearColor = function () {
        return qt.getClearColor();
      }),
      (this.setClearColor = function () {
        qt.setClearColor.apply(qt, arguments);
      }),
      (this.getClearAlpha = function () {
        return qt.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        qt.setClearAlpha.apply(qt, arguments);
      }),
      (this.clear = function (t, e, i) {
        let n = 0;
        ((void 0 === t || t) && (n |= Ot.COLOR_BUFFER_BIT),
          (void 0 === e || e) && (n |= Ot.DEPTH_BUFFER_BIT),
          (void 0 === i || i) && (n |= Ot.STENCIL_BUFFER_BIT),
          Ot.clear(n));
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.clearTarget = function (t, e, i, n) {
        (this.setRenderTarget(t), this.clear(e, i, n));
      }),
      (this.dispose = function () {
        (A.removeEventListener('webglcontextlost', h, !1),
          A.removeEventListener('webglcontextrestored', l, !1),
          Xt.dispose(),
          te.dispose());
      }),
      (this.renderBufferImmediate = function (t, e, i) {
        Ft.initAttributes();
        const n = zt.get(t);
        (t.hasPositions && !n.position && (n.position = Ot.createBuffer()),
          t.hasNormals && !n.normal && (n.normal = Ot.createBuffer()),
          t.hasUvs && !n.uv && (n.uv = Ot.createBuffer()),
          t.hasColors && !n.color && (n.color = Ot.createBuffer()));
        const r = e.getAttributes();
        if (
          (t.hasPositions &&
            (Ot.bindBuffer(Ot.ARRAY_BUFFER, n.position),
            Ot.bufferData(Ot.ARRAY_BUFFER, t.positionArray, Ot.DYNAMIC_DRAW),
            Ft.enableAttribute(r.position),
            Ot.vertexAttribPointer(r.position, 3, Ot.FLOAT, !1, 0, 0)),
          t.hasNormals)
        ) {
          if (
            (Ot.bindBuffer(Ot.ARRAY_BUFFER, n.normal),
            !i.isMeshPhongMaterial && !i.isMeshStandardMaterial && !i.isMeshNormalMaterial && !0 === i.flatShading)
          )
            for (let a = 0, o = 3 * t.count; a < o; a += 9) {
              const s = t.normalArray,
                c = (s[a + 0] + s[a + 3] + s[a + 6]) / 3,
                h = (s[a + 1] + s[a + 4] + s[a + 7]) / 3,
                l = (s[a + 2] + s[a + 5] + s[a + 8]) / 3;
              ((s[a + 0] = c),
                (s[a + 1] = h),
                (s[a + 2] = l),
                (s[a + 3] = c),
                (s[a + 4] = h),
                (s[a + 5] = l),
                (s[a + 6] = c),
                (s[a + 7] = h),
                (s[a + 8] = l));
            }
          (Ot.bufferData(Ot.ARRAY_BUFFER, t.normalArray, Ot.DYNAMIC_DRAW),
            Ft.enableAttribute(r.normal),
            Ot.vertexAttribPointer(r.normal, 3, Ot.FLOAT, !1, 0, 0));
        }
        (t.hasUvs &&
          i.map &&
          (Ot.bindBuffer(Ot.ARRAY_BUFFER, n.uv),
          Ot.bufferData(Ot.ARRAY_BUFFER, t.uvArray, Ot.DYNAMIC_DRAW),
          Ft.enableAttribute(r.uv),
          Ot.vertexAttribPointer(r.uv, 2, Ot.FLOAT, !1, 0, 0)),
          t.hasColors &&
            i.vertexColors !== $n &&
            (Ot.bindBuffer(Ot.ARRAY_BUFFER, n.color),
            Ot.bufferData(Ot.ARRAY_BUFFER, t.colorArray, Ot.DYNAMIC_DRAW),
            Ft.enableAttribute(r.color),
            Ot.vertexAttribPointer(r.color, 3, Ot.FLOAT, !1, 0, 0)),
          Ft.disableUnusedAttributes(),
          Ot.drawArrays(Ot.TRIANGLES, 0, t.count),
          (t.count = 0));
      }),
      (this.renderBufferDirect = function (t, i, n, r, a, o) {
        Ft.setMaterial(r);
        let s = x(t, i, r, a),
          c = n.id + '_' + s.id + '_' + (!0 === r.wireframe),
          h = !1;
        (c !== $ && (($ = c), (h = !0)), a.morphTargetInfluences && (Yt.update(a, n, r, s), (h = !0)));
        let l = n.index,
          u = n.attributes.position,
          p = 1;
        !0 === r.wireframe && ((l = Vt.getWireframeAttribute(n)), (p = 2));
        let d,
          f = Zt;
        (null !== l && ((d = Ht.get(l)), (f = Qt).setIndex(d)),
          h &&
            (!(function (t, e, i, n) {
              if (i && i.isInstancedBufferGeometry && null === Nt.get('ANGLE_instanced_arrays'))
                console.error(
                  'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
                );
              else {
                (void 0 === n && (n = 0), Ft.initAttributes());
                const r = i.attributes,
                  a = e.getAttributes(),
                  o = t.defaultAttributeValues;
                for (const s in a) {
                  const c = a[s];
                  if (c >= 0) {
                    const h = r[s];
                    if (void 0 !== h) {
                      const l = h.normalized,
                        u = h.itemSize,
                        p = Ht.get(h);
                      if (void 0 === p) continue;
                      const d = p.buffer,
                        f = p.type,
                        m = p.bytesPerElement;
                      if (h.isInterleavedBufferAttribute) {
                        const v = h.data,
                          g = v.stride,
                          y = h.offset;
                        (v && v.isInstancedInterleavedBuffer
                          ? (Ft.enableAttributeAndDivisor(c, v.meshPerAttribute),
                            void 0 === i.maxInstancedCount && (i.maxInstancedCount = v.meshPerAttribute * v.count))
                          : Ft.enableAttribute(c),
                          Ot.bindBuffer(Ot.ARRAY_BUFFER, d),
                          Ot.vertexAttribPointer(c, u, f, l, g * m, (n * g + y) * m));
                      } else
                        (h.isInstancedBufferAttribute
                          ? (Ft.enableAttributeAndDivisor(c, h.meshPerAttribute),
                            void 0 === i.maxInstancedCount && (i.maxInstancedCount = h.meshPerAttribute * h.count))
                          : Ft.enableAttribute(c),
                          Ot.bindBuffer(Ot.ARRAY_BUFFER, d),
                          Ot.vertexAttribPointer(c, u, f, l, 0, n * u * m));
                    } else if (void 0 !== o) {
                      const x = o[s];
                      if (void 0 !== x)
                        switch (x.length) {
                          case 2:
                            Ot.vertexAttrib2fv(c, x);
                            break;
                          case 3:
                            Ot.vertexAttrib3fv(c, x);
                            break;
                          case 4:
                            Ot.vertexAttrib4fv(c, x);
                            break;
                          default:
                            Ot.vertexAttrib1fv(c, x);
                        }
                    }
                  }
                }
                Ft.disableUnusedAttributes();
              }
            })(r, s, n),
            null !== l && Ot.bindBuffer(Ot.ELEMENT_ARRAY_BUFFER, d.buffer)));
        let m = 0;
        null !== l ? (m = l.count) : void 0 !== u && (m = u.count);
        const v = n.drawRange.start * p,
          g = n.drawRange.count * p,
          y = null !== o ? o.start * p : 0,
          b = null !== o ? o.count * p : 1 / 0,
          _ = Math.max(v, y),
          w = Math.min(m, v + g, y + b) - 1,
          E = Math.max(0, w - _ + 1);
        if (0 !== E) {
          if (a.isMesh)
            if (!0 === r.wireframe) (Ft.setLineWidth(r.wireframeLinewidth * e()), f.setMode(Ot.LINES));
            else
              switch (a.drawMode) {
                case Da:
                  f.setMode(Ot.TRIANGLES);
                  break;
                case Oa:
                  f.setMode(Ot.TRIANGLE_STRIP);
                  break;
                case Ua:
                  f.setMode(Ot.TRIANGLE_FAN);
              }
          else if (a.isLine) {
            let M = r.linewidth;
            (void 0 === M && (M = 1),
              Ft.setLineWidth(M * e()),
              a.isLineSegments
                ? f.setMode(Ot.LINES)
                : a.isLineLoop
                  ? f.setMode(Ot.LINE_LOOP)
                  : f.setMode(Ot.LINE_STRIP));
          } else a.isPoints && f.setMode(Ot.POINTS);
          n && n.isInstancedBufferGeometry ? n.maxInstancedCount > 0 && f.renderInstances(n, _, E) : f.render(_, E);
        }
      }),
      (this.compile = function (t, e) {
        ((z.length = 0),
          (G.length = 0),
          t.traverse(function (t) {
            t.isLight && (z.push(t), t.castShadow && G.push(t));
          }),
          jt.setup(z, G, e),
          t.traverse(function (e) {
            if (e.material)
              if (Array.isArray(e.material)) for (let i = 0; i < e.material.length; i++) y(e.material[i], t.fog, e);
              else y(e.material, t.fog, e);
          }));
      }));
    var ie = !1,
      ne = null;
    ((this.animate = function (t) {
      ((ne = t),
        (function () {
          if (!ie) {
            const t = te.getDevice();
            (t && t.isPresenting ? t.requestAnimationFrame(f) : window.requestAnimationFrame(f), (ie = !0));
          }
        })());
    }),
      (this.render = function (t, e, i, n) {
        if (e && e.isCamera) {
          if (!X) {
            (($ = ''),
              (Q = -1),
              (et = null),
              !0 === t.autoUpdate && t.updateMatrixWorld(),
              null === e.parent && e.updateMatrixWorld(),
              te.enabled && (e = te.getCamera(e)),
              Pt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
              St.setFromMatrix(Pt),
              (z.length = 0),
              (G.length = 0),
              (V.length = 0),
              (k.length = 0),
              (Lt = this.localClippingEnabled),
              (Rt = At.init(this.clippingPlanes, Lt, e)),
              (H = Xt.get(t, e)).init(),
              m(t, e, j.sortObjects),
              !0 === j.sortObjects && H.sort(),
              Rt && At.beginShadows(),
              ee.render(G, t, e),
              jt.setup(z, G, e),
              Rt && At.endShadows(),
              Dt.frame++,
              (Dt.calls = 0),
              (Dt.vertices = 0),
              (Dt.faces = 0),
              (Dt.points = 0),
              void 0 === i && (i = null),
              this.setRenderTarget(i),
              qt.render(H, t, e, n));
            const r = H.opaque,
              a = H.transparent;
            if (t.overrideMaterial) {
              const o = t.overrideMaterial;
              (r.length && v(r, t, e, o), a.length && v(a, t, e, o));
            } else (r.length && v(r, t, e), a.length && v(a, t, e));
            (Kt.render(V, t, e),
              Jt.render(k, t, e, ot),
              i && Gt.updateRenderTargetMipmap(i),
              Ft.buffers.depth.setTest(!0),
              Ft.buffers.depth.setMask(!0),
              Ft.buffers.color.setMask(!0),
              Ft.setPolygonOffset(!1),
              te.enabled && te.submitFrame());
          }
        } else console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
      }),
      (this.setFaceCulling = function (t, e) {
        (Ft.setCullFace(t), Ft.setFlipSided(e === qn));
      }),
      (this.allocTextureUnit = function () {
        const t = gt;
        return (
          t >= Bt.maxTextures &&
            console.warn(
              'THREE.WebGLRenderer: Trying to use ' +
                t +
                ' texture units while this GPU supports only ' +
                Bt.maxTextures
            ),
          (gt += 1),
          t
        );
      }),
      (this.setTexture2D = (function () {
        let t = !1;
        return function (e, i) {
          (e &&
            e.isWebGLRenderTarget &&
            (t ||
              (console.warn(
                "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."
              ),
              (t = !0)),
            (e = e.texture)),
            Gt.setTexture2D(e, i));
        };
      })()),
      (this.setTexture = (function () {
        let t = !1;
        return function (e, i) {
          (t || (console.warn('THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.'), (t = !0)),
            Gt.setTexture2D(e, i));
        };
      })()),
      (this.setTextureCube = (function () {
        let t = !1;
        return function (e, i) {
          (e &&
            e.isWebGLRenderTargetCube &&
            (t ||
              (console.warn(
                "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."
              ),
              (t = !0)),
            (e = e.texture)),
            (e && e.isCubeTexture) || (Array.isArray(e.image) && 6 === e.image.length)
              ? Gt.setTextureCube(e, i)
              : Gt.setTextureCubeDynamic(e, i));
        };
      })()),
      (this.getRenderTarget = function () {
        return Y;
      }),
      (this.setRenderTarget = function (t) {
        ((Y = t), t && void 0 === zt.get(t).__webglFramebuffer && Gt.setupRenderTarget(t));
        let e = null,
          i = !1;
        if (t) {
          const n = zt.get(t).__webglFramebuffer;
          (t.isWebGLRenderTargetCube ? ((e = n[t.activeCubeFace]), (i = !0)) : (e = n),
            ot.copy(t.viewport),
            st.copy(t.scissor),
            (vt = t.scissorTest));
        } else (ot.copy(Et).multiplyScalar(wt), st.copy(Mt).multiplyScalar(wt), (vt = Tt));
        if (
          (Z !== e && (Ot.bindFramebuffer(Ot.FRAMEBUFFER, e), (Z = e)),
          Ft.viewport(ot),
          Ft.scissor(st),
          Ft.setScissorTest(vt),
          i)
        ) {
          const r = zt.get(t.texture);
          Ot.framebufferTexture2D(
            Ot.FRAMEBUFFER,
            Ot.COLOR_ATTACHMENT0,
            Ot.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace,
            r.__webglTexture,
            t.activeMipMapLevel
          );
        }
      }),
      (this.readRenderTargetPixels = function (t, e, i, n, r, a) {
        if (t && t.isWebGLRenderTarget) {
          const o = zt.get(t).__webglFramebuffer;
          if (o) {
            let s = !1;
            o !== Z && (Ot.bindFramebuffer(Ot.FRAMEBUFFER, o), (s = !0));
            try {
              const c = t.texture,
                h = c.format,
                l = c.type;
              if (h !== va && $t.convert(h) !== Ot.getParameter(Ot.IMPLEMENTATION_COLOR_READ_FORMAT))
                return void console.error(
                  'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.'
                );
              if (
                !(
                  l === ia ||
                  $t.convert(l) === Ot.getParameter(Ot.IMPLEMENTATION_COLOR_READ_TYPE) ||
                  (l === ca && (Nt.get('OES_texture_float') || Nt.get('WEBGL_color_buffer_float'))) ||
                  (l === ha && Nt.get('EXT_color_buffer_half_float'))
                )
              )
                return void console.error(
                  'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.'
                );
              Ot.checkFramebufferStatus(Ot.FRAMEBUFFER) === Ot.FRAMEBUFFER_COMPLETE
                ? e >= 0 &&
                  e <= t.width - n &&
                  i >= 0 &&
                  i <= t.height - r &&
                  Ot.readPixels(e, i, n, r, $t.convert(h), $t.convert(l), a)
                : console.error(
                    'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.'
                  );
            } finally {
              s && Ot.bindFramebuffer(Ot.FRAMEBUFFER, Z);
            }
          }
        } else
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
      }));
  }
  function _t(t, e) {
    ((this.name = ''), (this.color = new w(t)), (this.density = void 0 !== e ? e : 25e-5));
  }
  function wt(t, e, i) {
    ((this.name = ''),
      (this.color = new w(t)),
      (this.near = void 0 !== e ? e : 1),
      (this.far = void 0 !== i ? i : 1e3));
  }
  function Et() {
    (U.call(this),
      (this.type = 'Scene'),
      (this.background = null),
      (this.fog = null),
      (this.overrideMaterial = null),
      (this.autoUpdate = !0));
  }
  function Mt(t, e, i, n, r) {
    (U.call(this),
      (this.lensFlares = []),
      (this.positionScreen = new a()),
      (this.customUpdateCallback = void 0),
      void 0 !== t && this.add(t, e, i, n, r));
  }
  function Tt(t) {
    (T.call(this),
      (this.type = 'SpriteMaterial'),
      (this.color = new w(16777215)),
      (this.map = null),
      (this.rotation = 0),
      (this.fog = !1),
      (this.lights = !1),
      this.setValues(t));
  }
  function St(t) {
    (U.call(this), (this.type = 'Sprite'), (this.material = void 0 !== t ? t : new Tt()));
  }
  function At() {
    (U.call(this), (this.type = 'LOD'), Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }));
  }
  function Rt(t, e) {
    if (
      ((t = t || []),
      (this.bones = t.slice(0)),
      (this.boneMatrices = new Float32Array(16 * this.bones.length)),
      void 0 === e)
    )
      this.calculateInverses();
    else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
    else {
      (console.warn('THREE.Skeleton boneInverses is the wrong length.'), (this.boneInverses = []));
      for (let i = 0, r = this.bones.length; i < r; i++) this.boneInverses.push(new n());
    }
  }
  function Lt() {
    (U.call(this), (this.type = 'Bone'));
  }
  function Pt(t, e) {
    (ct.call(this, t, e),
      (this.type = 'SkinnedMesh'),
      (this.bindMode = 'attached'),
      (this.bindMatrix = new n()),
      (this.bindMatrixInverse = new n()));
    const i = new Rt(this.initBones());
    (this.bind(i, this.matrixWorld), this.normalizeSkinWeights());
  }
  function Ct(t) {
    (T.call(this),
      (this.type = 'LineBasicMaterial'),
      (this.color = new w(16777215)),
      (this.linewidth = 1),
      (this.linecap = 'round'),
      (this.linejoin = 'round'),
      (this.lights = !1),
      this.setValues(t));
  }
  function It(t, e, i) {
    if (1 === i)
      return (
        console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.'),
        new Dt(t, e)
      );
    (U.call(this),
      (this.type = 'Line'),
      (this.geometry = void 0 !== t ? t : new K()),
      (this.material = void 0 !== e ? e : new Ct({ color: 16777215 * Math.random() })));
  }
  function Dt(t, e) {
    (It.call(this, t, e), (this.type = 'LineSegments'));
  }
  function Ot(t, e) {
    (It.call(this, t, e), (this.type = 'LineLoop'));
  }
  function Ut(t) {
    (T.call(this),
      (this.type = 'PointsMaterial'),
      (this.color = new w(16777215)),
      (this.map = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.lights = !1),
      this.setValues(t));
  }
  function Nt(t, e) {
    (U.call(this),
      (this.type = 'Points'),
      (this.geometry = void 0 !== t ? t : new K()),
      (this.material = void 0 !== e ? e : new Ut({ color: 16777215 * Math.random() })));
  }
  function Bt() {
    (U.call(this), (this.type = 'Group'));
  }
  function Ft(t, e, i, n, r, a, o, c, h) {
    function l() {
      const t = u.image;
      (t.readyState >= t.HAVE_CURRENT_DATA && (u.needsUpdate = !0), requestAnimationFrame(l));
    }
    (s.call(this, t, e, i, n, r, a, o, c, h), (this.generateMipmaps = !1));
    var u = this;
    requestAnimationFrame(l);
  }
  function zt(t, e, i, n, r, a, o, c, h, l, u, p) {
    (s.call(this, null, a, o, c, h, l, n, r, u, p),
      (this.image = { width: e, height: i }),
      (this.mipmaps = t),
      (this.flipY = !1),
      (this.generateMipmaps = !1));
  }
  function Gt(t, e, i, n, r, a, o, c, h, l) {
    if ((l = void 0 !== l ? l : ba) !== ba && l !== _a)
      throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
    (void 0 === i && l === ba && (i = aa),
      void 0 === i && l === _a && (i = da),
      s.call(this, null, n, r, a, o, c, l, i, h),
      (this.image = { width: t, height: e }),
      (this.magFilter = void 0 !== o ? o : Qr),
      (this.minFilter = void 0 !== c ? c : Qr),
      (this.flipY = !1),
      (this.generateMipmaps = !1));
  }
  function Ht(t) {
    (K.call(this), (this.type = 'WireframeGeometry'));
    let e,
      i,
      n,
      r,
      o,
      s,
      c,
      h,
      l,
      u,
      p = [],
      d = [0, 0],
      f = {},
      m = ['a', 'b', 'c'];
    if (t && t.isGeometry) {
      const v = t.faces;
      for (e = 0, n = v.length; e < n; e++) {
        const g = v[e];
        for (i = 0; i < 3; i++)
          ((c = g[m[i]]),
            (h = g[m[(i + 1) % 3]]),
            (d[0] = Math.min(c, h)),
            (d[1] = Math.max(c, h)),
            void 0 === f[(l = d[0] + ',' + d[1])] && (f[l] = { index1: d[0], index2: d[1] }));
      }
      for (l in f)
        ((s = f[l]),
          (u = t.vertices[s.index1]),
          p.push(u.x, u.y, u.z),
          (u = t.vertices[s.index2]),
          p.push(u.x, u.y, u.z));
    } else if (t && t.isBufferGeometry) {
      let y, x, b, _, w, E, M;
      if (((u = new a()), null !== t.index)) {
        for (
          y = t.attributes.position,
            x = t.index,
            0 === (b = t.groups).length && (b = [{ start: 0, count: x.count, materialIndex: 0 }]),
            r = 0,
            o = b.length;
          r < o;
          ++r
        )
          for (e = w = (_ = b[r]).start, n = w + _.count; e < n; e += 3)
            for (i = 0; i < 3; i++)
              ((c = x.getX(e + i)),
                (h = x.getX(e + ((i + 1) % 3))),
                (d[0] = Math.min(c, h)),
                (d[1] = Math.max(c, h)),
                void 0 === f[(l = d[0] + ',' + d[1])] && (f[l] = { index1: d[0], index2: d[1] }));
        for (l in f)
          ((s = f[l]),
            u.fromBufferAttribute(y, s.index1),
            p.push(u.x, u.y, u.z),
            u.fromBufferAttribute(y, s.index2),
            p.push(u.x, u.y, u.z));
      } else
        for (e = 0, n = (y = t.attributes.position).count / 3; e < n; e++)
          for (i = 0; i < 3; i++)
            ((E = 3 * e + i),
              u.fromBufferAttribute(y, E),
              p.push(u.x, u.y, u.z),
              (M = 3 * e + ((i + 1) % 3)),
              u.fromBufferAttribute(y, M),
              p.push(u.x, u.y, u.z));
    }
    this.addAttribute('position', new Y(p, 3));
  }
  function Vt(t, e, i) {
    (z.call(this),
      (this.type = 'ParametricGeometry'),
      (this.parameters = { func: t, slices: e, stacks: i }),
      this.fromBufferGeometry(new kt(t, e, i)),
      this.mergeVertices());
  }
  function kt(t, e, i) {
    (K.call(this), (this.type = 'ParametricBufferGeometry'), (this.parameters = { func: t, slices: e, stacks: i }));
    let n,
      r,
      o = [],
      s = [],
      c = [],
      h = [],
      l = new a(),
      u = new a(),
      p = new a(),
      d = new a(),
      f = new a(),
      m = e + 1;
    for (n = 0; n <= i; n++) {
      const v = n / i;
      for (r = 0; r <= e; r++) {
        const g = r / e;
        ((u = t(g, v, u)),
          s.push(u.x, u.y, u.z),
          g - 1e-5 >= 0 ? ((p = t(g - 1e-5, v, p)), d.subVectors(u, p)) : ((p = t(g + 1e-5, v, p)), d.subVectors(p, u)),
          v - 1e-5 >= 0 ? ((p = t(g, v - 1e-5, p)), f.subVectors(u, p)) : ((p = t(g, v + 1e-5, p)), f.subVectors(p, u)),
          l.crossVectors(d, f).normalize(),
          c.push(l.x, l.y, l.z),
          h.push(g, v));
      }
    }
    for (n = 0; n < i; n++)
      for (r = 0; r < e; r++) {
        const y = n * m + r,
          x = n * m + r + 1,
          b = (n + 1) * m + r + 1,
          _ = (n + 1) * m + r;
        (o.push(y, x, _), o.push(x, b, _));
      }
    (this.setIndex(o),
      this.addAttribute('position', new Y(s, 3)),
      this.addAttribute('normal', new Y(c, 3)),
      this.addAttribute('uv', new Y(h, 2)));
  }
  function jt(t, e, i, n) {
    (z.call(this),
      (this.type = 'PolyhedronGeometry'),
      (this.parameters = { vertices: t, indices: e, radius: i, detail: n }),
      this.fromBufferGeometry(new Wt(t, e, i, n)),
      this.mergeVertices());
  }
  function Wt(t, e, n, r) {
    function o(t) {
      l.push(t.x, t.y, t.z);
    }
    function s(e, i) {
      const n = 3 * e;
      ((i.x = t[n + 0]), (i.y = t[n + 1]), (i.z = t[n + 2]));
    }
    function c(t, e, i, n) {
      (n < 0 && 1 === t.x && (u[e] = t.x - 1), 0 === i.x && 0 === i.z && (u[e] = n / 2 / Math.PI + 0.5));
    }
    function h(t) {
      return Math.atan2(t.z, -t.x);
    }
    (K.call(this),
      (this.type = 'PolyhedronBufferGeometry'),
      (this.parameters = { vertices: t, indices: e, radius: n, detail: r }),
      (n = n || 1));
    var l = [],
      u = [];
    (!(function (t) {
      for (let i = new a(), n = new a(), r = new a(), c = 0; c < e.length; c += 3)
        (s(e[c + 0], i),
          s(e[c + 1], n),
          s(e[c + 2], r),
          (function (t, e, i, n) {
            let r,
              a,
              s = Math.pow(2, n),
              c = [];
            for (r = 0; r <= s; r++) {
              c[r] = [];
              const h = t.clone().lerp(i, r / s),
                l = e.clone().lerp(i, r / s),
                u = s - r;
              for (a = 0; a <= u; a++) c[r][a] = 0 === a && r === s ? h : h.clone().lerp(l, a / u);
            }
            for (r = 0; r < s; r++)
              for (a = 0; a < 2 * (s - r) - 1; a++) {
                const p = Math.floor(a / 2);
                a % 2 == 0
                  ? (o(c[r][p + 1]), o(c[r + 1][p]), o(c[r][p]))
                  : (o(c[r][p + 1]), o(c[r + 1][p + 1]), o(c[r + 1][p]));
              }
          })(i, n, r, t));
    })((r = r || 0)),
      (function (t) {
        for (let e = new a(), i = 0; i < l.length; i += 3)
          ((e.x = l[i + 0]),
            (e.y = l[i + 1]),
            (e.z = l[i + 2]),
            e.normalize().multiplyScalar(t),
            (l[i + 0] = e.x),
            (l[i + 1] = e.y),
            (l[i + 2] = e.z));
      })(n),
      (function () {
        for (let t = new a(), e = 0; e < l.length; e += 3) {
          ((t.x = l[e + 0]), (t.y = l[e + 1]), (t.z = l[e + 2]));
          const n = h(t) / 2 / Math.PI + 0.5,
            r =
              (function (t) {
                return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z));
              })(t) /
                Math.PI +
              0.5;
          u.push(n, 1 - r);
        }
        (!(function () {
          for (
            let t = new a(), e = new a(), n = new a(), r = new a(), o = new i(), s = new i(), p = new i(), d = 0, f = 0;
            d < l.length;
            d += 9, f += 6
          ) {
            (t.set(l[d + 0], l[d + 1], l[d + 2]),
              e.set(l[d + 3], l[d + 4], l[d + 5]),
              n.set(l[d + 6], l[d + 7], l[d + 8]),
              o.set(u[f + 0], u[f + 1]),
              s.set(u[f + 2], u[f + 3]),
              p.set(u[f + 4], u[f + 5]),
              r.copy(t).add(e).add(n).divideScalar(3));
            const m = h(r);
            (c(o, f + 0, t, m), c(s, f + 2, e, m), c(p, f + 4, n, m));
          }
        })(),
          (function () {
            for (let t = 0; t < u.length; t += 6) {
              const e = u[t + 0],
                i = u[t + 2],
                n = u[t + 4],
                r = Math.max(e, i, n),
                a = Math.min(e, i, n);
              r > 0.9 &&
                a < 0.1 &&
                (e < 0.2 && (u[t + 0] += 1), i < 0.2 && (u[t + 2] += 1), n < 0.2 && (u[t + 4] += 1));
            }
          })());
      })(),
      this.addAttribute('position', new Y(l, 3)),
      this.addAttribute('normal', new Y(l.slice(), 3)),
      this.addAttribute('uv', new Y(u, 2)),
      0 === r ? this.computeVertexNormals() : this.normalizeNormals());
  }
  function Xt(t, e) {
    (z.call(this),
      (this.type = 'TetrahedronGeometry'),
      (this.parameters = { radius: t, detail: e }),
      this.fromBufferGeometry(new qt(t, e)),
      this.mergeVertices());
  }
  function qt(t, e) {
    (Wt.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e),
      (this.type = 'TetrahedronBufferGeometry'),
      (this.parameters = { radius: t, detail: e }));
  }
  function Yt(t, e) {
    (z.call(this),
      (this.type = 'OctahedronGeometry'),
      (this.parameters = { radius: t, detail: e }),
      this.fromBufferGeometry(new Zt(t, e)),
      this.mergeVertices());
  }
  function Zt(t, e) {
    (Wt.call(
      this,
      [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
      t,
      e
    ),
      (this.type = 'OctahedronBufferGeometry'),
      (this.parameters = { radius: t, detail: e }));
  }
  function Qt(t, e) {
    (z.call(this),
      (this.type = 'IcosahedronGeometry'),
      (this.parameters = { radius: t, detail: e }),
      this.fromBufferGeometry(new Jt(t, e)),
      this.mergeVertices());
  }
  function Jt(t, e) {
    const i = (1 + Math.sqrt(5)) / 2;
    (Wt.call(
      this,
      [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1,
      ],
      [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4,
        2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ],
      t,
      e
    ),
      (this.type = 'IcosahedronBufferGeometry'),
      (this.parameters = { radius: t, detail: e }));
  }
  function Kt(t, e) {
    (z.call(this),
      (this.type = 'DodecahedronGeometry'),
      (this.parameters = { radius: t, detail: e }),
      this.fromBufferGeometry(new $t(t, e)),
      this.mergeVertices());
  }
  function $t(t, e) {
    const i = (1 + Math.sqrt(5)) / 2,
      n = 1 / i;
    (Wt.call(
      this,
      [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -n,
        -i,
        0,
        -n,
        i,
        0,
        n,
        -i,
        0,
        n,
        i,
        -n,
        -i,
        0,
        -n,
        i,
        0,
        n,
        -i,
        0,
        n,
        i,
        0,
        -i,
        0,
        -n,
        i,
        0,
        -n,
        -i,
        0,
        n,
        i,
        0,
        n,
      ],
      [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16,
        2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1,
        9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19,
        4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
      ],
      t,
      e
    ),
      (this.type = 'DodecahedronBufferGeometry'),
      (this.parameters = { radius: t, detail: e }));
  }
  function te(t, e, i, n, r, a) {
    (z.call(this),
      (this.type = 'TubeGeometry'),
      (this.parameters = { path: t, tubularSegments: e, radius: i, radialSegments: n, closed: r }),
      void 0 !== a && console.warn('THREE.TubeGeometry: taper has been removed.'));
    const o = new ee(t, e, i, n, r);
    ((this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals),
      this.fromBufferGeometry(o),
      this.mergeVertices());
  }
  function ee(t, e, n, r, o) {
    function s(i) {
      f = t.getPointAt(i / e, f);
      const a = c.normals[i],
        o = c.binormals[i];
      for (l = 0; l <= r; l++) {
        const s = (l / r) * Math.PI * 2,
          h = Math.sin(s),
          d = -Math.cos(s);
        ((p.x = d * a.x + h * o.x),
          (p.y = d * a.y + h * o.y),
          (p.z = d * a.z + h * o.z),
          p.normalize(),
          v.push(p.x, p.y, p.z),
          (u.x = f.x + n * p.x),
          (u.y = f.y + n * p.y),
          (u.z = f.z + n * p.z),
          m.push(u.x, u.y, u.z));
      }
    }
    (K.call(this),
      (this.type = 'TubeBufferGeometry'),
      (this.parameters = { path: t, tubularSegments: e, radius: n, radialSegments: r, closed: o }),
      (e = e || 64),
      (n = n || 1),
      (r = r || 8),
      (o = o || !1));
    var c = t.computeFrenetFrames(e, o);
    ((this.tangents = c.tangents), (this.normals = c.normals), (this.binormals = c.binormals));
    var h,
      l,
      u = new a(),
      p = new a(),
      d = new i(),
      f = new a(),
      m = [],
      v = [],
      g = [],
      y = [];
    (!(function () {
      for (h = 0; h < e; h++) s(h);
      (s(!1 === o ? e : 0),
        (function () {
          for (h = 0; h <= e; h++) for (l = 0; l <= r; l++) ((d.x = h / e), (d.y = l / r), g.push(d.x, d.y));
        })(),
        (function () {
          for (l = 1; l <= e; l++)
            for (h = 1; h <= r; h++) {
              const t = (r + 1) * (l - 1) + (h - 1),
                i = (r + 1) * l + (h - 1),
                n = (r + 1) * l + h,
                a = (r + 1) * (l - 1) + h;
              (y.push(t, i, a), y.push(i, n, a));
            }
        })());
    })(),
      this.setIndex(y),
      this.addAttribute('position', new Y(m, 3)),
      this.addAttribute('normal', new Y(v, 3)),
      this.addAttribute('uv', new Y(g, 2)));
  }
  function ie(t, e, i, n, r, a, o) {
    (z.call(this),
      (this.type = 'TorusKnotGeometry'),
      (this.parameters = { radius: t, tube: e, tubularSegments: i, radialSegments: n, p: r, q: a }),
      void 0 !== o &&
        console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.'),
      this.fromBufferGeometry(new ne(t, e, i, n, r, a)),
      this.mergeVertices());
  }
  function ne(t, e, i, n, r, o) {
    function s(t, e, i, n, r) {
      const a = Math.cos(t),
        o = Math.sin(t),
        s = (i / e) * t,
        c = Math.cos(s);
      ((r.x = n * (2 + c) * 0.5 * a), (r.y = n * (2 + c) * o * 0.5), (r.z = n * Math.sin(s) * 0.5));
    }
    (K.call(this),
      (this.type = 'TorusKnotBufferGeometry'),
      (this.parameters = { radius: t, tube: e, tubularSegments: i, radialSegments: n, p: r, q: o }),
      (t = t || 1),
      (e = e || 0.4),
      (i = Math.floor(i) || 64),
      (n = Math.floor(n) || 8),
      (r = r || 2),
      (o = o || 3));
    let c,
      h,
      l = [],
      u = [],
      p = [],
      d = [],
      f = new a(),
      m = new a(),
      v = new a(),
      g = new a(),
      y = new a(),
      x = new a(),
      b = new a();
    for (c = 0; c <= i; ++c) {
      const _ = (c / i) * r * Math.PI * 2;
      for (
        s(_, r, o, t, v),
          s(_ + 0.01, r, o, t, g),
          x.subVectors(g, v),
          b.addVectors(g, v),
          y.crossVectors(x, b),
          b.crossVectors(y, x),
          y.normalize(),
          b.normalize(),
          h = 0;
        h <= n;
        ++h
      ) {
        const w = (h / n) * Math.PI * 2,
          E = -e * Math.cos(w),
          M = e * Math.sin(w);
        ((f.x = v.x + (E * b.x + M * y.x)),
          (f.y = v.y + (E * b.y + M * y.y)),
          (f.z = v.z + (E * b.z + M * y.z)),
          u.push(f.x, f.y, f.z),
          m.subVectors(f, v).normalize(),
          p.push(m.x, m.y, m.z),
          d.push(c / i),
          d.push(h / n));
      }
    }
    for (h = 1; h <= i; h++)
      for (c = 1; c <= n; c++) {
        const T = (n + 1) * (h - 1) + (c - 1),
          S = (n + 1) * h + (c - 1),
          A = (n + 1) * h + c,
          R = (n + 1) * (h - 1) + c;
        (l.push(T, S, R), l.push(S, A, R));
      }
    (this.setIndex(l),
      this.addAttribute('position', new Y(u, 3)),
      this.addAttribute('normal', new Y(p, 3)),
      this.addAttribute('uv', new Y(d, 2)));
  }
  function re(t, e, i, n, r) {
    (z.call(this),
      (this.type = 'TorusGeometry'),
      (this.parameters = { radius: t, tube: e, radialSegments: i, tubularSegments: n, arc: r }),
      this.fromBufferGeometry(new ae(t, e, i, n, r)),
      this.mergeVertices());
  }
  function ae(t, e, i, n, r) {
    (K.call(this),
      (this.type = 'TorusBufferGeometry'),
      (this.parameters = { radius: t, tube: e, radialSegments: i, tubularSegments: n, arc: r }),
      (t = t || 1),
      (e = e || 0.4),
      (i = Math.floor(i) || 8),
      (n = Math.floor(n) || 6),
      (r = r || 2 * Math.PI));
    let o,
      s,
      c = [],
      h = [],
      l = [],
      u = [],
      p = new a(),
      d = new a(),
      f = new a();
    for (o = 0; o <= i; o++)
      for (s = 0; s <= n; s++) {
        const m = (s / n) * r,
          v = (o / i) * Math.PI * 2;
        ((d.x = (t + e * Math.cos(v)) * Math.cos(m)),
          (d.y = (t + e * Math.cos(v)) * Math.sin(m)),
          (d.z = e * Math.sin(v)),
          h.push(d.x, d.y, d.z),
          (p.x = t * Math.cos(m)),
          (p.y = t * Math.sin(m)),
          f.subVectors(d, p).normalize(),
          l.push(f.x, f.y, f.z),
          u.push(s / n),
          u.push(o / i));
      }
    for (o = 1; o <= i; o++)
      for (s = 1; s <= n; s++) {
        const g = (n + 1) * o + s - 1,
          y = (n + 1) * (o - 1) + s - 1,
          x = (n + 1) * (o - 1) + s,
          b = (n + 1) * o + s;
        (c.push(g, y, b), c.push(y, x, b));
      }
    (this.setIndex(c),
      this.addAttribute('position', new Y(h, 3)),
      this.addAttribute('normal', new Y(l, 3)),
      this.addAttribute('uv', new Y(u, 2)));
  }
  function oe(t, e, i, n, r) {
    let a, o;
    if (
      r ===
      (function (t, e, i, n) {
        for (var r = 0, a = e, o = i - n; a < i; a += n) ((r += (t[o] - t[a]) * (t[a + 1] + t[o + 1])), (o = a));
        return r;
      })(t, e, i, n) >
        0
    )
      for (a = e; a < i; a += n) o = ve(a, t[a], t[a + 1], o);
    else for (a = i - n; a >= e; a -= n) o = ve(a, t[a], t[a + 1], o);
    return (o && pe(o, o.next) && (ge(o), (o = o.next)), o);
  }
  function se(t, e) {
    if (!t) return t;
    e || (e = t);
    let i,
      n = t;
    do {
      if (((i = !1), n.steiner || (!pe(n, n.next) && 0 !== ue(n.prev, n, n.next)))) n = n.next;
      else {
        if ((ge(n), (n = e = n.prev) === n.next)) break;
        i = !0;
      }
    } while (i || n !== e);
    return e;
  }
  function ce(t, e, i, n, r, a, o) {
    if (t) {
      !o &&
        a &&
        (function (t, e, i, n) {
          let r = t;
          do {
            (null === r.z && (r.z = he(r.x, r.y, e, i, n)), (r.prevZ = r.prev), (r.nextZ = r.next), (r = r.next));
          } while (r !== t);
          ((r.prevZ.nextZ = null),
            (r.prevZ = null),
            (function (t) {
              let e,
                i,
                n,
                r,
                a,
                o,
                s,
                c,
                h = 1;
              do {
                for (i = t, t = null, a = null, o = 0; i; ) {
                  for (o++, n = i, s = 0, e = 0; e < h && (s++, (n = n.nextZ)); e++);
                  for (c = h; s > 0 || (c > 0 && n); )
                    (0 !== s && (0 === c || !n || i.z <= n.z)
                      ? ((r = i), (i = i.nextZ), s--)
                      : ((r = n), (n = n.nextZ), c--),
                      a ? (a.nextZ = r) : (t = r),
                      (r.prevZ = a),
                      (a = r));
                  i = n;
                }
                ((a.nextZ = null), (h *= 2));
              } while (o > 1);
            })(r));
        })(t, n, r, a);
      for (var s, c, h = t; t.prev !== t.next; )
        if (
          ((s = t.prev),
          (c = t.next),
          a
            ? (function (t, e, i, n) {
                const r = t.prev,
                  a = t,
                  o = t.next;
                if (ue(r, a, o) >= 0) return !1;
                let s = r.x < a.x ? (r.x < o.x ? r.x : o.x) : a.x < o.x ? a.x : o.x,
                  c = r.y < a.y ? (r.y < o.y ? r.y : o.y) : a.y < o.y ? a.y : o.y,
                  h = r.x > a.x ? (r.x > o.x ? r.x : o.x) : a.x > o.x ? a.x : o.x,
                  l = r.y > a.y ? (r.y > o.y ? r.y : o.y) : a.y > o.y ? a.y : o.y,
                  u = he(s, c, e, i, n),
                  p = he(h, l, e, i, n),
                  d = t.nextZ;
                for (; d && d.z <= p; ) {
                  if (
                    d !== t.prev &&
                    d !== t.next &&
                    le(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) &&
                    ue(d.prev, d, d.next) >= 0
                  )
                    return !1;
                  d = d.nextZ;
                }
                d = t.prevZ;
                for (; d && d.z >= u; ) {
                  if (
                    d !== t.prev &&
                    d !== t.next &&
                    le(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) &&
                    ue(d.prev, d, d.next) >= 0
                  )
                    return !1;
                  d = d.prevZ;
                }
                return !0;
              })(t, n, r, a)
            : (function (t) {
                const e = t.prev,
                  i = t,
                  n = t.next;
                if (ue(e, i, n) >= 0) return !1;
                let r = t.next.next;
                for (; r !== t.prev; ) {
                  if (le(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) && ue(r.prev, r, r.next) >= 0) return !1;
                  r = r.next;
                }
                return !0;
              })(t))
        )
          (e.push(s.i / i), e.push(t.i / i), e.push(c.i / i), ge(t), (t = c.next), (h = c.next));
        else if ((t = c) === h) {
          o
            ? 1 === o
              ? ce(
                  (t = (function (t, e, i) {
                    let n = t;
                    do {
                      const r = n.prev,
                        a = n.next.next;
                      (!pe(r, a) &&
                        de(r, n, n.next, a) &&
                        fe(r, a) &&
                        fe(a, r) &&
                        (e.push(r.i / i), e.push(n.i / i), e.push(a.i / i), ge(n), ge(n.next), (n = t = a)),
                        (n = n.next));
                    } while (n !== t);
                    return n;
                  })(t, e, i)),
                  e,
                  i,
                  n,
                  r,
                  a,
                  2
                )
              : 2 === o &&
                (function (t, e, i, n, r, a) {
                  let o = t;
                  do {
                    for (let s = o.next.next; s !== o.prev; ) {
                      if (
                        o.i !== s.i &&
                        (function (t, e) {
                          return (
                            t.next.i !== e.i &&
                            t.prev.i !== e.i &&
                            !(function (t, e) {
                              let i = t;
                              do {
                                if (
                                  i.i !== t.i &&
                                  i.next.i !== t.i &&
                                  i.i !== e.i &&
                                  i.next.i !== e.i &&
                                  de(i, i.next, t, e)
                                )
                                  return !0;
                                i = i.next;
                              } while (i !== t);
                              return !1;
                            })(t, e) &&
                            fe(t, e) &&
                            fe(e, t) &&
                            (function (t, e) {
                              let i = t,
                                n = !1,
                                r = (t.x + e.x) / 2,
                                a = (t.y + e.y) / 2;
                              do {
                                (i.y > a != i.next.y > a &&
                                  i.next.y !== i.y &&
                                  r < ((i.next.x - i.x) * (a - i.y)) / (i.next.y - i.y) + i.x &&
                                  (n = !n),
                                  (i = i.next));
                              } while (i !== t);
                              return n;
                            })(t, e)
                          );
                        })(o, s)
                      ) {
                        let c = me(o, s);
                        return (
                          (o = se(o, o.next)),
                          (c = se(c, c.next)),
                          ce(o, e, i, n, r, a),
                          void ce(c, e, i, n, r, a)
                        );
                      }
                      s = s.next;
                    }
                    o = o.next;
                  } while (o !== t);
                })(t, e, i, n, r, a)
            : ce(se(t), e, i, n, r, a, 1);
          break;
        }
    }
  }
  function he(t, e, i, n, r) {
    return (
      (t = 32767 * (t - i) * r),
      (e = 32767 * (e - n) * r),
      (t = 16711935 & (t | (t << 8))),
      (t = 252645135 & (t | (t << 4))),
      (t = 858993459 & (t | (t << 2))),
      (t = 1431655765 & (t | (t << 1))),
      (e = 16711935 & (e | (e << 8))),
      (e = 252645135 & (e | (e << 4))),
      (e = 858993459 & (e | (e << 2))),
      (e = 1431655765 & (e | (e << 1))),
      t | (e << 1)
    );
  }
  function le(t, e, i, n, r, a, o, s) {
    return (
      (r - o) * (e - s) - (t - o) * (a - s) >= 0 &&
      (t - o) * (n - s) - (i - o) * (e - s) >= 0 &&
      (i - o) * (a - s) - (r - o) * (n - s) >= 0
    );
  }
  function ue(t, e, i) {
    return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
  }
  function pe(t, e) {
    return t.x === e.x && t.y === e.y;
  }
  function de(t, e, i, n) {
    return (
      !!((pe(t, e) && pe(i, n)) || (pe(t, n) && pe(i, e))) ||
      (ue(t, e, i) > 0 != ue(t, e, n) > 0 && ue(i, n, t) > 0 != ue(i, n, e) > 0)
    );
  }
  function fe(t, e) {
    return ue(t.prev, t, t.next) < 0
      ? ue(t, e, t.next) >= 0 && ue(t, t.prev, e) >= 0
      : ue(t, e, t.prev) < 0 || ue(t, t.next, e) < 0;
  }
  function me(t, e) {
    const i = new ye(t.i, t.x, t.y),
      n = new ye(e.i, e.x, e.y),
      r = t.next,
      a = e.prev;
    return (
      (t.next = e),
      (e.prev = t),
      (i.next = r),
      (r.prev = i),
      (n.next = i),
      (i.prev = n),
      (a.next = n),
      (n.prev = a),
      n
    );
  }
  function ve(t, e, i, n) {
    const r = new ye(t, e, i);
    return (n ? ((r.next = n.next), (r.prev = n), (n.next.prev = r), (n.next = r)) : ((r.prev = r), (r.next = r)), r);
  }
  function ge(t) {
    ((t.next.prev = t.prev),
      (t.prev.next = t.next),
      t.prevZ && (t.prevZ.nextZ = t.nextZ),
      t.nextZ && (t.nextZ.prevZ = t.prevZ));
  }
  function ye(t, e, i) {
    ((this.i = t),
      (this.x = e),
      (this.y = i),
      (this.prev = null),
      (this.next = null),
      (this.z = null),
      (this.prevZ = null),
      (this.nextZ = null),
      (this.steiner = !1));
  }
  function xe(t, e) {
    (z.call(this),
      (this.type = 'ExtrudeGeometry'),
      (this.parameters = { shapes: t, options: e }),
      this.fromBufferGeometry(new be(t, e)),
      this.mergeVertices());
  }
  function be(t, e) {
    void 0 !== t &&
      (K.call(this),
      (this.type = 'ExtrudeBufferGeometry'),
      (t = Array.isArray(t) ? t : [t]),
      this.addShapeList(t, e),
      this.computeVertexNormals());
  }
  function _e(t, e) {
    (z.call(this),
      (this.type = 'TextGeometry'),
      (this.parameters = { text: t, parameters: e }),
      this.fromBufferGeometry(new we(t, e)),
      this.mergeVertices());
  }
  function we(t, e) {
    const i = (e = e || {}).font;
    if (!i || !i.isFont)
      return (console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.'), new z());
    const n = i.generateShapes(t, e.size, e.curveSegments);
    ((e.amount = void 0 !== e.height ? e.height : 50),
      void 0 === e.bevelThickness && (e.bevelThickness = 10),
      void 0 === e.bevelSize && (e.bevelSize = 8),
      void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
      be.call(this, n, e),
      (this.type = 'TextBufferGeometry'));
  }
  function Ee(t, e, i, n, r, a, o) {
    (z.call(this),
      (this.type = 'SphereGeometry'),
      (this.parameters = {
        radius: t,
        widthSegments: e,
        heightSegments: i,
        phiStart: n,
        phiLength: r,
        thetaStart: a,
        thetaLength: o,
      }),
      this.fromBufferGeometry(new Me(t, e, i, n, r, a, o)),
      this.mergeVertices());
  }
  function Me(t, e, i, n, r, o, s) {
    (K.call(this),
      (this.type = 'SphereBufferGeometry'),
      (this.parameters = {
        radius: t,
        widthSegments: e,
        heightSegments: i,
        phiStart: n,
        phiLength: r,
        thetaStart: o,
        thetaLength: s,
      }),
      (t = t || 1),
      (e = Math.max(3, Math.floor(e) || 8)),
      (i = Math.max(2, Math.floor(i) || 6)),
      (n = void 0 !== n ? n : 0),
      (r = void 0 !== r ? r : 2 * Math.PI));
    let c,
      h,
      l = (o = void 0 !== o ? o : 0) + (s = void 0 !== s ? s : Math.PI),
      u = 0,
      p = [],
      d = new a(),
      f = new a(),
      m = [],
      v = [],
      g = [],
      y = [];
    for (h = 0; h <= i; h++) {
      const x = [],
        b = h / i;
      for (c = 0; c <= e; c++) {
        const _ = c / e;
        ((d.x = -t * Math.cos(n + _ * r) * Math.sin(o + b * s)),
          (d.y = t * Math.cos(o + b * s)),
          (d.z = t * Math.sin(n + _ * r) * Math.sin(o + b * s)),
          v.push(d.x, d.y, d.z),
          f.set(d.x, d.y, d.z).normalize(),
          g.push(f.x, f.y, f.z),
          y.push(_, 1 - b),
          x.push(u++));
      }
      p.push(x);
    }
    for (h = 0; h < i; h++)
      for (c = 0; c < e; c++) {
        const w = p[h][c + 1],
          E = p[h][c],
          M = p[h + 1][c],
          T = p[h + 1][c + 1];
        ((0 !== h || o > 0) && m.push(w, E, T), (h !== i - 1 || l < Math.PI) && m.push(E, M, T));
      }
    (this.setIndex(m),
      this.addAttribute('position', new Y(v, 3)),
      this.addAttribute('normal', new Y(g, 3)),
      this.addAttribute('uv', new Y(y, 2)));
  }
  function Te(t, e, i, n, r, a) {
    (z.call(this),
      (this.type = 'RingGeometry'),
      (this.parameters = {
        innerRadius: t,
        outerRadius: e,
        thetaSegments: i,
        phiSegments: n,
        thetaStart: r,
        thetaLength: a,
      }),
      this.fromBufferGeometry(new Se(t, e, i, n, r, a)),
      this.mergeVertices());
  }
  function Se(t, e, n, r, o, s) {
    (K.call(this),
      (this.type = 'RingBufferGeometry'),
      (this.parameters = {
        innerRadius: t,
        outerRadius: e,
        thetaSegments: n,
        phiSegments: r,
        thetaStart: o,
        thetaLength: s,
      }),
      (t = t || 0.5),
      (e = e || 1),
      (o = void 0 !== o ? o : 0),
      (s = void 0 !== s ? s : 2 * Math.PI),
      (n = void 0 !== n ? Math.max(3, n) : 8));
    let c,
      h,
      l,
      u = [],
      p = [],
      d = [],
      f = [],
      m = t,
      v = (e - t) / (r = void 0 !== r ? Math.max(1, r) : 1),
      g = new a(),
      y = new i();
    for (h = 0; h <= r; h++) {
      for (l = 0; l <= n; l++)
        ((c = o + (l / n) * s),
          (g.x = m * Math.cos(c)),
          (g.y = m * Math.sin(c)),
          p.push(g.x, g.y, g.z),
          d.push(0, 0, 1),
          (y.x = (g.x / e + 1) / 2),
          (y.y = (g.y / e + 1) / 2),
          f.push(y.x, y.y));
      m += v;
    }
    for (h = 0; h < r; h++) {
      const x = h * (n + 1);
      for (l = 0; l < n; l++) {
        const b = (c = l + x),
          _ = c + n + 1,
          w = c + n + 2,
          E = c + 1;
        (u.push(b, _, E), u.push(_, w, E));
      }
    }
    (this.setIndex(u),
      this.addAttribute('position', new Y(p, 3)),
      this.addAttribute('normal', new Y(d, 3)),
      this.addAttribute('uv', new Y(f, 2)));
  }
  function Ae(t, e, i, n) {
    (z.call(this),
      (this.type = 'LatheGeometry'),
      (this.parameters = { points: t, segments: e, phiStart: i, phiLength: n }),
      this.fromBufferGeometry(new Re(t, e, i, n)),
      this.mergeVertices());
  }
  function Re(t, e, n, r) {
    (K.call(this),
      (this.type = 'LatheBufferGeometry'),
      (this.parameters = { points: t, segments: e, phiStart: n, phiLength: r }),
      (e = Math.floor(e) || 12),
      (n = n || 0),
      (r = r || 2 * Math.PI),
      (r = Wa.clamp(r, 0, 2 * Math.PI)));
    let o,
      s,
      c,
      h = [],
      l = [],
      u = [],
      p = 1 / e,
      d = new a(),
      f = new i();
    for (s = 0; s <= e; s++) {
      const m = n + s * p * r,
        v = Math.sin(m),
        g = Math.cos(m);
      for (c = 0; c <= t.length - 1; c++)
        ((d.x = t[c].x * v),
          (d.y = t[c].y),
          (d.z = t[c].x * g),
          l.push(d.x, d.y, d.z),
          (f.x = s / e),
          (f.y = c / (t.length - 1)),
          u.push(f.x, f.y));
    }
    for (s = 0; s < e; s++)
      for (c = 0; c < t.length - 1; c++) {
        const y = (o = c + s * t.length),
          x = o + t.length,
          b = o + t.length + 1,
          _ = o + 1;
        (h.push(y, x, _), h.push(x, b, _));
      }
    if (
      (this.setIndex(h),
      this.addAttribute('position', new Y(l, 3)),
      this.addAttribute('uv', new Y(u, 2)),
      this.computeVertexNormals(),
      r === 2 * Math.PI)
    ) {
      const w = this.attributes.normal.array,
        E = new a(),
        M = new a(),
        T = new a();
      for (o = e * t.length * 3, s = 0, c = 0; s < t.length; s++, c += 3)
        ((E.x = w[c + 0]),
          (E.y = w[c + 1]),
          (E.z = w[c + 2]),
          (M.x = w[o + c + 0]),
          (M.y = w[o + c + 1]),
          (M.z = w[o + c + 2]),
          T.addVectors(E, M).normalize(),
          (w[c + 0] = w[o + c + 0] = T.x),
          (w[c + 1] = w[o + c + 1] = T.y),
          (w[c + 2] = w[o + c + 2] = T.z));
    }
  }
  function Le(t, e) {
    (z.call(this),
      (this.type = 'ShapeGeometry'),
      'object' == typeof e &&
        (console.warn('THREE.ShapeGeometry: Options parameter has been removed.'), (e = e.curveSegments)),
      (this.parameters = { shapes: t, curveSegments: e }),
      this.fromBufferGeometry(new Pe(t, e)),
      this.mergeVertices());
  }
  function Pe(t, e) {
    function i(t) {
      let i,
        s,
        h,
        l = r.length / 3,
        u = t.extractPoints(e),
        p = u.shape,
        d = u.holes;
      if (!1 === uo.isClockWise(p))
        for (p = p.reverse(), i = 0, s = d.length; i < s; i++)
          ((h = d[i]), !0 === uo.isClockWise(h) && (d[i] = h.reverse()));
      const f = uo.triangulateShape(p, d);
      for (i = 0, s = d.length; i < s; i++) ((h = d[i]), (p = p.concat(h)));
      for (i = 0, s = p.length; i < s; i++) {
        const m = p[i];
        (r.push(m.x, m.y, 0), a.push(0, 0, 1), o.push(m.x, m.y));
      }
      for (i = 0, s = f.length; i < s; i++) {
        const v = f[i],
          g = v[0] + l,
          y = v[1] + l,
          x = v[2] + l;
        (n.push(g, y, x), (c += 3));
      }
    }
    (K.call(this),
      (this.type = 'ShapeBufferGeometry'),
      (this.parameters = { shapes: t, curveSegments: e }),
      (e = e || 12));
    var n = [],
      r = [],
      a = [],
      o = [],
      s = 0,
      c = 0;
    if (!1 === Array.isArray(t)) i(t);
    else for (let h = 0; h < t.length; h++) (i(t[h]), this.addGroup(s, c, h), (s += c), (c = 0));
    (this.setIndex(n),
      this.addAttribute('position', new Y(r, 3)),
      this.addAttribute('normal', new Y(a, 3)),
      this.addAttribute('uv', new Y(o, 2)));
  }
  function Ce(t, e) {
    (K.call(this),
      (this.type = 'EdgesGeometry'),
      (this.parameters = { thresholdAngle: e }),
      (e = void 0 !== e ? e : 1));
    let i,
      n,
      r,
      a,
      o = [],
      s = Math.cos(Wa.DEG2RAD * e),
      c = [0, 0],
      h = {},
      l = ['a', 'b', 'c'];
    (t.isBufferGeometry ? (a = new z()).fromBufferGeometry(t) : (a = t.clone()),
      a.mergeVertices(),
      a.computeFaceNormals());
    for (var u = a.vertices, p = a.faces, d = 0, f = p.length; d < f; d++)
      for (let m = p[d], v = 0; v < 3; v++)
        ((i = m[l[v]]),
          (n = m[l[(v + 1) % 3]]),
          (c[0] = Math.min(i, n)),
          (c[1] = Math.max(i, n)),
          void 0 === h[(r = c[0] + ',' + c[1])]
            ? (h[r] = { index1: c[0], index2: c[1], face1: d, face2: void 0 })
            : (h[r].face2 = d));
    for (r in h) {
      const g = h[r];
      if (void 0 === g.face2 || p[g.face1].normal.dot(p[g.face2].normal) <= s) {
        let y = u[g.index1];
        (o.push(y.x, y.y, y.z), (y = u[g.index2]), o.push(y.x, y.y, y.z));
      }
    }
    this.addAttribute('position', new Y(o, 3));
  }
  function Ie(t, e, i, n, r, a, o, s) {
    (z.call(this),
      (this.type = 'CylinderGeometry'),
      (this.parameters = {
        radiusTop: t,
        radiusBottom: e,
        height: i,
        radialSegments: n,
        heightSegments: r,
        openEnded: a,
        thetaStart: o,
        thetaLength: s,
      }),
      this.fromBufferGeometry(new De(t, e, i, n, r, a, o, s)),
      this.mergeVertices());
  }
  function De(t, e, n, r, o, s, c, h) {
    function l(n) {
      let o,
        s,
        l,
        g = new i(),
        b = new a(),
        _ = 0,
        w = !0 === n ? t : e,
        E = !0 === n ? 1 : -1;
      for (s = v, o = 1; o <= r; o++) (d.push(0, y * E, 0), f.push(0, E, 0), m.push(0.5, 0.5), v++);
      for (l = v, o = 0; o <= r; o++) {
        const M = (o / r) * h + c,
          T = Math.cos(M),
          S = Math.sin(M);
        ((b.x = w * S),
          (b.y = y * E),
          (b.z = w * T),
          d.push(b.x, b.y, b.z),
          f.push(0, E, 0),
          (g.x = 0.5 * T + 0.5),
          (g.y = 0.5 * S * E + 0.5),
          m.push(g.x, g.y),
          v++);
      }
      for (o = 0; o < r; o++) {
        const A = s + o,
          R = l + o;
        (!0 === n ? p.push(R, R + 1, A) : p.push(R + 1, R, A), (_ += 3));
      }
      (u.addGroup(x, _, !0 === n ? 1 : 2), (x += _));
    }
    (K.call(this),
      (this.type = 'CylinderBufferGeometry'),
      (this.parameters = {
        radiusTop: t,
        radiusBottom: e,
        height: n,
        radialSegments: r,
        heightSegments: o,
        openEnded: s,
        thetaStart: c,
        thetaLength: h,
      }));
    var u = this;
    ((t = void 0 !== t ? t : 1),
      (e = void 0 !== e ? e : 1),
      (n = n || 1),
      (r = Math.floor(r) || 8),
      (o = Math.floor(o) || 1),
      (s = void 0 !== s && s),
      (c = void 0 !== c ? c : 0),
      (h = void 0 !== h ? h : 2 * Math.PI));
    var p = [],
      d = [],
      f = [],
      m = [],
      v = 0,
      g = [],
      y = n / 2,
      x = 0;
    (!(function () {
      let i,
        s,
        l = new a(),
        b = new a(),
        _ = 0,
        w = (e - t) / n;
      for (s = 0; s <= o; s++) {
        const E = [],
          M = s / o,
          T = M * (e - t) + t;
        for (i = 0; i <= r; i++) {
          const S = i / r,
            A = S * h + c,
            R = Math.sin(A),
            L = Math.cos(A);
          ((b.x = T * R),
            (b.y = -M * n + y),
            (b.z = T * L),
            d.push(b.x, b.y, b.z),
            l.set(R, w, L).normalize(),
            f.push(l.x, l.y, l.z),
            m.push(S, 1 - M),
            E.push(v++));
        }
        g.push(E);
      }
      for (i = 0; i < r; i++)
        for (s = 0; s < o; s++) {
          const P = g[s][i],
            C = g[s + 1][i],
            I = g[s + 1][i + 1],
            D = g[s][i + 1];
          (p.push(P, C, D), p.push(C, I, D), (_ += 6));
        }
      (u.addGroup(x, _, 0), (x += _));
    })(),
      !1 === s && (t > 0 && l(!0), e > 0 && l(!1)),
      this.setIndex(p),
      this.addAttribute('position', new Y(d, 3)),
      this.addAttribute('normal', new Y(f, 3)),
      this.addAttribute('uv', new Y(m, 2)));
  }
  function Oe(t, e, i, n, r, a, o) {
    (Ie.call(this, 0, t, e, i, n, r, a, o),
      (this.type = 'ConeGeometry'),
      (this.parameters = {
        radius: t,
        height: e,
        radialSegments: i,
        heightSegments: n,
        openEnded: r,
        thetaStart: a,
        thetaLength: o,
      }));
  }
  function Ue(t, e, i, n, r, a, o) {
    (De.call(this, 0, t, e, i, n, r, a, o),
      (this.type = 'ConeBufferGeometry'),
      (this.parameters = {
        radius: t,
        height: e,
        radialSegments: i,
        heightSegments: n,
        openEnded: r,
        thetaStart: a,
        thetaLength: o,
      }));
  }
  function Ne(t, e, i, n) {
    (z.call(this),
      (this.type = 'CircleGeometry'),
      (this.parameters = { radius: t, segments: e, thetaStart: i, thetaLength: n }),
      this.fromBufferGeometry(new Be(t, e, i, n)),
      this.mergeVertices());
  }
  function Be(t, e, n, r) {
    (K.call(this),
      (this.type = 'CircleBufferGeometry'),
      (this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: r }),
      (t = t || 1),
      (e = void 0 !== e ? Math.max(3, e) : 8),
      (n = void 0 !== n ? n : 0),
      (r = void 0 !== r ? r : 2 * Math.PI));
    let o,
      s,
      c = [],
      h = [],
      l = [],
      u = [],
      p = new a(),
      d = new i();
    for (h.push(0, 0, 0), l.push(0, 0, 1), u.push(0.5, 0.5), s = 0, o = 3; s <= e; s++, o += 3) {
      const f = n + (s / e) * r;
      ((p.x = t * Math.cos(f)),
        (p.y = t * Math.sin(f)),
        h.push(p.x, p.y, p.z),
        l.push(0, 0, 1),
        (d.x = (h[o] / t + 1) / 2),
        (d.y = (h[o + 1] / t + 1) / 2),
        u.push(d.x, d.y));
    }
    for (o = 1; o <= e; o++) c.push(o, o + 1, 0);
    (this.setIndex(c),
      this.addAttribute('position', new Y(h, 3)),
      this.addAttribute('normal', new Y(l, 3)),
      this.addAttribute('uv', new Y(u, 2)));
  }
  function Fe(t) {
    (T.call(this),
      (this.type = 'ShadowMaterial'),
      (this.color = new w(0)),
      (this.opacity = 1),
      (this.lights = !0),
      (this.transparent = !0),
      this.setValues(t));
  }
  function ze(t) {
    (rt.call(this, t), (this.type = 'RawShaderMaterial'));
  }
  function Ge(t) {
    (T.call(this),
      (this.defines = { STANDARD: '' }),
      (this.type = 'MeshStandardMaterial'),
      (this.color = new w(16777215)),
      (this.roughness = 0.5),
      (this.metalness = 0.5),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new w(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalScale = new i(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(t));
  }
  function He(t) {
    (Ge.call(this),
      (this.defines = { PHYSICAL: '' }),
      (this.type = 'MeshPhysicalMaterial'),
      (this.reflectivity = 0.5),
      (this.clearCoat = 0),
      (this.clearCoatRoughness = 0),
      this.setValues(t));
  }
  function Ve(t) {
    (T.call(this),
      (this.type = 'MeshPhongMaterial'),
      (this.color = new w(16777215)),
      (this.specular = new w(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new w(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalScale = new i(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = Ir),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(t));
  }
  function ke(t) {
    (Ve.call(this),
      (this.defines = { TOON: '' }),
      (this.type = 'MeshToonMaterial'),
      (this.gradientMap = null),
      this.setValues(t));
  }
  function je(t) {
    (T.call(this),
      (this.type = 'MeshNormalMaterial'),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalScale = new i(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(t));
  }
  function We(t) {
    (T.call(this),
      (this.type = 'MeshLambertMaterial'),
      (this.color = new w(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new w(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = Ir),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(t));
  }
  function Xe(t) {
    (Ct.call(this),
      (this.type = 'LineDashedMaterial'),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(t));
  }
  function qe(t, e, i) {
    let n = this,
      r = !1,
      a = 0,
      o = 0,
      s = void 0;
    ((this.onStart = void 0),
      (this.onLoad = t),
      (this.onProgress = e),
      (this.onError = i),
      (this.itemStart = function (t) {
        (o++, !1 === r && void 0 !== n.onStart && n.onStart(t, a, o), (r = !0));
      }),
      (this.itemEnd = function (t) {
        (a++,
          void 0 !== n.onProgress && n.onProgress(t, a, o),
          a === o && ((r = !1), void 0 !== n.onLoad && n.onLoad()));
      }),
      (this.itemError = function (t) {
        void 0 !== n.onError && n.onError(t);
      }),
      (this.resolveURL = function (t) {
        return s ? s(t) : t;
      }),
      (this.setURLModifier = function (t) {
        s = t;
      }));
  }
  function Ye(t) {
    this.manager = void 0 !== t ? t : vo;
  }
  function Ze(t) {
    ((this.manager = void 0 !== t ? t : vo), (this._parser = null));
  }
  function Qe(t) {
    ((this.manager = void 0 !== t ? t : vo), (this._parser = null));
  }
  function Je(t) {
    this.manager = void 0 !== t ? t : vo;
  }
  function Ke(t) {
    this.manager = void 0 !== t ? t : vo;
  }
  function $e(t) {
    this.manager = void 0 !== t ? t : vo;
  }
  function ti(t, e) {
    (U.call(this),
      (this.type = 'Light'),
      (this.color = new w(t)),
      (this.intensity = void 0 !== e ? e : 1),
      (this.receiveShadow = void 0));
  }
  function ei(t, e, i) {
    (ti.call(this, t, i),
      (this.type = 'HemisphereLight'),
      (this.castShadow = void 0),
      this.position.copy(U.DefaultUp),
      this.updateMatrix(),
      (this.groundColor = new w(e)));
  }
  function ii(t) {
    ((this.camera = t),
      (this.bias = 0),
      (this.radius = 1),
      (this.mapSize = new i(512, 512)),
      (this.map = null),
      (this.matrix = new n()));
  }
  function ni() {
    ii.call(this, new vt(50, 1, 0.5, 500));
  }
  function ri(t, e, i, n, r, a) {
    (ti.call(this, t, e),
      (this.type = 'SpotLight'),
      this.position.copy(U.DefaultUp),
      this.updateMatrix(),
      (this.target = new U()),
      Object.defineProperty(this, 'power', {
        get: function () {
          return this.intensity * Math.PI;
        },
        set: function (t) {
          this.intensity = t / Math.PI;
        },
      }),
      (this.distance = void 0 !== i ? i : 0),
      (this.angle = void 0 !== n ? n : Math.PI / 3),
      (this.penumbra = void 0 !== r ? r : 0),
      (this.decay = void 0 !== a ? a : 1),
      (this.shadow = new ni()));
  }
  function ai(t, e, i, n) {
    (ti.call(this, t, e),
      (this.type = 'PointLight'),
      Object.defineProperty(this, 'power', {
        get: function () {
          return 4 * this.intensity * Math.PI;
        },
        set: function (t) {
          this.intensity = t / (4 * Math.PI);
        },
      }),
      (this.distance = void 0 !== i ? i : 0),
      (this.decay = void 0 !== n ? n : 1),
      (this.shadow = new ii(new vt(90, 1, 0.5, 500))));
  }
  function oi() {
    ii.call(this, new B(-5, 5, 5, -5, 0.5, 500));
  }
  function si(t, e) {
    (ti.call(this, t, e),
      (this.type = 'DirectionalLight'),
      this.position.copy(U.DefaultUp),
      this.updateMatrix(),
      (this.target = new U()),
      (this.shadow = new oi()));
  }
  function ci(t, e) {
    (ti.call(this, t, e), (this.type = 'AmbientLight'), (this.castShadow = void 0));
  }
  function hi(t, e, i, n) {
    (ti.call(this, t, e),
      (this.type = 'RectAreaLight'),
      this.position.set(0, 1, 0),
      this.updateMatrix(),
      (this.width = void 0 !== i ? i : 10),
      (this.height = void 0 !== n ? n : 10));
  }
  function li(t, e, i, n) {
    bi.call(this, t, e, i, n);
  }
  function ui(t, e, i) {
    bi.call(this, t, e, i);
  }
  function pi(t, e, i, n) {
    ((this.parameterPositions = t),
      (this._cachedIndex = 0),
      (this.resultBuffer = void 0 !== n ? n : new e.constructor(i)),
      (this.sampleValues = e),
      (this.valueSize = i));
  }
  function di(t, e, i, n) {
    pi.call(this, t, e, i, n);
  }
  function fi(t, e, i, n) {
    bi.call(this, t, e, i, n);
  }
  function mi(t, e, i, n) {
    bi.call(this, t, e, i, n);
  }
  function vi(t, e, i, n) {
    bi.call(this, t, e, i, n);
  }
  function gi(t, e, i, n) {
    (pi.call(this, t, e, i, n),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0));
  }
  function yi(t, e, i, n) {
    pi.call(this, t, e, i, n);
  }
  function xi(t, e, i, n) {
    pi.call(this, t, e, i, n);
  }
  function bi(t, e, i, n) {
    if (void 0 === t) throw new Error('THREE.KeyframeTrack: track name is undefined');
    if (void 0 === e || 0 === e.length) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + t);
    ((this.name = t),
      (this.times = yo.convertArray(e, this.TimeBufferType)),
      (this.values = yo.convertArray(i, this.ValueBufferType)),
      this.setInterpolation(n || this.DefaultInterpolation),
      this.validate(),
      this.optimize());
  }
  function _i(t, e, i, n) {
    bi.call(this, t, e, i, n);
  }
  function wi(t, e, i) {
    ((this.name = t),
      (this.tracks = i),
      (this.duration = void 0 !== e ? e : -1),
      (this.uuid = Wa.generateUUID()),
      this.duration < 0 && this.resetDuration(),
      this.optimize());
  }
  function Ei(t) {
    ((this.manager = void 0 !== t ? t : vo), (this.textures = {}));
  }
  function Mi(t) {
    this.manager = void 0 !== t ? t : vo;
  }
  function Ti() {
    ((this.onLoadStart = function () {}),
      (this.onLoadProgress = function () {}),
      (this.onLoadComplete = function () {}));
  }
  function Si(t) {
    ('boolean' == typeof t &&
      (console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.'), (t = void 0)),
      (this.manager = void 0 !== t ? t : vo),
      (this.withCredentials = !1));
  }
  function Ai(t) {
    ((this.manager = void 0 !== t ? t : vo), (this.texturePath = ''));
  }
  function Ri(t) {
    ('undefined' == typeof createImageBitmap &&
      console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.'),
      'undefined' == typeof fetch && console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
      (this.manager = void 0 !== t ? t : vo),
      (this.options = void 0));
  }
  function Li(t, e, i, n, r) {
    const a = 0.5 * (n - e),
      o = 0.5 * (r - i),
      s = t * t;
    return (2 * i - 2 * n + a + o) * (t * s) + (-3 * i + 3 * n - 2 * a - o) * s + a * t + i;
  }
  function Pi(t, e, i, n) {
    return (
      (function (t, e) {
        const i = 1 - t;
        return i * i * e;
      })(t, e) +
      (function (t, e) {
        return 2 * (1 - t) * t * e;
      })(t, i) +
      (function (t, e) {
        return t * t * e;
      })(t, n)
    );
  }
  function Ci(t, e, i, n, r) {
    return (
      (function (t, e) {
        const i = 1 - t;
        return i * i * i * e;
      })(t, e) +
      (function (t, e) {
        const i = 1 - t;
        return 3 * i * i * t * e;
      })(t, i) +
      (function (t, e) {
        return 3 * (1 - t) * t * t * e;
      })(t, n) +
      (function (t, e) {
        return t * t * t * e;
      })(t, r)
    );
  }
  function Ii() {
    ((this.type = 'Curve'), (this.arcLengthDivisions = 200));
  }
  function Di(t, e) {
    (Ii.call(this), (this.type = 'LineCurve'), (this.v1 = t || new i()), (this.v2 = e || new i()));
  }
  function Oi() {
    (Ii.call(this), (this.type = 'CurvePath'), (this.curves = []), (this.autoClose = !1));
  }
  function Ui(t, e, i, n, r, a, o, s) {
    (Ii.call(this),
      (this.type = 'EllipseCurve'),
      (this.aX = t || 0),
      (this.aY = e || 0),
      (this.xRadius = i || 1),
      (this.yRadius = n || 1),
      (this.aStartAngle = r || 0),
      (this.aEndAngle = a || 2 * Math.PI),
      (this.aClockwise = o || !1),
      (this.aRotation = s || 0));
  }
  function Ni(t) {
    (Ii.call(this), (this.type = 'SplineCurve'), (this.points = t || []));
  }
  function Bi(t, e, n, r) {
    (Ii.call(this),
      (this.type = 'CubicBezierCurve'),
      (this.v0 = t || new i()),
      (this.v1 = e || new i()),
      (this.v2 = n || new i()),
      (this.v3 = r || new i()));
  }
  function Fi(t, e, n) {
    (Ii.call(this),
      (this.type = 'QuadraticBezierCurve'),
      (this.v0 = t || new i()),
      (this.v1 = e || new i()),
      (this.v2 = n || new i()));
  }
  function zi(t) {
    (Oi.call(this), (this.type = 'Path'), (this.currentPoint = new i()), t && this.setFromPoints(t));
  }
  function Gi(t) {
    (zi.call(this, t), (this.type = 'Shape'), (this.holes = []));
  }
  function Hi() {
    ((this.type = 'ShapePath'), (this.subPaths = []), (this.currentPath = null));
  }
  function Vi(t) {
    ((this.type = 'Font'), (this.data = t));
  }
  function ki(t) {
    this.manager = void 0 !== t ? t : vo;
  }
  function ji(t) {
    this.manager = void 0 !== t ? t : vo;
  }
  function Wi() {
    ((this.type = 'StereoCamera'),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new vt()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new vt()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1));
  }
  function Xi(t, e, i) {
    (U.call(this), (this.type = 'CubeCamera'));
    const n = new vt(90, 1, t, e);
    (n.up.set(0, -1, 0), n.lookAt(new a(1, 0, 0)), this.add(n));
    const r = new vt(90, 1, t, e);
    (r.up.set(0, -1, 0), r.lookAt(new a(-1, 0, 0)), this.add(r));
    const o = new vt(90, 1, t, e);
    (o.up.set(0, 0, 1), o.lookAt(new a(0, 1, 0)), this.add(o));
    const s = new vt(90, 1, t, e);
    (s.up.set(0, 0, -1), s.lookAt(new a(0, -1, 0)), this.add(s));
    const c = new vt(90, 1, t, e);
    (c.up.set(0, -1, 0), c.lookAt(new a(0, 0, 1)), this.add(c));
    const h = new vt(90, 1, t, e);
    (h.up.set(0, -1, 0), h.lookAt(new a(0, 0, -1)), this.add(h));
    const u = { format: ma, magFilter: $r, minFilter: $r };
    ((this.renderTarget = new l(i, i, u)),
      (this.renderTarget.texture.name = 'CubeCamera'),
      (this.update = function (t, e) {
        null === this.parent && this.updateMatrixWorld();
        const i = this.renderTarget,
          a = i.texture.generateMipmaps;
        ((i.texture.generateMipmaps = !1),
          (i.activeCubeFace = 0),
          t.render(e, n, i),
          (i.activeCubeFace = 1),
          t.render(e, r, i),
          (i.activeCubeFace = 2),
          t.render(e, o, i),
          (i.activeCubeFace = 3),
          t.render(e, s, i),
          (i.activeCubeFace = 4),
          t.render(e, c, i),
          (i.texture.generateMipmaps = a),
          (i.activeCubeFace = 5),
          t.render(e, h, i),
          t.setRenderTarget(null));
      }),
      (this.clear = function (t, e, i, n) {
        for (let r = this.renderTarget, a = 0; a < 6; a++)
          ((r.activeCubeFace = a), t.setRenderTarget(r), t.clear(e, i, n));
        t.setRenderTarget(null);
      }));
  }
  function qi() {
    (U.call(this),
      (this.type = 'AudioListener'),
      (this.context = Mo.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null));
  }
  function Yi(t) {
    (U.call(this),
      (this.type = 'Audio'),
      (this.context = t.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(t.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.loop = !1),
      (this.startTime = 0),
      (this.offset = 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.sourceType = 'empty'),
      (this.filters = []));
  }
  function Zi(t) {
    (Yi.call(this, t), (this.panner = this.context.createPanner()), this.panner.connect(this.gain));
  }
  function Qi(t, e) {
    ((this.analyser = t.context.createAnalyser()),
      (this.analyser.fftSize = void 0 !== e ? e : 2048),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      t.getOutput().connect(this.analyser));
  }
  function Ji(t, e, i) {
    ((this.binding = t), (this.valueSize = i));
    let n,
      r = Float64Array;
    switch (e) {
      case 'quaternion':
        n = this._slerp;
        break;
      case 'string':
      case 'bool':
        ((r = Array), (n = this._select));
        break;
      default:
        n = this._lerp;
    }
    ((this.buffer = new r(4 * i)),
      (this._mixBufferRegion = n),
      (this.cumulativeWeight = 0),
      (this.useCount = 0),
      (this.referenceCount = 0));
  }
  function Ki(t, e, i) {
    const n = i || $i.parseTrackName(e);
    ((this._targetGroup = t), (this._bindings = t.subscribe_(e, n)));
  }
  function $i(t, e, i) {
    ((this.path = e),
      (this.parsedPath = i || $i.parseTrackName(e)),
      (this.node = $i.findNode(t, this.parsedPath.nodeName) || t),
      (this.rootNode = t));
  }
  function tn() {
    ((this.uuid = Wa.generateUUID()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0));
    const t = {};
    this._indicesByUUID = t;
    for (let e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
    ((this._paths = []), (this._parsedPaths = []), (this._bindings = []), (this._bindingsIndicesByPath = {}));
    const n = this;
    this.stats = {
      objects: {
        get total() {
          return n._objects.length;
        },
        get inUse() {
          return this.total - n.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return n._bindings.length;
      },
    };
  }
  function en(t, e, i) {
    ((this._mixer = t), (this._clip = e), (this._localRoot = i || null));
    for (
      var n = e.tracks, r = n.length, a = new Array(r), o = { endingStart: Ia, endingEnd: Ia }, s = 0;
      s !== r;
      ++s
    ) {
      const c = n[s].createInterpolant(null);
      ((a[s] = c), (c.settings = o));
    }
    ((this._interpolantSettings = o),
      (this._interpolants = a),
      (this._propertyBindings = new Array(r)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = Ca),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0));
  }
  function nn(t) {
    ((this._root = t), this._initMemoryManager(), (this._accuIndex = 0), (this.time = 0), (this.timeScale = 1));
  }
  function rn(t) {
    ('string' == typeof t && (console.warn('THREE.Uniform: Type parameter is no longer needed.'), (t = arguments[1])),
      (this.value = t));
  }
  function an() {
    (K.call(this), (this.type = 'InstancedBufferGeometry'), (this.maxInstancedCount = void 0));
  }
  function on(t, e, i, n) {
    ((this.uuid = Wa.generateUUID()),
      (this.data = t),
      (this.itemSize = e),
      (this.offset = i),
      (this.normalized = !0 === n));
  }
  function sn(t, e) {
    ((this.uuid = Wa.generateUUID()),
      (this.array = t),
      (this.stride = e),
      (this.count = void 0 !== t ? t.length / e : 0),
      (this.dynamic = !1),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.onUploadCallback = function () {}),
      (this.version = 0));
  }
  function cn(t, e, i) {
    (sn.call(this, t, e), (this.meshPerAttribute = i || 1));
  }
  function hn(t, e, i) {
    (G.call(this, t, e), (this.meshPerAttribute = i || 1));
  }
  function ln(t, e, i, n) {
    ((this.ray = new at(t, e)),
      (this.near = i || 0),
      (this.far = n || 1 / 0),
      (this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }),
      Object.defineProperties(this.params, {
        PointCloud: {
          get: function () {
            return (console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.'), this.Points);
          },
        },
      }));
  }
  function un(t, e) {
    return t.distance - e.distance;
  }
  function pn(t, e, i, n) {
    if (!1 !== t.visible && (t.raycast(e, i), !0 === n))
      for (let r = t.children, a = 0, o = r.length; a < o; a++) pn(r[a], e, i, !0);
  }
  function dn(t) {
    ((this.autoStart = void 0 === t || t),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1));
  }
  function fn(t, e, i) {
    return (
      (this.radius = void 0 !== t ? t : 1),
      (this.phi = void 0 !== e ? e : 0),
      (this.theta = void 0 !== i ? i : 0),
      this
    );
  }
  function mn(t, e, i) {
    return (
      (this.radius = void 0 !== t ? t : 1),
      (this.theta = void 0 !== e ? e : 0),
      (this.y = void 0 !== i ? i : 0),
      this
    );
  }
  function vn(t) {
    (U.call(this), (this.material = t), (this.render = function () {}));
  }
  function gn(t, e, i, n) {
    ((this.object = t), (this.size = void 0 !== e ? e : 1));
    let r = void 0 !== i ? i : 16711680,
      a = void 0 !== n ? n : 1,
      o = 0,
      s = this.object.geometry;
    s && s.isGeometry ? (o = 3 * s.faces.length) : s && s.isBufferGeometry && (o = s.attributes.normal.count);
    const c = new K(),
      h = new Y(2 * o * 3, 3);
    (c.addAttribute('position', h),
      Dt.call(this, c, new Ct({ color: r, linewidth: a })),
      (this.matrixAutoUpdate = !1),
      this.update());
  }
  function yn(t, e) {
    (U.call(this),
      (this.light = t),
      this.light.updateMatrixWorld(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = e));
    for (
      var i = new K(),
        n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1],
        r = 0,
        a = 1;
      r < 32;
      r++, a++
    ) {
      const o = (r / 32) * Math.PI * 2,
        s = (a / 32) * Math.PI * 2;
      n.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1);
    }
    i.addAttribute('position', new Y(n, 3));
    const c = new Ct({ fog: !1 });
    ((this.cone = new Dt(i, c)), this.add(this.cone), this.update());
  }
  function xn(t) {
    const e = [];
    t && t.isBone && e.push(t);
    for (let i = 0; i < t.children.length; i++) e.push.apply(e, xn(t.children[i]));
    return e;
  }
  function bn(t) {
    for (var e = xn(t), i = new K(), n = [], r = [], a = new w(0, 0, 1), o = new w(0, 1, 0), s = 0; s < e.length; s++) {
      const c = e[s];
      c.parent && c.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b));
    }
    (i.addAttribute('position', new Y(n, 3)), i.addAttribute('color', new Y(r, 3)));
    const h = new Ct({ vertexColors: er, depthTest: !1, depthWrite: !1, transparent: !0 });
    (Dt.call(this, i, h),
      (this.root = t),
      (this.bones = e),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1));
  }
  function _n(t, e, i) {
    ((this.light = t), this.light.updateMatrixWorld(), (this.color = i));
    const n = new Me(e, 4, 2),
      r = new nt({ wireframe: !0, fog: !1 });
    (ct.call(this, n, r), (this.matrix = this.light.matrixWorld), (this.matrixAutoUpdate = !1), this.update());
  }
  function wn(t, e) {
    (U.call(this),
      (this.light = t),
      this.light.updateMatrixWorld(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = e));
    const i = new Ct({ fog: !1 }),
      n = new K();
    (n.addAttribute('position', new G(new Float32Array(15), 3)),
      (this.line = new It(n, i)),
      this.add(this.line),
      this.update());
  }
  function En(t, e, i) {
    (U.call(this),
      (this.light = t),
      this.light.updateMatrixWorld(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i));
    const n = new Zt(e);
    (n.rotateY(0.5 * Math.PI),
      (this.material = new nt({ wireframe: !0, fog: !1 })),
      void 0 === this.color && (this.material.vertexColors = er));
    const r = n.getAttribute('position'),
      a = new Float32Array(3 * r.count);
    (n.addAttribute('color', new G(a, 3)), this.add(new ct(n, this.material)), this.update());
  }
  function Mn(t, e, i, n) {
    ((t = t || 10), (e = e || 10), (i = new w(void 0 !== i ? i : 4473924)), (n = new w(void 0 !== n ? n : 8947848)));
    for (var r = e / 2, a = t / e, o = t / 2, s = [], c = [], h = 0, l = 0, u = -o; h <= e; h++, u += a) {
      (s.push(-o, 0, u, o, 0, u), s.push(u, 0, -o, u, 0, o));
      const p = h === r ? i : n;
      (p.toArray(c, l), (l += 3), p.toArray(c, l), (l += 3), p.toArray(c, l), (l += 3), p.toArray(c, l), (l += 3));
    }
    const d = new K();
    (d.addAttribute('position', new Y(s, 3)), d.addAttribute('color', new Y(c, 3)));
    const f = new Ct({ vertexColors: er });
    Dt.call(this, d, f);
  }
  function Tn(t, e, i, n, r, a) {
    ((t = t || 10),
      (e = e || 16),
      (i = i || 8),
      (n = n || 64),
      (r = new w(void 0 !== r ? r : 4473924)),
      (a = new w(void 0 !== a ? a : 8947848)));
    let o,
      s,
      c,
      h,
      l,
      u,
      p,
      d = [],
      f = [];
    for (h = 0; h <= e; h++)
      ((c = (h / e) * (2 * Math.PI)),
        (o = Math.sin(c) * t),
        (s = Math.cos(c) * t),
        d.push(0, 0, 0),
        d.push(o, 0, s),
        (p = 1 & h ? r : a),
        f.push(p.r, p.g, p.b),
        f.push(p.r, p.g, p.b));
    for (h = 0; h <= i; h++)
      for (p = 1 & h ? r : a, u = t - (t / i) * h, l = 0; l < n; l++)
        ((c = (l / n) * (2 * Math.PI)),
          (o = Math.sin(c) * u),
          (s = Math.cos(c) * u),
          d.push(o, 0, s),
          f.push(p.r, p.g, p.b),
          (c = ((l + 1) / n) * (2 * Math.PI)),
          (o = Math.sin(c) * u),
          (s = Math.cos(c) * u),
          d.push(o, 0, s),
          f.push(p.r, p.g, p.b));
    const m = new K();
    (m.addAttribute('position', new Y(d, 3)), m.addAttribute('color', new Y(f, 3)));
    const v = new Ct({ vertexColors: er });
    Dt.call(this, m, v);
  }
  function Sn(t, e, i, n) {
    ((this.object = t), (this.size = void 0 !== e ? e : 1));
    let r = void 0 !== i ? i : 16776960,
      a = void 0 !== n ? n : 1,
      o = 0,
      s = this.object.geometry;
    s && s.isGeometry
      ? (o = s.faces.length)
      : console.warn(
          'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.'
        );
    const c = new K(),
      h = new Y(2 * o * 3, 3);
    (c.addAttribute('position', h),
      Dt.call(this, c, new Ct({ color: r, linewidth: a })),
      (this.matrixAutoUpdate = !1),
      this.update());
  }
  function An(t, e, i) {
    (U.call(this),
      (this.light = t),
      this.light.updateMatrixWorld(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      void 0 === e && (e = 1));
    let n = new K();
    n.addAttribute('position', new Y([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
    const r = new Ct({ fog: !1 });
    ((this.lightPlane = new It(n, r)),
      this.add(this.lightPlane),
      (n = new K()).addAttribute('position', new Y([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new It(n, r)),
      this.add(this.targetLine),
      this.update());
  }
  function Rn(t) {
    function e(t, e, n) {
      (i(t, n), i(e, n));
    }
    function i(t, e) {
      (a.push(0, 0, 0), o.push(e.r, e.g, e.b), void 0 === s[t] && (s[t] = []), s[t].push(a.length / 3 - 1));
    }
    var n = new K(),
      r = new Ct({ color: 16777215, vertexColors: tr }),
      a = [],
      o = [],
      s = {},
      c = new w(16755200),
      h = new w(16711680),
      l = new w(43775),
      u = new w(16777215),
      p = new w(3355443);
    (e('n1', 'n2', c),
      e('n2', 'n4', c),
      e('n4', 'n3', c),
      e('n3', 'n1', c),
      e('f1', 'f2', c),
      e('f2', 'f4', c),
      e('f4', 'f3', c),
      e('f3', 'f1', c),
      e('n1', 'f1', c),
      e('n2', 'f2', c),
      e('n3', 'f3', c),
      e('n4', 'f4', c),
      e('p', 'n1', h),
      e('p', 'n2', h),
      e('p', 'n3', h),
      e('p', 'n4', h),
      e('u1', 'u2', l),
      e('u2', 'u3', l),
      e('u3', 'u1', l),
      e('c', 't', u),
      e('p', 'c', p),
      e('cn1', 'cn2', p),
      e('cn3', 'cn4', p),
      e('cf1', 'cf2', p),
      e('cf3', 'cf4', p),
      n.addAttribute('position', new Y(a, 3)),
      n.addAttribute('color', new Y(o, 3)),
      Dt.call(this, n, r),
      (this.camera = t),
      this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = s),
      this.update());
  }
  function Ln(t, e) {
    ((this.object = t), void 0 === e && (e = 16776960));
    const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
      n = new Float32Array(24),
      r = new K();
    (r.setIndex(new G(i, 1)),
      r.addAttribute('position', new G(n, 3)),
      Dt.call(this, r, new Ct({ color: e })),
      (this.matrixAutoUpdate = !1),
      this.update());
  }
  function Pn(t, e) {
    ((this.type = 'Box3Helper'), (this.box = t));
    const i = void 0 !== e ? e : 16776960,
      n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
      r = new K();
    (r.setIndex(new G(n, 1)),
      r.addAttribute(
        'position',
        new Y([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)
      ),
      Dt.call(this, r, new Ct({ color: i })),
      this.geometry.computeBoundingSphere());
  }
  function Cn(t, e, i) {
    ((this.type = 'PlaneHelper'), (this.plane = t), (this.size = void 0 === e ? 1 : e));
    const n = void 0 !== i ? i : 16776960,
      r = new K();
    (r.addAttribute(
      'position',
      new Y([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)
    ),
      r.computeBoundingSphere(),
      It.call(this, r, new Ct({ color: n })));
    const a = new K();
    (a.addAttribute('position', new Y([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)),
      a.computeBoundingSphere(),
      this.add(new ct(a, new nt({ color: n, opacity: 0.2, transparent: !0, depthWrite: !1 }))));
  }
  function In(t, e, i, n, r, a) {
    (U.call(this),
      void 0 === n && (n = 16776960),
      void 0 === i && (i = 1),
      void 0 === r && (r = 0.2 * i),
      void 0 === a && (a = 0.2 * r),
      void 0 === To &&
        ((To = new K()).addAttribute('position', new Y([0, 0, 0, 0, 1, 0], 3)),
        (So = new De(0, 0.5, 1, 5, 1)).translate(0, -0.5, 0)),
      this.position.copy(e),
      (this.line = new It(To, new Ct({ color: n }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new ct(So, new nt({ color: n }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(t),
      this.setLength(i, r, a));
  }
  function Dn(t) {
    const e = [0, 0, 0, (t = t || 1), 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
      i = new K();
    (i.addAttribute('position', new Y(e, 3)),
      i.addAttribute('color', new Y([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)));
    const n = new Ct({ vertexColors: er });
    Dt.call(this, i, n);
  }
  function On() {
    function t(t, a, o, s) {
      ((e = t), (i = o), (n = -3 * t + 3 * a - 2 * o - s), (r = 2 * t - 2 * a + o + s));
    }
    var e = 0,
      i = 0,
      n = 0,
      r = 0;
    return {
      initCatmullRom: function (e, i, n, r, a) {
        t(i, n, a * (n - e), a * (r - i));
      },
      initNonuniformCatmullRom: function (e, i, n, r, a, o, s) {
        let c = (i - e) / a - (n - e) / (a + o) + (n - i) / o,
          h = (n - i) / o - (r - i) / (o + s) + (r - n) / s;
        t(i, n, (c *= o), (h *= o));
      },
      calc: function (t) {
        const a = t * t;
        return e + i * t + n * a + r * (a * t);
      },
    };
  }
  function Un(t, e, i, n) {
    (Ii.call(this),
      (this.type = 'CatmullRomCurve3'),
      (this.points = t || []),
      (this.closed = e || !1),
      (this.curveType = i || 'centripetal'),
      (this.tension = n || 0.5));
  }
  function Nn(t, e, i, n) {
    (Ii.call(this),
      (this.type = 'CubicBezierCurve3'),
      (this.v0 = t || new a()),
      (this.v1 = e || new a()),
      (this.v2 = i || new a()),
      (this.v3 = n || new a()));
  }
  function Bn(t, e, i) {
    (Ii.call(this),
      (this.type = 'QuadraticBezierCurve3'),
      (this.v0 = t || new a()),
      (this.v1 = e || new a()),
      (this.v2 = i || new a()));
  }
  function Fn(t, e) {
    (Ii.call(this), (this.type = 'LineCurve3'), (this.v1 = t || new a()), (this.v2 = e || new a()));
  }
  function zn(t, e, i, n, r, a) {
    (Ui.call(this, t, e, i, i, n, r, a), (this.type = 'ArcCurve'));
  }
  function Gn(t) {
    (console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.'),
      Un.call(this, t),
      (this.type = 'catmullrom'),
      (this.closed = !0));
  }
  function Hn(t) {
    (console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.'),
      Un.call(this, t),
      (this.type = 'catmullrom'));
  }
  function Vn(t) {
    (console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.'),
      Un.call(this, t),
      (this.type = 'catmullrom'));
  }
  (void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
    void 0 === Number.isInteger &&
      (Number.isInteger = function (t) {
        return 'number' == typeof t && isFinite(t) && Math.floor(t) === t;
      }),
    void 0 === Math.sign &&
      (Math.sign = function (t) {
        return t < 0 ? -1 : t > 0 ? 1 : +t;
      }),
    'name' in Function.prototype == !1 &&
      Object.defineProperty(Function.prototype, 'name', {
        get: function () {
          return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
        },
      }),
    void 0 === Object.assign &&
      (Object.assign = function (t) {
        if (void 0 === t || null === t) throw new TypeError('Cannot convert undefined or null to object');
        for (var e = Object(t), i = 1; i < arguments.length; i++) {
          const n = arguments[i];
          if (void 0 !== n && null !== n)
            for (const r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
        }
        return e;
      }),
    Object.assign(e.prototype, {
      addEventListener: function (t, e) {
        void 0 === this._listeners && (this._listeners = {});
        const i = this._listeners;
        (void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e));
      },
      hasEventListener: function (t, e) {
        if (void 0 === this._listeners) return !1;
        const i = this._listeners;
        return void 0 !== i[t] && -1 !== i[t].indexOf(e);
      },
      removeEventListener: function (t, e) {
        if (void 0 !== this._listeners) {
          const i = this._listeners[t];
          if (void 0 !== i) {
            const n = i.indexOf(e);
            -1 !== n && i.splice(n, 1);
          }
        }
      },
      dispatchEvent: function (t) {
        if (void 0 !== this._listeners) {
          const e = this._listeners[t.type];
          if (void 0 !== e) {
            t.target = this;
            for (let i = e.slice(0), n = 0, r = i.length; n < r; n++) i[n].call(this, t);
          }
        }
      },
    }));
  var kn = '89dev',
    jn = 0,
    Wn = 1,
    Xn = 2,
    qn = 0,
    Yn = 1,
    Zn = 2,
    Qn = 0,
    Jn = 1,
    Kn = 2,
    $n = 0,
    tr = 1,
    er = 2,
    ir = 0,
    nr = 1,
    rr = 2,
    ar = 3,
    or = 4,
    sr = 5,
    cr = 100,
    hr = 101,
    lr = 102,
    ur = 103,
    pr = 104,
    dr = 200,
    fr = 201,
    mr = 202,
    vr = 203,
    gr = 204,
    yr = 205,
    xr = 206,
    br = 207,
    _r = 208,
    wr = 209,
    Er = 210,
    Mr = 0,
    Tr = 1,
    Sr = 2,
    Ar = 3,
    Rr = 4,
    Lr = 5,
    Pr = 6,
    Cr = 7,
    Ir = 0,
    Dr = 1,
    Or = 2,
    Ur = 0,
    Nr = 1,
    Br = 2,
    Fr = 3,
    zr = 4,
    Gr = 301,
    Hr = 302,
    Vr = 303,
    kr = 304,
    jr = 305,
    Wr = 306,
    Xr = 307,
    qr = 1e3,
    Yr = 1001,
    Zr = 1002,
    Qr = 1003,
    Jr = 1004,
    Kr = 1005,
    $r = 1006,
    ta = 1007,
    ea = 1008,
    ia = 1009,
    na = 1010,
    ra = 1011,
    aa = 1012,
    oa = 1013,
    sa = 1014,
    ca = 1015,
    ha = 1016,
    la = 1017,
    ua = 1018,
    pa = 1019,
    da = 1020,
    fa = 1021,
    ma = 1022,
    va = 1023,
    ga = 1024,
    ya = 1025,
    xa = va,
    ba = 1026,
    _a = 1027,
    wa = 2001,
    Ea = 2002,
    Ma = 2003,
    Ta = 2004,
    Sa = 2100,
    Aa = 2101,
    Ra = 2102,
    La = 2103,
    Pa = 2151,
    Ca = 2201,
    Ia = 2400,
    Da = 0,
    Oa = 1,
    Ua = 2,
    Na = 3e3,
    Ba = 3001,
    Fa = 3007,
    za = 3002,
    Ga = 3004,
    Ha = 3005,
    Va = 3006,
    ka = 3200,
    ja = 3201,
    Wa = {
      DEG2RAD: Math.PI / 180,
      RAD2DEG: 180 / Math.PI,
      generateUUID: (function () {
        for (var t = [], e = 0; e < 256; e++) t[e] = (e < 16 ? '0' : '') + e.toString(16).toUpperCase();
        return function () {
          const e = (4294967295 * Math.random()) | 0,
            i = (4294967295 * Math.random()) | 0,
            n = (4294967295 * Math.random()) | 0,
            r = (4294967295 * Math.random()) | 0;
          return (
            t[255 & e] +
            t[(e >> 8) & 255] +
            t[(e >> 16) & 255] +
            t[(e >> 24) & 255] +
            '-' +
            t[255 & i] +
            t[(i >> 8) & 255] +
            '-' +
            t[((i >> 16) & 15) | 64] +
            t[(i >> 24) & 255] +
            '-' +
            t[(63 & n) | 128] +
            t[(n >> 8) & 255] +
            '-' +
            t[(n >> 16) & 255] +
            t[(n >> 24) & 255] +
            t[255 & r] +
            t[(r >> 8) & 255] +
            t[(r >> 16) & 255] +
            t[(r >> 24) & 255]
          );
        };
      })(),
      clamp: function (t, e, i) {
        return Math.max(e, Math.min(i, t));
      },
      euclideanModulo: function (t, e) {
        return ((t % e) + e) % e;
      },
      mapLinear: function (t, e, i, n, r) {
        return n + ((t - e) * (r - n)) / (i - e);
      },
      lerp: function (t, e, i) {
        return (1 - i) * t + i * e;
      },
      smoothstep: function (t, e, i) {
        return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t);
      },
      smootherstep: function (t, e, i) {
        return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10);
      },
      randInt: function (t, e) {
        return t + Math.floor(Math.random() * (e - t + 1));
      },
      randFloat: function (t, e) {
        return t + Math.random() * (e - t);
      },
      randFloatSpread: function (t) {
        return t * (0.5 - Math.random());
      },
      degToRad: function (t) {
        return t * Wa.DEG2RAD;
      },
      radToDeg: function (t) {
        return t * Wa.RAD2DEG;
      },
      isPowerOfTwo: function (t) {
        return 0 == (t & (t - 1)) && 0 !== t;
      },
      ceilPowerOfTwo: function (t) {
        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
      },
      floorPowerOfTwo: function (t) {
        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
      },
    };
  (Object.defineProperties(i.prototype, {
    width: {
      get: function () {
        return this.x;
      },
      set: function (t) {
        this.x = t;
      },
    },
    height: {
      get: function () {
        return this.y;
      },
      set: function (t) {
        this.y = t;
      },
    },
  }),
    Object.assign(i.prototype, {
      isVector2: !0,
      set: function (t, e) {
        return ((this.x = t), (this.y = e), this);
      },
      setScalar: function (t) {
        return ((this.x = t), (this.y = t), this);
      },
      setX: function (t) {
        return ((this.x = t), this);
      },
      setY: function (t) {
        return ((this.y = t), this);
      },
      setComponent: function (t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          default:
            throw new Error('index is out of range: ' + t);
        }
        return this;
      },
      getComponent: function (t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error('index is out of range: ' + t);
        }
      },
      clone: function () {
        return new this.constructor(this.x, this.y);
      },
      copy: function (t) {
        return ((this.x = t.x), (this.y = t.y), this);
      },
      add: function (t, e) {
        return void 0 !== e
          ? (console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'),
            this.addVectors(t, e))
          : ((this.x += t.x), (this.y += t.y), this);
      },
      addScalar: function (t) {
        return ((this.x += t), (this.y += t), this);
      },
      addVectors: function (t, e) {
        return ((this.x = t.x + e.x), (this.y = t.y + e.y), this);
      },
      addScaledVector: function (t, e) {
        return ((this.x += t.x * e), (this.y += t.y * e), this);
      },
      sub: function (t, e) {
        return void 0 !== e
          ? (console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'),
            this.subVectors(t, e))
          : ((this.x -= t.x), (this.y -= t.y), this);
      },
      subScalar: function (t) {
        return ((this.x -= t), (this.y -= t), this);
      },
      subVectors: function (t, e) {
        return ((this.x = t.x - e.x), (this.y = t.y - e.y), this);
      },
      multiply: function (t) {
        return ((this.x *= t.x), (this.y *= t.y), this);
      },
      multiplyScalar: function (t) {
        return ((this.x *= t), (this.y *= t), this);
      },
      divide: function (t) {
        return ((this.x /= t.x), (this.y /= t.y), this);
      },
      divideScalar: function (t) {
        return this.multiplyScalar(1 / t);
      },
      applyMatrix3: function (t) {
        const e = this.x,
          i = this.y,
          n = t.elements;
        return ((this.x = n[0] * e + n[3] * i + n[6]), (this.y = n[1] * e + n[4] * i + n[7]), this);
      },
      min: function (t) {
        return ((this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this);
      },
      max: function (t) {
        return ((this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this);
      },
      clamp: function (t, e) {
        return ((this.x = Math.max(t.x, Math.min(e.x, this.x))), (this.y = Math.max(t.y, Math.min(e.y, this.y))), this);
      },
      clampScalar: (function () {
        const t = new i(),
          e = new i();
        return function (i, n) {
          return (t.set(i, i), e.set(n, n), this.clamp(t, e));
        };
      })(),
      clampLength: function (t, e) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
      },
      floor: function () {
        return ((this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this);
      },
      ceil: function () {
        return ((this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this);
      },
      round: function () {
        return ((this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this);
      },
      roundToZero: function () {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          this
        );
      },
      negate: function () {
        return ((this.x = -this.x), (this.y = -this.y), this);
      },
      dot: function (t) {
        return this.x * t.x + this.y * t.y;
      },
      lengthSq: function () {
        return this.x * this.x + this.y * this.y;
      },
      length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      },
      manhattanLength: function () {
        return Math.abs(this.x) + Math.abs(this.y);
      },
      normalize: function () {
        return this.divideScalar(this.length() || 1);
      },
      angle: function () {
        let t = Math.atan2(this.y, this.x);
        return (t < 0 && (t += 2 * Math.PI), t);
      },
      distanceTo: function (t) {
        return Math.sqrt(this.distanceToSquared(t));
      },
      distanceToSquared: function (t) {
        const e = this.x - t.x,
          i = this.y - t.y;
        return e * e + i * i;
      },
      manhattanDistanceTo: function (t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
      },
      setLength: function (t) {
        return this.normalize().multiplyScalar(t);
      },
      lerp: function (t, e) {
        return ((this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this);
      },
      lerpVectors: function (t, e, i) {
        return this.subVectors(e, t).multiplyScalar(i).add(t);
      },
      equals: function (t) {
        return t.x === this.x && t.y === this.y;
      },
      fromArray: function (t, e) {
        return (void 0 === e && (e = 0), (this.x = t[e]), (this.y = t[e + 1]), this);
      },
      toArray: function (t, e) {
        return (void 0 === t && (t = []), void 0 === e && (e = 0), (t[e] = this.x), (t[e + 1] = this.y), t);
      },
      fromBufferAttribute: function (t, e, i) {
        return (
          void 0 !== i && console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().'),
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          this
        );
      },
      rotateAround: function (t, e) {
        const i = Math.cos(e),
          n = Math.sin(e),
          r = this.x - t.x,
          a = this.y - t.y;
        return ((this.x = r * i - a * n + t.x), (this.y = r * n + a * i + t.y), this);
      },
    }),
    Object.assign(n.prototype, {
      isMatrix4: !0,
      set: function (t, e, i, n, r, a, o, s, c, h, l, u, p, d, f, m) {
        const v = this.elements;
        return (
          (v[0] = t),
          (v[4] = e),
          (v[8] = i),
          (v[12] = n),
          (v[1] = r),
          (v[5] = a),
          (v[9] = o),
          (v[13] = s),
          (v[2] = c),
          (v[6] = h),
          (v[10] = l),
          (v[14] = u),
          (v[3] = p),
          (v[7] = d),
          (v[11] = f),
          (v[15] = m),
          this
        );
      },
      identity: function () {
        return (this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this);
      },
      clone: function () {
        return new n().fromArray(this.elements);
      },
      copy: function (t) {
        const e = this.elements,
          i = t.elements;
        return (
          (e[0] = i[0]),
          (e[1] = i[1]),
          (e[2] = i[2]),
          (e[3] = i[3]),
          (e[4] = i[4]),
          (e[5] = i[5]),
          (e[6] = i[6]),
          (e[7] = i[7]),
          (e[8] = i[8]),
          (e[9] = i[9]),
          (e[10] = i[10]),
          (e[11] = i[11]),
          (e[12] = i[12]),
          (e[13] = i[13]),
          (e[14] = i[14]),
          (e[15] = i[15]),
          this
        );
      },
      copyPosition: function (t) {
        const e = this.elements,
          i = t.elements;
        return ((e[12] = i[12]), (e[13] = i[13]), (e[14] = i[14]), this);
      },
      extractBasis: function (t, e, i) {
        return (t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this);
      },
      makeBasis: function (t, e, i) {
        return (this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this);
      },
      extractRotation: (function () {
        const t = new a();
        return function (e) {
          const i = this.elements,
            n = e.elements,
            r = 1 / t.setFromMatrixColumn(e, 0).length(),
            a = 1 / t.setFromMatrixColumn(e, 1).length(),
            o = 1 / t.setFromMatrixColumn(e, 2).length();
          return (
            (i[0] = n[0] * r),
            (i[1] = n[1] * r),
            (i[2] = n[2] * r),
            (i[4] = n[4] * a),
            (i[5] = n[5] * a),
            (i[6] = n[6] * a),
            (i[8] = n[8] * o),
            (i[9] = n[9] * o),
            (i[10] = n[10] * o),
            this
          );
        };
      })(),
      makeRotationFromEuler: function (t) {
        (t && t.isEuler) ||
          console.error(
            'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.'
          );
        const e = this.elements,
          i = t.x,
          n = t.y,
          r = t.z,
          a = Math.cos(i),
          o = Math.sin(i),
          s = Math.cos(n),
          c = Math.sin(n),
          h = Math.cos(r),
          l = Math.sin(r);
        if ('XYZ' === t.order) {
          var u = a * h,
            p = a * l,
            d = o * h,
            f = o * l;
          ((e[0] = s * h),
            (e[4] = -s * l),
            (e[8] = c),
            (e[1] = p + d * c),
            (e[5] = u - f * c),
            (e[9] = -o * s),
            (e[2] = f - u * c),
            (e[6] = d + p * c),
            (e[10] = a * s));
        } else if ('YXZ' === t.order) {
          var m = s * h,
            v = s * l,
            g = c * h,
            y = c * l;
          ((e[0] = m + y * o),
            (e[4] = g * o - v),
            (e[8] = a * c),
            (e[1] = a * l),
            (e[5] = a * h),
            (e[9] = -o),
            (e[2] = v * o - g),
            (e[6] = y + m * o),
            (e[10] = a * s));
        } else if ('ZXY' === t.order) {
          var m = s * h,
            v = s * l,
            g = c * h,
            y = c * l;
          ((e[0] = m - y * o),
            (e[4] = -a * l),
            (e[8] = g + v * o),
            (e[1] = v + g * o),
            (e[5] = a * h),
            (e[9] = y - m * o),
            (e[2] = -a * c),
            (e[6] = o),
            (e[10] = a * s));
        } else if ('ZYX' === t.order) {
          var u = a * h,
            p = a * l,
            d = o * h,
            f = o * l;
          ((e[0] = s * h),
            (e[4] = d * c - p),
            (e[8] = u * c + f),
            (e[1] = s * l),
            (e[5] = f * c + u),
            (e[9] = p * c - d),
            (e[2] = -c),
            (e[6] = o * s),
            (e[10] = a * s));
        } else if ('YZX' === t.order) {
          var x = a * s,
            b = a * c,
            _ = o * s,
            w = o * c;
          ((e[0] = s * h),
            (e[4] = w - x * l),
            (e[8] = _ * l + b),
            (e[1] = l),
            (e[5] = a * h),
            (e[9] = -o * h),
            (e[2] = -c * h),
            (e[6] = b * l + _),
            (e[10] = x - w * l));
        } else if ('XZY' === t.order) {
          var x = a * s,
            b = a * c,
            _ = o * s,
            w = o * c;
          ((e[0] = s * h),
            (e[4] = -l),
            (e[8] = c * h),
            (e[1] = x * l + w),
            (e[5] = a * h),
            (e[9] = b * l - _),
            (e[2] = _ * l - b),
            (e[6] = o * h),
            (e[10] = w * l + x));
        }
        return ((e[3] = 0), (e[7] = 0), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), this);
      },
      makeRotationFromQuaternion: function (t) {
        const e = this.elements,
          i = t._x,
          n = t._y,
          r = t._z,
          a = t._w,
          o = i + i,
          s = n + n,
          c = r + r,
          h = i * o,
          l = i * s,
          u = i * c,
          p = n * s,
          d = n * c,
          f = r * c,
          m = a * o,
          v = a * s,
          g = a * c;
        return (
          (e[0] = 1 - (p + f)),
          (e[4] = l - g),
          (e[8] = u + v),
          (e[1] = l + g),
          (e[5] = 1 - (h + f)),
          (e[9] = d - m),
          (e[2] = u - v),
          (e[6] = d + m),
          (e[10] = 1 - (h + p)),
          (e[3] = 0),
          (e[7] = 0),
          (e[11] = 0),
          (e[12] = 0),
          (e[13] = 0),
          (e[14] = 0),
          (e[15] = 1),
          this
        );
      },
      lookAt: (function () {
        const t = new a(),
          e = new a(),
          i = new a();
        return function (n, r, a) {
          const o = this.elements;
          return (
            i.subVectors(n, r),
            0 === i.lengthSq() && (i.z = 1),
            i.normalize(),
            t.crossVectors(a, i),
            0 === t.lengthSq() &&
              (1 === Math.abs(a.z) ? (i.x += 1e-4) : (i.z += 1e-4), i.normalize(), t.crossVectors(a, i)),
            t.normalize(),
            e.crossVectors(i, t),
            (o[0] = t.x),
            (o[4] = e.x),
            (o[8] = i.x),
            (o[1] = t.y),
            (o[5] = e.y),
            (o[9] = i.y),
            (o[2] = t.z),
            (o[6] = e.z),
            (o[10] = i.z),
            this
          );
        };
      })(),
      multiply: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.'
            ),
            this.multiplyMatrices(t, e))
          : this.multiplyMatrices(this, t);
      },
      premultiply: function (t) {
        return this.multiplyMatrices(t, this);
      },
      multiplyMatrices: function (t, e) {
        const i = t.elements,
          n = e.elements,
          r = this.elements,
          a = i[0],
          o = i[4],
          s = i[8],
          c = i[12],
          h = i[1],
          l = i[5],
          u = i[9],
          p = i[13],
          d = i[2],
          f = i[6],
          m = i[10],
          v = i[14],
          g = i[3],
          y = i[7],
          x = i[11],
          b = i[15],
          _ = n[0],
          w = n[4],
          E = n[8],
          M = n[12],
          T = n[1],
          S = n[5],
          A = n[9],
          R = n[13],
          L = n[2],
          P = n[6],
          C = n[10],
          I = n[14],
          D = n[3],
          O = n[7],
          U = n[11],
          N = n[15];
        return (
          (r[0] = a * _ + o * T + s * L + c * D),
          (r[4] = a * w + o * S + s * P + c * O),
          (r[8] = a * E + o * A + s * C + c * U),
          (r[12] = a * M + o * R + s * I + c * N),
          (r[1] = h * _ + l * T + u * L + p * D),
          (r[5] = h * w + l * S + u * P + p * O),
          (r[9] = h * E + l * A + u * C + p * U),
          (r[13] = h * M + l * R + u * I + p * N),
          (r[2] = d * _ + f * T + m * L + v * D),
          (r[6] = d * w + f * S + m * P + v * O),
          (r[10] = d * E + f * A + m * C + v * U),
          (r[14] = d * M + f * R + m * I + v * N),
          (r[3] = g * _ + y * T + x * L + b * D),
          (r[7] = g * w + y * S + x * P + b * O),
          (r[11] = g * E + y * A + x * C + b * U),
          (r[15] = g * M + y * R + x * I + b * N),
          this
        );
      },
      multiplyScalar: function (t) {
        const e = this.elements;
        return (
          (e[0] *= t),
          (e[4] *= t),
          (e[8] *= t),
          (e[12] *= t),
          (e[1] *= t),
          (e[5] *= t),
          (e[9] *= t),
          (e[13] *= t),
          (e[2] *= t),
          (e[6] *= t),
          (e[10] *= t),
          (e[14] *= t),
          (e[3] *= t),
          (e[7] *= t),
          (e[11] *= t),
          (e[15] *= t),
          this
        );
      },
      applyToBufferAttribute: (function () {
        const t = new a();
        return function (e) {
          for (let i = 0, n = e.count; i < n; i++)
            ((t.x = e.getX(i)), (t.y = e.getY(i)), (t.z = e.getZ(i)), t.applyMatrix4(this), e.setXYZ(i, t.x, t.y, t.z));
          return e;
        };
      })(),
      determinant: function () {
        const t = this.elements,
          e = t[0],
          i = t[4],
          n = t[8],
          r = t[12],
          a = t[1],
          o = t[5],
          s = t[9],
          c = t[13],
          h = t[2],
          l = t[6],
          u = t[10],
          p = t[14];
        return (
          t[3] * (+r * s * l - n * c * l - r * o * u + i * c * u + n * o * p - i * s * p) +
          t[7] * (+e * s * p - e * c * u + r * a * u - n * a * p + n * c * h - r * s * h) +
          t[11] * (+e * c * l - e * o * p - r * a * l + i * a * p + r * o * h - i * c * h) +
          t[15] * (-n * o * h - e * s * l + e * o * u + n * a * l - i * a * u + i * s * h)
        );
      },
      transpose: function () {
        let t,
          e = this.elements;
        return (
          (t = e[1]),
          (e[1] = e[4]),
          (e[4] = t),
          (t = e[2]),
          (e[2] = e[8]),
          (e[8] = t),
          (t = e[6]),
          (e[6] = e[9]),
          (e[9] = t),
          (t = e[3]),
          (e[3] = e[12]),
          (e[12] = t),
          (t = e[7]),
          (e[7] = e[13]),
          (e[13] = t),
          (t = e[11]),
          (e[11] = e[14]),
          (e[14] = t),
          this
        );
      },
      setPosition: function (t) {
        const e = this.elements;
        return ((e[12] = t.x), (e[13] = t.y), (e[14] = t.z), this);
      },
      getInverse: function (t, e) {
        const i = this.elements,
          n = t.elements,
          r = n[0],
          a = n[1],
          o = n[2],
          s = n[3],
          c = n[4],
          h = n[5],
          l = n[6],
          u = n[7],
          p = n[8],
          d = n[9],
          f = n[10],
          m = n[11],
          v = n[12],
          g = n[13],
          y = n[14],
          x = n[15],
          b = d * y * u - g * f * u + g * l * m - h * y * m - d * l * x + h * f * x,
          _ = v * f * u - p * y * u - v * l * m + c * y * m + p * l * x - c * f * x,
          w = p * g * u - v * d * u + v * h * m - c * g * m - p * h * x + c * d * x,
          E = v * d * l - p * g * l - v * h * f + c * g * f + p * h * y - c * d * y,
          M = r * b + a * _ + o * w + s * E;
        if (0 === M) {
          const T = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
          if (!0 === e) throw new Error(T);
          return (console.warn(T), this.identity());
        }
        const S = 1 / M;
        return (
          (i[0] = b * S),
          (i[1] = (g * f * s - d * y * s - g * o * m + a * y * m + d * o * x - a * f * x) * S),
          (i[2] = (h * y * s - g * l * s + g * o * u - a * y * u - h * o * x + a * l * x) * S),
          (i[3] = (d * l * s - h * f * s - d * o * u + a * f * u + h * o * m - a * l * m) * S),
          (i[4] = _ * S),
          (i[5] = (p * y * s - v * f * s + v * o * m - r * y * m - p * o * x + r * f * x) * S),
          (i[6] = (v * l * s - c * y * s - v * o * u + r * y * u + c * o * x - r * l * x) * S),
          (i[7] = (c * f * s - p * l * s + p * o * u - r * f * u - c * o * m + r * l * m) * S),
          (i[8] = w * S),
          (i[9] = (v * d * s - p * g * s - v * a * m + r * g * m + p * a * x - r * d * x) * S),
          (i[10] = (c * g * s - v * h * s + v * a * u - r * g * u - c * a * x + r * h * x) * S),
          (i[11] = (p * h * s - c * d * s - p * a * u + r * d * u + c * a * m - r * h * m) * S),
          (i[12] = E * S),
          (i[13] = (p * g * o - v * d * o + v * a * f - r * g * f - p * a * y + r * d * y) * S),
          (i[14] = (v * h * o - c * g * o - v * a * l + r * g * l + c * a * y - r * h * y) * S),
          (i[15] = (c * d * o - p * h * o + p * a * l - r * d * l - c * a * f + r * h * f) * S),
          this
        );
      },
      scale: function (t) {
        const e = this.elements,
          i = t.x,
          n = t.y,
          r = t.z;
        return (
          (e[0] *= i),
          (e[4] *= n),
          (e[8] *= r),
          (e[1] *= i),
          (e[5] *= n),
          (e[9] *= r),
          (e[2] *= i),
          (e[6] *= n),
          (e[10] *= r),
          (e[3] *= i),
          (e[7] *= n),
          (e[11] *= r),
          this
        );
      },
      getMaxScaleOnAxis: function () {
        const t = this.elements,
          e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
          i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
          n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e, i, n));
      },
      makeTranslation: function (t, e, i) {
        return (this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this);
      },
      makeRotationX: function (t) {
        const e = Math.cos(t),
          i = Math.sin(t);
        return (this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this);
      },
      makeRotationY: function (t) {
        const e = Math.cos(t),
          i = Math.sin(t);
        return (this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this);
      },
      makeRotationZ: function (t) {
        const e = Math.cos(t),
          i = Math.sin(t);
        return (this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this);
      },
      makeRotationAxis: function (t, e) {
        const i = Math.cos(e),
          n = Math.sin(e),
          r = 1 - i,
          a = t.x,
          o = t.y,
          s = t.z,
          c = r * a,
          h = r * o;
        return (
          this.set(
            c * a + i,
            c * o - n * s,
            c * s + n * o,
            0,
            c * o + n * s,
            h * o + i,
            h * s - n * a,
            0,
            c * s - n * o,
            h * s + n * a,
            r * s * s + i,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      },
      makeScale: function (t, e, i) {
        return (this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this);
      },
      makeShear: function (t, e, i) {
        return (this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this);
      },
      compose: function (t, e, i) {
        return (this.makeRotationFromQuaternion(e), this.scale(i), this.setPosition(t), this);
      },
      decompose: (function () {
        const t = new a(),
          e = new n();
        return function (i, n, r) {
          let a = this.elements,
            o = t.set(a[0], a[1], a[2]).length(),
            s = t.set(a[4], a[5], a[6]).length(),
            c = t.set(a[8], a[9], a[10]).length();
          (this.determinant() < 0 && (o = -o), (i.x = a[12]), (i.y = a[13]), (i.z = a[14]), e.copy(this));
          const h = 1 / o,
            l = 1 / s,
            u = 1 / c;
          return (
            (e.elements[0] *= h),
            (e.elements[1] *= h),
            (e.elements[2] *= h),
            (e.elements[4] *= l),
            (e.elements[5] *= l),
            (e.elements[6] *= l),
            (e.elements[8] *= u),
            (e.elements[9] *= u),
            (e.elements[10] *= u),
            n.setFromRotationMatrix(e),
            (r.x = o),
            (r.y = s),
            (r.z = c),
            this
          );
        };
      })(),
      makePerspective: function (t, e, i, n, r, a) {
        void 0 === a &&
          console.warn(
            'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.'
          );
        const o = this.elements,
          s = (2 * r) / (e - t),
          c = (2 * r) / (i - n),
          h = (e + t) / (e - t),
          l = (i + n) / (i - n),
          u = -(a + r) / (a - r),
          p = (-2 * a * r) / (a - r);
        return (
          (o[0] = s),
          (o[4] = 0),
          (o[8] = h),
          (o[12] = 0),
          (o[1] = 0),
          (o[5] = c),
          (o[9] = l),
          (o[13] = 0),
          (o[2] = 0),
          (o[6] = 0),
          (o[10] = u),
          (o[14] = p),
          (o[3] = 0),
          (o[7] = 0),
          (o[11] = -1),
          (o[15] = 0),
          this
        );
      },
      makeOrthographic: function (t, e, i, n, r, a) {
        const o = this.elements,
          s = 1 / (e - t),
          c = 1 / (i - n),
          h = 1 / (a - r),
          l = (e + t) * s,
          u = (i + n) * c,
          p = (a + r) * h;
        return (
          (o[0] = 2 * s),
          (o[4] = 0),
          (o[8] = 0),
          (o[12] = -l),
          (o[1] = 0),
          (o[5] = 2 * c),
          (o[9] = 0),
          (o[13] = -u),
          (o[2] = 0),
          (o[6] = 0),
          (o[10] = -2 * h),
          (o[14] = -p),
          (o[3] = 0),
          (o[7] = 0),
          (o[11] = 0),
          (o[15] = 1),
          this
        );
      },
      equals: function (t) {
        for (let e = this.elements, i = t.elements, n = 0; n < 16; n++) if (e[n] !== i[n]) return !1;
        return !0;
      },
      fromArray: function (t, e) {
        void 0 === e && (e = 0);
        for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
        return this;
      },
      toArray: function (t, e) {
        (void 0 === t && (t = []), void 0 === e && (e = 0));
        const i = this.elements;
        return (
          (t[e] = i[0]),
          (t[e + 1] = i[1]),
          (t[e + 2] = i[2]),
          (t[e + 3] = i[3]),
          (t[e + 4] = i[4]),
          (t[e + 5] = i[5]),
          (t[e + 6] = i[6]),
          (t[e + 7] = i[7]),
          (t[e + 8] = i[8]),
          (t[e + 9] = i[9]),
          (t[e + 10] = i[10]),
          (t[e + 11] = i[11]),
          (t[e + 12] = i[12]),
          (t[e + 13] = i[13]),
          (t[e + 14] = i[14]),
          (t[e + 15] = i[15]),
          t
        );
      },
    }),
    Object.assign(r, {
      slerp: function (t, e, i, n) {
        return i.copy(t).slerp(e, n);
      },
      slerpFlat: function (t, e, i, n, r, a, o) {
        let s = i[n + 0],
          c = i[n + 1],
          h = i[n + 2],
          l = i[n + 3],
          u = r[a + 0],
          p = r[a + 1],
          d = r[a + 2],
          f = r[a + 3];
        if (l !== f || s !== u || c !== p || h !== d) {
          let m = 1 - o,
            v = s * u + c * p + h * d + l * f,
            g = v >= 0 ? 1 : -1,
            y = 1 - v * v;
          if (y > Number.EPSILON) {
            const x = Math.sqrt(y),
              b = Math.atan2(x, v * g);
            ((m = Math.sin(m * b) / x), (o = Math.sin(o * b) / x));
          }
          const _ = o * g;
          if (((s = s * m + u * _), (c = c * m + p * _), (h = h * m + d * _), (l = l * m + f * _), m === 1 - o)) {
            const w = 1 / Math.sqrt(s * s + c * c + h * h + l * l);
            ((s *= w), (c *= w), (h *= w), (l *= w));
          }
        }
        ((t[e] = s), (t[e + 1] = c), (t[e + 2] = h), (t[e + 3] = l));
      },
    }),
    Object.defineProperties(r.prototype, {
      x: {
        get: function () {
          return this._x;
        },
        set: function (t) {
          ((this._x = t), this.onChangeCallback());
        },
      },
      y: {
        get: function () {
          return this._y;
        },
        set: function (t) {
          ((this._y = t), this.onChangeCallback());
        },
      },
      z: {
        get: function () {
          return this._z;
        },
        set: function (t) {
          ((this._z = t), this.onChangeCallback());
        },
      },
      w: {
        get: function () {
          return this._w;
        },
        set: function (t) {
          ((this._w = t), this.onChangeCallback());
        },
      },
    }),
    Object.assign(r.prototype, {
      set: function (t, e, i, n) {
        return ((this._x = t), (this._y = e), (this._z = i), (this._w = n), this.onChangeCallback(), this);
      },
      clone: function () {
        return new this.constructor(this._x, this._y, this._z, this._w);
      },
      copy: function (t) {
        return ((this._x = t.x), (this._y = t.y), (this._z = t.z), (this._w = t.w), this.onChangeCallback(), this);
      },
      setFromEuler: function (t, e) {
        if (!t || !t.isEuler)
          throw new Error(
            'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.'
          );
        const i = t._x,
          n = t._y,
          r = t._z,
          a = t.order,
          o = Math.cos,
          s = Math.sin,
          c = o(i / 2),
          h = o(n / 2),
          l = o(r / 2),
          u = s(i / 2),
          p = s(n / 2),
          d = s(r / 2);
        return (
          'XYZ' === a
            ? ((this._x = u * h * l + c * p * d),
              (this._y = c * p * l - u * h * d),
              (this._z = c * h * d + u * p * l),
              (this._w = c * h * l - u * p * d))
            : 'YXZ' === a
              ? ((this._x = u * h * l + c * p * d),
                (this._y = c * p * l - u * h * d),
                (this._z = c * h * d - u * p * l),
                (this._w = c * h * l + u * p * d))
              : 'ZXY' === a
                ? ((this._x = u * h * l - c * p * d),
                  (this._y = c * p * l + u * h * d),
                  (this._z = c * h * d + u * p * l),
                  (this._w = c * h * l - u * p * d))
                : 'ZYX' === a
                  ? ((this._x = u * h * l - c * p * d),
                    (this._y = c * p * l + u * h * d),
                    (this._z = c * h * d - u * p * l),
                    (this._w = c * h * l + u * p * d))
                  : 'YZX' === a
                    ? ((this._x = u * h * l + c * p * d),
                      (this._y = c * p * l + u * h * d),
                      (this._z = c * h * d - u * p * l),
                      (this._w = c * h * l - u * p * d))
                    : 'XZY' === a &&
                      ((this._x = u * h * l - c * p * d),
                      (this._y = c * p * l - u * h * d),
                      (this._z = c * h * d + u * p * l),
                      (this._w = c * h * l + u * p * d)),
          !1 !== e && this.onChangeCallback(),
          this
        );
      },
      setFromAxisAngle: function (t, e) {
        const i = e / 2,
          n = Math.sin(i);
        return (
          (this._x = t.x * n),
          (this._y = t.y * n),
          (this._z = t.z * n),
          (this._w = Math.cos(i)),
          this.onChangeCallback(),
          this
        );
      },
      setFromRotationMatrix: function (t) {
        let e,
          i = t.elements,
          n = i[0],
          r = i[4],
          a = i[8],
          o = i[1],
          s = i[5],
          c = i[9],
          h = i[2],
          l = i[6],
          u = i[10],
          p = n + s + u;
        return (
          p > 0
            ? ((e = 0.5 / Math.sqrt(p + 1)),
              (this._w = 0.25 / e),
              (this._x = (l - c) * e),
              (this._y = (a - h) * e),
              (this._z = (o - r) * e))
            : n > s && n > u
              ? ((e = 2 * Math.sqrt(1 + n - s - u)),
                (this._w = (l - c) / e),
                (this._x = 0.25 * e),
                (this._y = (r + o) / e),
                (this._z = (a + h) / e))
              : s > u
                ? ((e = 2 * Math.sqrt(1 + s - n - u)),
                  (this._w = (a - h) / e),
                  (this._x = (r + o) / e),
                  (this._y = 0.25 * e),
                  (this._z = (c + l) / e))
                : ((e = 2 * Math.sqrt(1 + u - n - s)),
                  (this._w = (o - r) / e),
                  (this._x = (a + h) / e),
                  (this._y = (c + l) / e),
                  (this._z = 0.25 * e)),
          this.onChangeCallback(),
          this
        );
      },
      setFromUnitVectors: (function () {
        let t,
          e = new a();
        return function (i, n) {
          return (
            void 0 === e && (e = new a()),
            (t = i.dot(n) + 1) < 1e-6
              ? ((t = 0), Math.abs(i.x) > Math.abs(i.z) ? e.set(-i.y, i.x, 0) : e.set(0, -i.z, i.y))
              : e.crossVectors(i, n),
            (this._x = e.x),
            (this._y = e.y),
            (this._z = e.z),
            (this._w = t),
            this.normalize()
          );
        };
      })(),
      inverse: function () {
        return this.conjugate().normalize();
      },
      conjugate: function () {
        return ((this._x *= -1), (this._y *= -1), (this._z *= -1), this.onChangeCallback(), this);
      },
      dot: function (t) {
        return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
      },
      lengthSq: function () {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      },
      length: function () {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      },
      normalize: function () {
        let t = this.length();
        return (
          0 === t
            ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
            : ((t = 1 / t),
              (this._x = this._x * t),
              (this._y = this._y * t),
              (this._z = this._z * t),
              (this._w = this._w * t)),
          this.onChangeCallback(),
          this
        );
      },
      multiply: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.'
            ),
            this.multiplyQuaternions(t, e))
          : this.multiplyQuaternions(this, t);
      },
      premultiply: function (t) {
        return this.multiplyQuaternions(t, this);
      },
      multiplyQuaternions: function (t, e) {
        const i = t._x,
          n = t._y,
          r = t._z,
          a = t._w,
          o = e._x,
          s = e._y,
          c = e._z,
          h = e._w;
        return (
          (this._x = i * h + a * o + n * c - r * s),
          (this._y = n * h + a * s + r * o - i * c),
          (this._z = r * h + a * c + i * s - n * o),
          (this._w = a * h - i * o - n * s - r * c),
          this.onChangeCallback(),
          this
        );
      },
      slerp: function (t, e) {
        if (0 === e) return this;
        if (1 === e) return this.copy(t);
        let i = this._x,
          n = this._y,
          r = this._z,
          a = this._w,
          o = a * t._w + i * t._x + n * t._y + r * t._z;
        if (
          (o < 0
            ? ((this._w = -t._w), (this._x = -t._x), (this._y = -t._y), (this._z = -t._z), (o = -o))
            : this.copy(t),
          o >= 1)
        )
          return ((this._w = a), (this._x = i), (this._y = n), (this._z = r), this);
        const s = Math.sqrt(1 - o * o);
        if (Math.abs(s) < 0.001)
          return (
            (this._w = 0.5 * (a + this._w)),
            (this._x = 0.5 * (i + this._x)),
            (this._y = 0.5 * (n + this._y)),
            (this._z = 0.5 * (r + this._z)),
            this
          );
        const c = Math.atan2(s, o),
          h = Math.sin((1 - e) * c) / s,
          l = Math.sin(e * c) / s;
        return (
          (this._w = a * h + this._w * l),
          (this._x = i * h + this._x * l),
          (this._y = n * h + this._y * l),
          (this._z = r * h + this._z * l),
          this.onChangeCallback(),
          this
        );
      },
      equals: function (t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
      },
      fromArray: function (t, e) {
        return (
          void 0 === e && (e = 0),
          (this._x = t[e]),
          (this._y = t[e + 1]),
          (this._z = t[e + 2]),
          (this._w = t[e + 3]),
          this.onChangeCallback(),
          this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this._x),
          (t[e + 1] = this._y),
          (t[e + 2] = this._z),
          (t[e + 3] = this._w),
          t
        );
      },
      onChange: function (t) {
        return ((this.onChangeCallback = t), this);
      },
      onChangeCallback: function () {},
    }),
    Object.assign(a.prototype, {
      isVector3: !0,
      set: function (t, e, i) {
        return ((this.x = t), (this.y = e), (this.z = i), this);
      },
      setScalar: function (t) {
        return ((this.x = t), (this.y = t), (this.z = t), this);
      },
      setX: function (t) {
        return ((this.x = t), this);
      },
      setY: function (t) {
        return ((this.y = t), this);
      },
      setZ: function (t) {
        return ((this.z = t), this);
      },
      setComponent: function (t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          default:
            throw new Error('index is out of range: ' + t);
        }
        return this;
      },
      getComponent: function (t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error('index is out of range: ' + t);
        }
      },
      clone: function () {
        return new this.constructor(this.x, this.y, this.z);
      },
      copy: function (t) {
        return ((this.x = t.x), (this.y = t.y), (this.z = t.z), this);
      },
      add: function (t, e) {
        return void 0 !== e
          ? (console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'),
            this.addVectors(t, e))
          : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
      },
      addScalar: function (t) {
        return ((this.x += t), (this.y += t), (this.z += t), this);
      },
      addVectors: function (t, e) {
        return ((this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this);
      },
      addScaledVector: function (t, e) {
        return ((this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this);
      },
      sub: function (t, e) {
        return void 0 !== e
          ? (console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'),
            this.subVectors(t, e))
          : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
      },
      subScalar: function (t) {
        return ((this.x -= t), (this.y -= t), (this.z -= t), this);
      },
      subVectors: function (t, e) {
        return ((this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this);
      },
      multiply: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.'
            ),
            this.multiplyVectors(t, e))
          : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
      },
      multiplyScalar: function (t) {
        return ((this.x *= t), (this.y *= t), (this.z *= t), this);
      },
      multiplyVectors: function (t, e) {
        return ((this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this);
      },
      applyEuler: (function () {
        const t = new r();
        return function (e) {
          return (
            (e && e.isEuler) ||
              console.error(
                'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.'
              ),
            this.applyQuaternion(t.setFromEuler(e))
          );
        };
      })(),
      applyAxisAngle: (function () {
        const t = new r();
        return function (e, i) {
          return this.applyQuaternion(t.setFromAxisAngle(e, i));
        };
      })(),
      applyMatrix3: function (t) {
        const e = this.x,
          i = this.y,
          n = this.z,
          r = t.elements;
        return (
          (this.x = r[0] * e + r[3] * i + r[6] * n),
          (this.y = r[1] * e + r[4] * i + r[7] * n),
          (this.z = r[2] * e + r[5] * i + r[8] * n),
          this
        );
      },
      applyMatrix4: function (t) {
        const e = this.x,
          i = this.y,
          n = this.z,
          r = t.elements,
          a = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
        return (
          (this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * a),
          (this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * a),
          (this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * a),
          this
        );
      },
      applyQuaternion: function (t) {
        const e = this.x,
          i = this.y,
          n = this.z,
          r = t.x,
          a = t.y,
          o = t.z,
          s = t.w,
          c = s * e + a * n - o * i,
          h = s * i + o * e - r * n,
          l = s * n + r * i - a * e,
          u = -r * e - a * i - o * n;
        return (
          (this.x = c * s + u * -r + h * -o - l * -a),
          (this.y = h * s + u * -a + l * -r - c * -o),
          (this.z = l * s + u * -o + c * -a - h * -r),
          this
        );
      },
      project: (function () {
        const t = new n();
        return function (e) {
          return (t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)), this.applyMatrix4(t));
        };
      })(),
      unproject: (function () {
        const t = new n();
        return function (e) {
          return (t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)), this.applyMatrix4(t));
        };
      })(),
      transformDirection: function (t) {
        const e = this.x,
          i = this.y,
          n = this.z,
          r = t.elements;
        return (
          (this.x = r[0] * e + r[4] * i + r[8] * n),
          (this.y = r[1] * e + r[5] * i + r[9] * n),
          (this.z = r[2] * e + r[6] * i + r[10] * n),
          this.normalize()
        );
      },
      divide: function (t) {
        return ((this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this);
      },
      divideScalar: function (t) {
        return this.multiplyScalar(1 / t);
      },
      min: function (t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          (this.z = Math.min(this.z, t.z)),
          this
        );
      },
      max: function (t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          (this.z = Math.max(this.z, t.z)),
          this
        );
      },
      clamp: function (t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          (this.z = Math.max(t.z, Math.min(e.z, this.z))),
          this
        );
      },
      clampScalar: (function () {
        const t = new a(),
          e = new a();
        return function (i, n) {
          return (t.set(i, i, i), e.set(n, n, n), this.clamp(t, e));
        };
      })(),
      clampLength: function (t, e) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
      },
      floor: function () {
        return ((this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.z = Math.floor(this.z)), this);
      },
      ceil: function () {
        return ((this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), this);
      },
      round: function () {
        return ((this.x = Math.round(this.x)), (this.y = Math.round(this.y)), (this.z = Math.round(this.z)), this);
      },
      roundToZero: function () {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          this
        );
      },
      negate: function () {
        return ((this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this);
      },
      dot: function (t) {
        return this.x * t.x + this.y * t.y + this.z * t.z;
      },
      lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      },
      length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      },
      manhattanLength: function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      },
      normalize: function () {
        return this.divideScalar(this.length() || 1);
      },
      setLength: function (t) {
        return this.normalize().multiplyScalar(t);
      },
      lerp: function (t, e) {
        return ((this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), (this.z += (t.z - this.z) * e), this);
      },
      lerpVectors: function (t, e, i) {
        return this.subVectors(e, t).multiplyScalar(i).add(t);
      },
      cross: function (t, e) {
        return void 0 !== e
          ? (console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.'),
            this.crossVectors(t, e))
          : this.crossVectors(this, t);
      },
      crossVectors: function (t, e) {
        const i = t.x,
          n = t.y,
          r = t.z,
          a = e.x,
          o = e.y,
          s = e.z;
        return ((this.x = n * s - r * o), (this.y = r * a - i * s), (this.z = i * o - n * a), this);
      },
      projectOnVector: function (t) {
        const e = t.dot(this) / t.lengthSq();
        return this.copy(t).multiplyScalar(e);
      },
      projectOnPlane: (function () {
        const t = new a();
        return function (e) {
          return (t.copy(this).projectOnVector(e), this.sub(t));
        };
      })(),
      reflect: (function () {
        const t = new a();
        return function (e) {
          return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)));
        };
      })(),
      angleTo: function (t) {
        const e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
        return Math.acos(Wa.clamp(e, -1, 1));
      },
      distanceTo: function (t) {
        return Math.sqrt(this.distanceToSquared(t));
      },
      distanceToSquared: function (t) {
        const e = this.x - t.x,
          i = this.y - t.y,
          n = this.z - t.z;
        return e * e + i * i + n * n;
      },
      manhattanDistanceTo: function (t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
      },
      setFromSpherical: function (t) {
        const e = Math.sin(t.phi) * t.radius;
        return (
          (this.x = e * Math.sin(t.theta)),
          (this.y = Math.cos(t.phi) * t.radius),
          (this.z = e * Math.cos(t.theta)),
          this
        );
      },
      setFromCylindrical: function (t) {
        return ((this.x = t.radius * Math.sin(t.theta)), (this.y = t.y), (this.z = t.radius * Math.cos(t.theta)), this);
      },
      setFromMatrixPosition: function (t) {
        const e = t.elements;
        return ((this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this);
      },
      setFromMatrixScale: function (t) {
        const e = this.setFromMatrixColumn(t, 0).length(),
          i = this.setFromMatrixColumn(t, 1).length(),
          n = this.setFromMatrixColumn(t, 2).length();
        return ((this.x = e), (this.y = i), (this.z = n), this);
      },
      setFromMatrixColumn: function (t, e) {
        return this.fromArray(t.elements, 4 * e);
      },
      equals: function (t) {
        return t.x === this.x && t.y === this.y && t.z === this.z;
      },
      fromArray: function (t, e) {
        return (void 0 === e && (e = 0), (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this);
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this.x),
          (t[e + 1] = this.y),
          (t[e + 2] = this.z),
          t
        );
      },
      fromBufferAttribute: function (t, e, i) {
        return (
          void 0 !== i && console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().'),
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          (this.z = t.getZ(e)),
          this
        );
      },
    }),
    Object.assign(o.prototype, {
      isMatrix3: !0,
      set: function (t, e, i, n, r, a, o, s, c) {
        const h = this.elements;
        return (
          (h[0] = t),
          (h[1] = n),
          (h[2] = o),
          (h[3] = e),
          (h[4] = r),
          (h[5] = s),
          (h[6] = i),
          (h[7] = a),
          (h[8] = c),
          this
        );
      },
      identity: function () {
        return (this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this);
      },
      clone: function () {
        return new this.constructor().fromArray(this.elements);
      },
      copy: function (t) {
        const e = this.elements,
          i = t.elements;
        return (
          (e[0] = i[0]),
          (e[1] = i[1]),
          (e[2] = i[2]),
          (e[3] = i[3]),
          (e[4] = i[4]),
          (e[5] = i[5]),
          (e[6] = i[6]),
          (e[7] = i[7]),
          (e[8] = i[8]),
          this
        );
      },
      setFromMatrix4: function (t) {
        const e = t.elements;
        return (this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this);
      },
      applyToBufferAttribute: (function () {
        const t = new a();
        return function (e) {
          for (let i = 0, n = e.count; i < n; i++)
            ((t.x = e.getX(i)), (t.y = e.getY(i)), (t.z = e.getZ(i)), t.applyMatrix3(this), e.setXYZ(i, t.x, t.y, t.z));
          return e;
        };
      })(),
      multiply: function (t) {
        return this.multiplyMatrices(this, t);
      },
      premultiply: function (t) {
        return this.multiplyMatrices(t, this);
      },
      multiplyMatrices: function (t, e) {
        const i = t.elements,
          n = e.elements,
          r = this.elements,
          a = i[0],
          o = i[3],
          s = i[6],
          c = i[1],
          h = i[4],
          l = i[7],
          u = i[2],
          p = i[5],
          d = i[8],
          f = n[0],
          m = n[3],
          v = n[6],
          g = n[1],
          y = n[4],
          x = n[7],
          b = n[2],
          _ = n[5],
          w = n[8];
        return (
          (r[0] = a * f + o * g + s * b),
          (r[3] = a * m + o * y + s * _),
          (r[6] = a * v + o * x + s * w),
          (r[1] = c * f + h * g + l * b),
          (r[4] = c * m + h * y + l * _),
          (r[7] = c * v + h * x + l * w),
          (r[2] = u * f + p * g + d * b),
          (r[5] = u * m + p * y + d * _),
          (r[8] = u * v + p * x + d * w),
          this
        );
      },
      multiplyScalar: function (t) {
        const e = this.elements;
        return (
          (e[0] *= t),
          (e[3] *= t),
          (e[6] *= t),
          (e[1] *= t),
          (e[4] *= t),
          (e[7] *= t),
          (e[2] *= t),
          (e[5] *= t),
          (e[8] *= t),
          this
        );
      },
      determinant: function () {
        const t = this.elements,
          e = t[0],
          i = t[1],
          n = t[2],
          r = t[3],
          a = t[4],
          o = t[5],
          s = t[6],
          c = t[7],
          h = t[8];
        return e * a * h - e * o * c - i * r * h + i * o * s + n * r * c - n * a * s;
      },
      getInverse: function (t, e) {
        t && t.isMatrix4 && console.error('THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.');
        const i = t.elements,
          n = this.elements,
          r = i[0],
          a = i[1],
          o = i[2],
          s = i[3],
          c = i[4],
          h = i[5],
          l = i[6],
          u = i[7],
          p = i[8],
          d = p * c - h * u,
          f = h * l - p * s,
          m = u * s - c * l,
          v = r * d + a * f + o * m;
        if (0 === v) {
          const g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
          if (!0 === e) throw new Error(g);
          return (console.warn(g), this.identity());
        }
        const y = 1 / v;
        return (
          (n[0] = d * y),
          (n[1] = (o * u - p * a) * y),
          (n[2] = (h * a - o * c) * y),
          (n[3] = f * y),
          (n[4] = (p * r - o * l) * y),
          (n[5] = (o * s - h * r) * y),
          (n[6] = m * y),
          (n[7] = (a * l - u * r) * y),
          (n[8] = (c * r - a * s) * y),
          this
        );
      },
      transpose: function () {
        let t,
          e = this.elements;
        return (
          (t = e[1]),
          (e[1] = e[3]),
          (e[3] = t),
          (t = e[2]),
          (e[2] = e[6]),
          (e[6] = t),
          (t = e[5]),
          (e[5] = e[7]),
          (e[7] = t),
          this
        );
      },
      getNormalMatrix: function (t) {
        return this.setFromMatrix4(t).getInverse(this).transpose();
      },
      transposeIntoArray: function (t) {
        const e = this.elements;
        return (
          (t[0] = e[0]),
          (t[1] = e[3]),
          (t[2] = e[6]),
          (t[3] = e[1]),
          (t[4] = e[4]),
          (t[5] = e[7]),
          (t[6] = e[2]),
          (t[7] = e[5]),
          (t[8] = e[8]),
          this
        );
      },
      setUvTransform: function (t, e, i, n, r, a, o) {
        const s = Math.cos(r),
          c = Math.sin(r);
        this.set(i * s, i * c, -i * (s * a + c * o) + a + t, -n * c, n * s, -n * (-c * a + s * o) + o + e, 0, 0, 1);
      },
      scale: function (t, e) {
        const i = this.elements;
        return ((i[0] *= t), (i[3] *= t), (i[6] *= t), (i[1] *= e), (i[4] *= e), (i[7] *= e), this);
      },
      rotate: function (t) {
        const e = Math.cos(t),
          i = Math.sin(t),
          n = this.elements,
          r = n[0],
          a = n[3],
          o = n[6],
          s = n[1],
          c = n[4],
          h = n[7];
        return (
          (n[0] = e * r + i * s),
          (n[3] = e * a + i * c),
          (n[6] = e * o + i * h),
          (n[1] = -i * r + e * s),
          (n[4] = -i * a + e * c),
          (n[7] = -i * o + e * h),
          this
        );
      },
      translate: function (t, e) {
        const i = this.elements;
        return (
          (i[0] += t * i[2]),
          (i[3] += t * i[5]),
          (i[6] += t * i[8]),
          (i[1] += e * i[2]),
          (i[4] += e * i[5]),
          (i[7] += e * i[8]),
          this
        );
      },
      equals: function (t) {
        for (let e = this.elements, i = t.elements, n = 0; n < 9; n++) if (e[n] !== i[n]) return !1;
        return !0;
      },
      fromArray: function (t, e) {
        void 0 === e && (e = 0);
        for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
        return this;
      },
      toArray: function (t, e) {
        (void 0 === t && (t = []), void 0 === e && (e = 0));
        const i = this.elements;
        return (
          (t[e] = i[0]),
          (t[e + 1] = i[1]),
          (t[e + 2] = i[2]),
          (t[e + 3] = i[3]),
          (t[e + 4] = i[4]),
          (t[e + 5] = i[5]),
          (t[e + 6] = i[6]),
          (t[e + 7] = i[7]),
          (t[e + 8] = i[8]),
          t
        );
      },
    }));
  var Xa = 0;
  ((s.DEFAULT_IMAGE = void 0),
    (s.DEFAULT_MAPPING = 300),
    Object.defineProperty(s.prototype, 'needsUpdate', {
      set: function (t) {
        !0 === t && this.version++;
      },
    }),
    Object.assign(s.prototype, e.prototype, {
      constructor: s,
      isTexture: !0,
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (
          (this.name = t.name),
          (this.image = t.image),
          (this.mipmaps = t.mipmaps.slice(0)),
          (this.mapping = t.mapping),
          (this.wrapS = t.wrapS),
          (this.wrapT = t.wrapT),
          (this.magFilter = t.magFilter),
          (this.minFilter = t.minFilter),
          (this.anisotropy = t.anisotropy),
          (this.format = t.format),
          (this.type = t.type),
          this.offset.copy(t.offset),
          this.repeat.copy(t.repeat),
          this.center.copy(t.center),
          (this.rotation = t.rotation),
          (this.matrixAutoUpdate = t.matrixAutoUpdate),
          this.matrix.copy(t.matrix),
          (this.generateMipmaps = t.generateMipmaps),
          (this.premultiplyAlpha = t.premultiplyAlpha),
          (this.flipY = t.flipY),
          (this.unpackAlignment = t.unpackAlignment),
          (this.encoding = t.encoding),
          this
        );
      },
      toJSON: function (t) {
        const e = void 0 === t || 'string' == typeof t;
        if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
        const i = {
          metadata: { version: 4.5, type: 'Texture', generator: 'Texture.toJSON' },
          uuid: this.uuid,
          name: this.name,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
        };
        if (void 0 !== this.image) {
          const n = this.image;
          (void 0 === n.uuid && (n.uuid = Wa.generateUUID()),
            e ||
              void 0 !== t.images[n.uuid] ||
              (t.images[n.uuid] = {
                uuid: n.uuid,
                url: (function (t) {
                  let e;
                  if (t instanceof HTMLCanvasElement) e = t;
                  else {
                    (((e = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')).width = t.width),
                      (e.height = t.height));
                    const i = e.getContext('2d');
                    t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height);
                  }
                  return e.width > 2048 || e.height > 2048 ? e.toDataURL('image/jpeg', 0.6) : e.toDataURL('image/png');
                })(n),
              }),
            (i.image = n.uuid));
        }
        return (e || (t.textures[this.uuid] = i), i);
      },
      dispose: function () {
        this.dispatchEvent({ type: 'dispose' });
      },
      transformUv: function (t) {
        if (300 === this.mapping) {
          if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
            switch (this.wrapS) {
              case qr:
                t.x = t.x - Math.floor(t.x);
                break;
              case Yr:
                t.x = t.x < 0 ? 0 : 1;
                break;
              case Zr:
                1 === Math.abs(Math.floor(t.x) % 2) ? (t.x = Math.ceil(t.x) - t.x) : (t.x = t.x - Math.floor(t.x));
            }
          if (t.y < 0 || t.y > 1)
            switch (this.wrapT) {
              case qr:
                t.y = t.y - Math.floor(t.y);
                break;
              case Yr:
                t.y = t.y < 0 ? 0 : 1;
                break;
              case Zr:
                1 === Math.abs(Math.floor(t.y) % 2) ? (t.y = Math.ceil(t.y) - t.y) : (t.y = t.y - Math.floor(t.y));
            }
          this.flipY && (t.y = 1 - t.y);
        }
      },
    }),
    Object.assign(c.prototype, {
      isVector4: !0,
      set: function (t, e, i, n) {
        return ((this.x = t), (this.y = e), (this.z = i), (this.w = n), this);
      },
      setScalar: function (t) {
        return ((this.x = t), (this.y = t), (this.z = t), (this.w = t), this);
      },
      setX: function (t) {
        return ((this.x = t), this);
      },
      setY: function (t) {
        return ((this.y = t), this);
      },
      setZ: function (t) {
        return ((this.z = t), this);
      },
      setW: function (t) {
        return ((this.w = t), this);
      },
      setComponent: function (t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          case 3:
            this.w = e;
            break;
          default:
            throw new Error('index is out of range: ' + t);
        }
        return this;
      },
      getComponent: function (t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error('index is out of range: ' + t);
        }
      },
      clone: function () {
        return new this.constructor(this.x, this.y, this.z, this.w);
      },
      copy: function (t) {
        return ((this.x = t.x), (this.y = t.y), (this.z = t.z), (this.w = void 0 !== t.w ? t.w : 1), this);
      },
      add: function (t, e) {
        return void 0 !== e
          ? (console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'),
            this.addVectors(t, e))
          : ((this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this);
      },
      addScalar: function (t) {
        return ((this.x += t), (this.y += t), (this.z += t), (this.w += t), this);
      },
      addVectors: function (t, e) {
        return ((this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), (this.w = t.w + e.w), this);
      },
      addScaledVector: function (t, e) {
        return ((this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), (this.w += t.w * e), this);
      },
      sub: function (t, e) {
        return void 0 !== e
          ? (console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'),
            this.subVectors(t, e))
          : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this);
      },
      subScalar: function (t) {
        return ((this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this);
      },
      subVectors: function (t, e) {
        return ((this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), (this.w = t.w - e.w), this);
      },
      multiplyScalar: function (t) {
        return ((this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this);
      },
      applyMatrix4: function (t) {
        const e = this.x,
          i = this.y,
          n = this.z,
          r = this.w,
          a = t.elements;
        return (
          (this.x = a[0] * e + a[4] * i + a[8] * n + a[12] * r),
          (this.y = a[1] * e + a[5] * i + a[9] * n + a[13] * r),
          (this.z = a[2] * e + a[6] * i + a[10] * n + a[14] * r),
          (this.w = a[3] * e + a[7] * i + a[11] * n + a[15] * r),
          this
        );
      },
      divideScalar: function (t) {
        return this.multiplyScalar(1 / t);
      },
      setAxisAngleFromQuaternion: function (t) {
        this.w = 2 * Math.acos(t.w);
        const e = Math.sqrt(1 - t.w * t.w);
        return (
          e < 1e-4
            ? ((this.x = 1), (this.y = 0), (this.z = 0))
            : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
          this
        );
      },
      setAxisAngleFromRotationMatrix: function (t) {
        let e,
          i,
          n,
          r,
          a = t.elements,
          o = a[0],
          s = a[4],
          c = a[8],
          h = a[1],
          l = a[5],
          u = a[9],
          p = a[2],
          d = a[6],
          f = a[10];
        if (Math.abs(s - h) < 0.01 && Math.abs(c - p) < 0.01 && Math.abs(u - d) < 0.01) {
          if (Math.abs(s + h) < 0.1 && Math.abs(c + p) < 0.1 && Math.abs(u + d) < 0.1 && Math.abs(o + l + f - 3) < 0.1)
            return (this.set(1, 0, 0, 0), this);
          e = Math.PI;
          const m = (o + 1) / 2,
            v = (l + 1) / 2,
            g = (f + 1) / 2,
            y = (s + h) / 4,
            x = (c + p) / 4,
            b = (u + d) / 4;
          return (
            m > v && m > g
              ? m < 0.01
                ? ((i = 0), (n = 0.707106781), (r = 0.707106781))
                : ((n = y / (i = Math.sqrt(m))), (r = x / i))
              : v > g
                ? v < 0.01
                  ? ((i = 0.707106781), (n = 0), (r = 0.707106781))
                  : ((i = y / (n = Math.sqrt(v))), (r = b / n))
                : g < 0.01
                  ? ((i = 0.707106781), (n = 0.707106781), (r = 0))
                  : ((i = x / (r = Math.sqrt(g))), (n = b / r)),
            this.set(i, n, r, e),
            this
          );
        }
        let _ = Math.sqrt((d - u) * (d - u) + (c - p) * (c - p) + (h - s) * (h - s));
        return (
          Math.abs(_) < 0.001 && (_ = 1),
          (this.x = (d - u) / _),
          (this.y = (c - p) / _),
          (this.z = (h - s) / _),
          (this.w = Math.acos((o + l + f - 1) / 2)),
          this
        );
      },
      min: function (t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          (this.z = Math.min(this.z, t.z)),
          (this.w = Math.min(this.w, t.w)),
          this
        );
      },
      max: function (t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          (this.z = Math.max(this.z, t.z)),
          (this.w = Math.max(this.w, t.w)),
          this
        );
      },
      clamp: function (t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          (this.z = Math.max(t.z, Math.min(e.z, this.z))),
          (this.w = Math.max(t.w, Math.min(e.w, this.w))),
          this
        );
      },
      clampScalar: (function () {
        let t, e;
        return function (i, n) {
          return (
            void 0 === t && ((t = new c()), (e = new c())),
            t.set(i, i, i, i),
            e.set(n, n, n, n),
            this.clamp(t, e)
          );
        };
      })(),
      clampLength: function (t, e) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
      },
      floor: function () {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          (this.w = Math.floor(this.w)),
          this
        );
      },
      ceil: function () {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          (this.w = Math.ceil(this.w)),
          this
        );
      },
      round: function () {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          (this.w = Math.round(this.w)),
          this
        );
      },
      roundToZero: function () {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
          this
        );
      },
      negate: function () {
        return ((this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this);
      },
      dot: function (t) {
        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
      },
      lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      },
      length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      },
      manhattanLength: function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      },
      normalize: function () {
        return this.divideScalar(this.length() || 1);
      },
      setLength: function (t) {
        return this.normalize().multiplyScalar(t);
      },
      lerp: function (t, e) {
        return (
          (this.x += (t.x - this.x) * e),
          (this.y += (t.y - this.y) * e),
          (this.z += (t.z - this.z) * e),
          (this.w += (t.w - this.w) * e),
          this
        );
      },
      lerpVectors: function (t, e, i) {
        return this.subVectors(e, t).multiplyScalar(i).add(t);
      },
      equals: function (t) {
        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
      },
      fromArray: function (t, e) {
        return (
          void 0 === e && (e = 0),
          (this.x = t[e]),
          (this.y = t[e + 1]),
          (this.z = t[e + 2]),
          (this.w = t[e + 3]),
          this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this.x),
          (t[e + 1] = this.y),
          (t[e + 2] = this.z),
          (t[e + 3] = this.w),
          t
        );
      },
      fromBufferAttribute: function (t, e, i) {
        return (
          void 0 !== i && console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().'),
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          (this.z = t.getZ(e)),
          (this.w = t.getW(e)),
          this
        );
      },
    }),
    Object.assign(h.prototype, e.prototype, {
      isWebGLRenderTarget: !0,
      setSize: function (t, e) {
        ((this.width === t && this.height === e) || ((this.width = t), (this.height = e), this.dispose()),
          this.viewport.set(0, 0, t, e),
          this.scissor.set(0, 0, t, e));
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (
          (this.width = t.width),
          (this.height = t.height),
          this.viewport.copy(t.viewport),
          (this.texture = t.texture.clone()),
          (this.depthBuffer = t.depthBuffer),
          (this.stencilBuffer = t.stencilBuffer),
          (this.depthTexture = t.depthTexture),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: 'dispose' });
      },
    }),
    ((l.prototype = Object.create(h.prototype)).constructor = l),
    (l.prototype.isWebGLRenderTargetCube = !0),
    ((u.prototype = Object.create(s.prototype)).constructor = u),
    (u.prototype.isDataTexture = !0),
    ((p.prototype = Object.create(s.prototype)).constructor = p),
    (p.prototype.isCubeTexture = !0),
    Object.defineProperty(p.prototype, 'images', {
      get: function () {
        return this.image;
      },
      set: function (t) {
        this.image = t;
      },
    }));
  var qa = new s(),
    Ya = new p(),
    Za = [],
    Qa = [],
    Ja = new Float32Array(16),
    Ka = new Float32Array(9);
  x.prototype.setValue = function (t, e) {
    for (let i = this.seq, n = 0, r = i.length; n !== r; ++n) {
      const a = i[n];
      a.setValue(t, e[a.id]);
    }
  };
  var $a = /([\w\d_]+)(\])?(\[|\.)?/g;
  ((_.prototype.setValue = function (t, e, i) {
    const n = this.map[e];
    void 0 !== n && n.setValue(t, i, this.renderer);
  }),
    (_.prototype.setOptional = function (t, e, i) {
      const n = e[i];
      void 0 !== n && this.setValue(t, i, n);
    }),
    (_.upload = function (t, e, i, n) {
      for (let r = 0, a = e.length; r !== a; ++r) {
        const o = e[r],
          s = i[o.id];
        !1 !== s.needsUpdate && o.setValue(t, s.value, n);
      }
    }),
    (_.seqWithValue = function (t, e) {
      for (var i = [], n = 0, r = t.length; n !== r; ++n) {
        const a = t[n];
        a.id in e && i.push(a);
      }
      return i;
    }));
  const to = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  };
  Object.assign(w.prototype, {
    isColor: !0,
    r: 1,
    g: 1,
    b: 1,
    set: function (t) {
      return (
        t && t.isColor
          ? this.copy(t)
          : 'number' == typeof t
            ? this.setHex(t)
            : 'string' == typeof t && this.setStyle(t),
        this
      );
    },
    setScalar: function (t) {
      return ((this.r = t), (this.g = t), (this.b = t), this);
    },
    setHex: function (t) {
      return (
        (t = Math.floor(t)),
        (this.r = ((t >> 16) & 255) / 255),
        (this.g = ((t >> 8) & 255) / 255),
        (this.b = (255 & t) / 255),
        this
      );
    },
    setRGB: function (t, e, i) {
      return ((this.r = t), (this.g = e), (this.b = i), this);
    },
    setHSL: (function () {
      function t(t, e, i) {
        return (
          i < 0 && (i += 1),
          i > 1 && (i -= 1),
          i < 1 / 6 ? t + 6 * (e - t) * i : i < 0.5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
        );
      }
      return function (e, i, n) {
        if (((e = Wa.euclideanModulo(e, 1)), (i = Wa.clamp(i, 0, 1)), (n = Wa.clamp(n, 0, 1)), 0 === i))
          this.r = this.g = this.b = n;
        else {
          const r = n <= 0.5 ? n * (1 + i) : n + i - n * i,
            a = 2 * n - r;
          ((this.r = t(a, r, e + 1 / 3)), (this.g = t(a, r, e)), (this.b = t(a, r, e - 1 / 3)));
        }
        return this;
      };
    })(),
    setStyle: function (t) {
      function e(e) {
        void 0 !== e && parseFloat(e) < 1 && console.warn('THREE.Color: Alpha component of ' + t + ' will be ignored.');
      }
      let i;
      if ((i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t))) {
        let n,
          r = i[1],
          a = i[2];
        switch (r) {
          case 'rgb':
          case 'rgba':
            if ((n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)))
              return (
                (this.r = Math.min(255, parseInt(n[1], 10)) / 255),
                (this.g = Math.min(255, parseInt(n[2], 10)) / 255),
                (this.b = Math.min(255, parseInt(n[3], 10)) / 255),
                e(n[5]),
                this
              );
            if ((n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)))
              return (
                (this.r = Math.min(100, parseInt(n[1], 10)) / 100),
                (this.g = Math.min(100, parseInt(n[2], 10)) / 100),
                (this.b = Math.min(100, parseInt(n[3], 10)) / 100),
                e(n[5]),
                this
              );
            break;
          case 'hsl':
          case 'hsla':
            if ((n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))) {
              const o = parseFloat(n[1]) / 360,
                s = parseInt(n[2], 10) / 100,
                c = parseInt(n[3], 10) / 100;
              return (e(n[5]), this.setHSL(o, s, c));
            }
        }
      } else if ((i = /^\#([A-Fa-f0-9]+)$/.exec(t))) {
        const h = (l = i[1]).length;
        if (3 === h)
          return (
            (this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255),
            (this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255),
            (this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255),
            this
          );
        if (6 === h)
          return (
            (this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255),
            (this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255),
            (this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255),
            this
          );
      }
      if (t && t.length > 0) {
        var l = to[t];
        void 0 !== l ? this.setHex(l) : console.warn('THREE.Color: Unknown color ' + t);
      }
      return this;
    },
    clone: function () {
      return new this.constructor(this.r, this.g, this.b);
    },
    copy: function (t) {
      return ((this.r = t.r), (this.g = t.g), (this.b = t.b), this);
    },
    copyGammaToLinear: function (t, e) {
      return (
        void 0 === e && (e = 2),
        (this.r = Math.pow(t.r, e)),
        (this.g = Math.pow(t.g, e)),
        (this.b = Math.pow(t.b, e)),
        this
      );
    },
    copyLinearToGamma: function (t, e) {
      void 0 === e && (e = 2);
      const i = e > 0 ? 1 / e : 1;
      return ((this.r = Math.pow(t.r, i)), (this.g = Math.pow(t.g, i)), (this.b = Math.pow(t.b, i)), this);
    },
    convertGammaToLinear: function () {
      const t = this.r,
        e = this.g,
        i = this.b;
      return ((this.r = t * t), (this.g = e * e), (this.b = i * i), this);
    },
    convertLinearToGamma: function () {
      return ((this.r = Math.sqrt(this.r)), (this.g = Math.sqrt(this.g)), (this.b = Math.sqrt(this.b)), this);
    },
    getHex: function () {
      return ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0);
    },
    getHexString: function () {
      return ('000000' + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function (t) {
      let e,
        i,
        n = t || { h: 0, s: 0, l: 0 },
        r = this.r,
        a = this.g,
        o = this.b,
        s = Math.max(r, a, o),
        c = Math.min(r, a, o),
        h = (c + s) / 2;
      if (c === s) ((e = 0), (i = 0));
      else {
        const l = s - c;
        switch (((i = h <= 0.5 ? l / (s + c) : l / (2 - s - c)), s)) {
          case r:
            e = (a - o) / l + (a < o ? 6 : 0);
            break;
          case a:
            e = (o - r) / l + 2;
            break;
          case o:
            e = (r - a) / l + 4;
        }
        e /= 6;
      }
      return ((n.h = e), (n.s = i), (n.l = h), n);
    },
    getStyle: function () {
      return 'rgb(' + ((255 * this.r) | 0) + ',' + ((255 * this.g) | 0) + ',' + ((255 * this.b) | 0) + ')';
    },
    offsetHSL: function (t, e, i) {
      const n = this.getHSL();
      return ((n.h += t), (n.s += e), (n.l += i), this.setHSL(n.h, n.s, n.l), this);
    },
    add: function (t) {
      return ((this.r += t.r), (this.g += t.g), (this.b += t.b), this);
    },
    addColors: function (t, e) {
      return ((this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this);
    },
    addScalar: function (t) {
      return ((this.r += t), (this.g += t), (this.b += t), this);
    },
    sub: function (t) {
      return (
        (this.r = Math.max(0, this.r - t.r)),
        (this.g = Math.max(0, this.g - t.g)),
        (this.b = Math.max(0, this.b - t.b)),
        this
      );
    },
    multiply: function (t) {
      return ((this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this);
    },
    multiplyScalar: function (t) {
      return ((this.r *= t), (this.g *= t), (this.b *= t), this);
    },
    lerp: function (t, e) {
      return ((this.r += (t.r - this.r) * e), (this.g += (t.g - this.g) * e), (this.b += (t.b - this.b) * e), this);
    },
    equals: function (t) {
      return t.r === this.r && t.g === this.g && t.b === this.b;
    },
    fromArray: function (t, e) {
      return (void 0 === e && (e = 0), (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this);
    },
    toArray: function (t, e) {
      return (
        void 0 === t && (t = []),
        void 0 === e && (e = 0),
        (t[e] = this.r),
        (t[e + 1] = this.g),
        (t[e + 2] = this.b),
        t
      );
    },
    toJSON: function () {
      return this.getHex();
    },
  });
  var eo = {
      common: {
        diffuse: { value: new w(15658734) },
        opacity: { value: 1 },
        map: { value: null },
        uvTransform: { value: new o() },
        alphaMap: { value: null },
      },
      specularmap: { specularMap: { value: null } },
      envmap: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1 },
        refractionRatio: { value: 0.98 },
      },
      aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
      lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
      emissivemap: { emissiveMap: { value: null } },
      bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
      normalmap: { normalMap: { value: null }, normalScale: { value: new i(1, 1) } },
      displacementmap: {
        displacementMap: { value: null },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 },
      },
      roughnessmap: { roughnessMap: { value: null } },
      metalnessmap: { metalnessMap: { value: null } },
      gradientmap: { gradientMap: { value: null } },
      fog: {
        fogDensity: { value: 25e-5 },
        fogNear: { value: 1 },
        fogFar: { value: 2e3 },
        fogColor: { value: new w(16777215) },
      },
      lights: {
        ambientLightColor: { value: [] },
        directionalLights: {
          value: [],
          properties: { direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} },
        },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {},
            shadow: {},
            shadowBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        spotShadowMap: { value: [] },
        spotShadowMatrix: { value: [] },
        pointLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            decay: {},
            distance: {},
            shadow: {},
            shadowBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {},
          },
        },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
        rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
      },
      points: {
        diffuse: { value: new w(15658734) },
        opacity: { value: 1 },
        size: { value: 1 },
        scale: { value: 1 },
        map: { value: null },
        uvTransform: { value: new o() },
      },
    },
    io = {
      merge: function (t) {
        for (var e = {}, i = 0; i < t.length; i++) {
          const n = this.clone(t[i]);
          for (const r in n) e[r] = n[r];
        }
        return e;
      },
      clone: function (t) {
        const e = {};
        for (const i in t) {
          e[i] = {};
          for (const n in t[i]) {
            const r = t[i][n];
            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture)
              ? (e[i][n] = r.clone())
              : Array.isArray(r)
                ? (e[i][n] = r.slice())
                : (e[i][n] = r);
          }
        }
        return e;
      },
    },
    no = {
      alphamap_fragment: '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n',
      alphamap_pars_fragment: '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n',
      alphatest_fragment: '#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n',
      aomap_fragment:
        '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n',
      aomap_pars_fragment: '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',
      begin_vertex: '\nvec3 transformed = vec3( position );\n',
      beginnormal_vertex: '\nvec3 objectNormal = vec3( normal );\n',
      bsdfs:
        'float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n',
      bumpmap_pars_fragment:
        '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n',
      clipping_planes_fragment:
        '#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n',
      clipping_planes_pars_fragment:
        '#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n',
      clipping_planes_pars_vertex:
        '#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n',
      clipping_planes_vertex:
        '#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n',
      color_fragment: '#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif',
      color_pars_fragment: '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n',
      color_pars_vertex: '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif',
      color_vertex: '#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif',
      common:
        '#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n',
      cube_uv_reflection_fragment:
        '#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n',
      defaultnormal_vertex:
        'vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n',
      displacementmap_pars_vertex:
        '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n',
      displacementmap_vertex:
        '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n',
      emissivemap_fragment:
        '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n',
      emissivemap_pars_fragment: '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n',
      encodings_fragment: '  gl_FragColor = linearToOutputTexel( gl_FragColor );\n',
      encodings_pars_fragment:
        '\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n',
      envmap_fragment:
        '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n',
      envmap_pars_fragment:
        '#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n',
      envmap_pars_vertex:
        '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n',
      envmap_vertex:
        '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n',
      fog_vertex: '\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif',
      fog_pars_vertex: '#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n',
      fog_fragment:
        '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n',
      fog_pars_fragment:
        '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n',
      gradientmap_pars_fragment:
        '#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n',
      lightmap_fragment:
        '#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n',
      lightmap_pars_fragment:
        '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',
      lights_lambert_vertex:
        'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n',
      lights_pars:
        'uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n',
      lights_phong_fragment:
        'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n',
      lights_phong_pars_fragment:
        'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n',
      lights_physical_fragment:
        'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n',
      lights_physical_pars_fragment:
        'struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n',
      lights_template:
        '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n',
      logdepthbuf_fragment:
        '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
      logdepthbuf_pars_fragment:
        '#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n',
      logdepthbuf_pars_vertex:
        '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif',
      logdepthbuf_vertex:
        '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n',
      map_fragment:
        '#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n',
      map_pars_fragment: '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n',
      map_particle_fragment:
        '#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n',
      map_particle_pars_fragment: '#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n',
      metalnessmap_fragment:
        'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n',
      metalnessmap_pars_fragment: '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',
      morphnormal_vertex:
        '#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n',
      morphtarget_pars_vertex:
        '#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif',
      morphtarget_vertex:
        '#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n',
      normal_fragment:
        '#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n',
      normalmap_pars_fragment:
        '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n',
      packing:
        'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n',
      premultiplied_alpha_fragment: '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n',
      project_vertex:
        'vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n',
      dithering_fragment: '#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n',
      dithering_pars_fragment:
        '#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n',
      roughnessmap_fragment:
        'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n',
      roughnessmap_pars_fragment: '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',
      shadowmap_pars_fragment:
        '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n',
      shadowmap_pars_vertex:
        '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n',
      shadowmap_vertex:
        '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n',
      shadowmask_pars_fragment:
        'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n',
      skinbase_vertex:
        '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
      skinning_pars_vertex:
        '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n',
      skinning_vertex:
        '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n',
      skinnormal_vertex:
        '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n',
      specularmap_fragment:
        'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
      specularmap_pars_fragment: '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
      tonemapping_fragment:
        '#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n',
      tonemapping_pars_fragment:
        '#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n',
      uv_pars_fragment:
        '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif',
      uv_pars_vertex:
        '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n',
      uv_vertex:
        '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif',
      uv2_pars_fragment: '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif',
      uv2_pars_vertex:
        '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif',
      uv2_vertex: '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif',
      worldpos_vertex:
        '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n',
      cube_frag:
        'uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n',
      cube_vert:
        'varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n',
      depth_frag:
        '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n',
      depth_vert:
        '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n',
      distanceRGBA_frag:
        '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n',
      distanceRGBA_vert:
        '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n',
      equirect_frag:
        'uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n',
      equirect_vert:
        'varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n',
      linedashed_frag:
        'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',
      linedashed_vert:
        'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n',
      meshbasic_frag:
        'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',
      meshbasic_vert:
        '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n',
      meshlambert_frag:
        'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n',
      meshlambert_vert:
        '#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',
      meshphong_frag:
        '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n',
      meshphong_vert:
        '#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',
      meshphysical_frag:
        '#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n',
      meshphysical_vert:
        '#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',
      normal_frag:
        '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n',
      normal_vert:
        '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n',
      points_frag:
        'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',
      points_vert:
        'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',
      shadow_frag:
        'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n',
      shadow_vert:
        '#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',
    },
    ro = {
      basic: {
        uniforms: io.merge([eo.common, eo.specularmap, eo.envmap, eo.aomap, eo.lightmap, eo.fog]),
        vertexShader: no.meshbasic_vert,
        fragmentShader: no.meshbasic_frag,
      },
      lambert: {
        uniforms: io.merge([
          eo.common,
          eo.specularmap,
          eo.envmap,
          eo.aomap,
          eo.lightmap,
          eo.emissivemap,
          eo.fog,
          eo.lights,
          { emissive: { value: new w(0) } },
        ]),
        vertexShader: no.meshlambert_vert,
        fragmentShader: no.meshlambert_frag,
      },
      phong: {
        uniforms: io.merge([
          eo.common,
          eo.specularmap,
          eo.envmap,
          eo.aomap,
          eo.lightmap,
          eo.emissivemap,
          eo.bumpmap,
          eo.normalmap,
          eo.displacementmap,
          eo.gradientmap,
          eo.fog,
          eo.lights,
          { emissive: { value: new w(0) }, specular: { value: new w(1118481) }, shininess: { value: 30 } },
        ]),
        vertexShader: no.meshphong_vert,
        fragmentShader: no.meshphong_frag,
      },
      standard: {
        uniforms: io.merge([
          eo.common,
          eo.envmap,
          eo.aomap,
          eo.lightmap,
          eo.emissivemap,
          eo.bumpmap,
          eo.normalmap,
          eo.displacementmap,
          eo.roughnessmap,
          eo.metalnessmap,
          eo.fog,
          eo.lights,
          {
            emissive: { value: new w(0) },
            roughness: { value: 0.5 },
            metalness: { value: 0.5 },
            envMapIntensity: { value: 1 },
          },
        ]),
        vertexShader: no.meshphysical_vert,
        fragmentShader: no.meshphysical_frag,
      },
      points: { uniforms: io.merge([eo.points, eo.fog]), vertexShader: no.points_vert, fragmentShader: no.points_frag },
      dashed: {
        uniforms: io.merge([
          eo.common,
          eo.fog,
          { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } },
        ]),
        vertexShader: no.linedashed_vert,
        fragmentShader: no.linedashed_frag,
      },
      depth: {
        uniforms: io.merge([eo.common, eo.displacementmap]),
        vertexShader: no.depth_vert,
        fragmentShader: no.depth_frag,
      },
      normal: {
        uniforms: io.merge([eo.common, eo.bumpmap, eo.normalmap, eo.displacementmap, { opacity: { value: 1 } }]),
        vertexShader: no.normal_vert,
        fragmentShader: no.normal_frag,
      },
      cube: {
        uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } },
        vertexShader: no.cube_vert,
        fragmentShader: no.cube_frag,
      },
      equirect: {
        uniforms: { tEquirect: { value: null } },
        vertexShader: no.equirect_vert,
        fragmentShader: no.equirect_frag,
      },
      distanceRGBA: {
        uniforms: io.merge([
          eo.common,
          eo.displacementmap,
          { referencePosition: { value: new a() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } },
        ]),
        vertexShader: no.distanceRGBA_vert,
        fragmentShader: no.distanceRGBA_frag,
      },
      shadow: {
        uniforms: io.merge([eo.lights, eo.fog, { color: { value: new w(0) }, opacity: { value: 1 } }]),
        vertexShader: no.shadow_vert,
        fragmentShader: no.shadow_frag,
      },
    };
  ((ro.physical = {
    uniforms: io.merge([ro.standard.uniforms, { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } }]),
    vertexShader: no.meshphysical_vert,
    fragmentShader: no.meshphysical_frag,
  }),
    Object.assign(E.prototype, {
      set: function (t, e) {
        return (this.min.copy(t), this.max.copy(e), this);
      },
      setFromPoints: function (t) {
        this.makeEmpty();
        for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
        return this;
      },
      setFromCenterAndSize: (function () {
        const t = new i();
        return function (e, i) {
          const n = t.copy(i).multiplyScalar(0.5);
          return (this.min.copy(e).sub(n), this.max.copy(e).add(n), this);
        };
      })(),
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (this.min.copy(t.min), this.max.copy(t.max), this);
      },
      makeEmpty: function () {
        return ((this.min.x = this.min.y = 1 / 0), (this.max.x = this.max.y = -1 / 0), this);
      },
      isEmpty: function () {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      },
      getCenter: function (t) {
        const e = t || new i();
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
      },
      getSize: function (t) {
        const e = t || new i();
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
      },
      expandByPoint: function (t) {
        return (this.min.min(t), this.max.max(t), this);
      },
      expandByVector: function (t) {
        return (this.min.sub(t), this.max.add(t), this);
      },
      expandByScalar: function (t) {
        return (this.min.addScalar(-t), this.max.addScalar(t), this);
      },
      containsPoint: function (t) {
        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y);
      },
      containsBox: function (t) {
        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y;
      },
      getParameter: function (t, e) {
        return (e || new i()).set(
          (t.x - this.min.x) / (this.max.x - this.min.x),
          (t.y - this.min.y) / (this.max.y - this.min.y)
        );
      },
      intersectsBox: function (t) {
        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y);
      },
      clampPoint: function (t, e) {
        return (e || new i()).copy(t).clamp(this.min, this.max);
      },
      distanceToPoint: (function () {
        const t = new i();
        return function (e) {
          return t.copy(e).clamp(this.min, this.max).sub(e).length();
        };
      })(),
      intersect: function (t) {
        return (this.min.max(t.min), this.max.min(t.max), this);
      },
      union: function (t) {
        return (this.min.min(t.min), this.max.max(t.max), this);
      },
      translate: function (t) {
        return (this.min.add(t), this.max.add(t), this);
      },
      equals: function (t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      },
    }),
    ((M.prototype = Object.create(s.prototype)).constructor = M));
  var ao = 0;
  (Object.assign(T.prototype, e.prototype, {
    isMaterial: !0,
    onBeforeCompile: function () {},
    setValues: function (t) {
      if (void 0 !== t)
        for (const e in t) {
          const i = t[e];
          if (void 0 !== i)
            if ('shading' !== e) {
              const n = this[e];
              void 0 !== n
                ? n && n.isColor
                  ? n.set(i)
                  : n && n.isVector3 && i && i.isVector3
                    ? n.copy(i)
                    : (this[e] = 'overdraw' === e ? Number(i) : i)
                : console.warn('THREE.' + this.type + ": '" + e + "' is not a property of this material.");
            } else
              (console.warn(
                'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.'
              ),
                (this.flatShading = 1 === i));
          else console.warn("THREE.Material: '" + e + "' parameter is undefined.");
        }
    },
    toJSON: function (t) {
      function e(t) {
        const e = [];
        for (const i in t) {
          const n = t[i];
          (delete n.metadata, e.push(n));
        }
        return e;
      }
      const i = void 0 === t || 'string' == typeof t;
      i && (t = { textures: {}, images: {} });
      const n = { metadata: { version: 4.5, type: 'Material', generator: 'Material.toJSON' } };
      if (
        ((n.uuid = this.uuid),
        (n.type = this.type),
        '' !== this.name && (n.name = this.name),
        this.color && this.color.isColor && (n.color = this.color.getHex()),
        void 0 !== this.roughness && (n.roughness = this.roughness),
        void 0 !== this.metalness && (n.metalness = this.metalness),
        this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
        1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
        void 0 !== this.shininess && (n.shininess = this.shininess),
        void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat),
        void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness),
        this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
        this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
        this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid),
        this.bumpMap &&
          this.bumpMap.isTexture &&
          ((n.bumpMap = this.bumpMap.toJSON(t).uuid), (n.bumpScale = this.bumpScale)),
        this.normalMap &&
          this.normalMap.isTexture &&
          ((n.normalMap = this.normalMap.toJSON(t).uuid), (n.normalScale = this.normalScale.toArray())),
        this.displacementMap &&
          this.displacementMap.isTexture &&
          ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
          (n.displacementScale = this.displacementScale),
          (n.displacementBias = this.displacementBias)),
        this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
        this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid),
        this.envMap &&
          this.envMap.isTexture &&
          ((n.envMap = this.envMap.toJSON(t).uuid), (n.reflectivity = this.reflectivity)),
        this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid),
        void 0 !== this.size && (n.size = this.size),
        void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
        this.blending !== nr && (n.blending = this.blending),
        !0 === this.flatShading && (n.flatShading = this.flatShading),
        this.side !== Qn && (n.side = this.side),
        this.vertexColors !== $n && (n.vertexColors = this.vertexColors),
        this.opacity < 1 && (n.opacity = this.opacity),
        !0 === this.transparent && (n.transparent = this.transparent),
        (n.depthFunc = this.depthFunc),
        (n.depthTest = this.depthTest),
        (n.depthWrite = this.depthWrite),
        0 !== this.rotation && (n.rotation = this.rotation),
        1 !== this.linewidth && (n.linewidth = this.linewidth),
        void 0 !== this.dashSize && (n.dashSize = this.dashSize),
        void 0 !== this.gapSize && (n.gapSize = this.gapSize),
        void 0 !== this.scale && (n.scale = this.scale),
        !0 === this.dithering && (n.dithering = !0),
        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
        !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
        !0 === this.wireframe && (n.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
        'round' !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
        'round' !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
        !0 === this.morphTargets && (n.morphTargets = !0),
        !0 === this.skinning && (n.skinning = !0),
        !1 === this.visible && (n.visible = !1),
        '{}' !== JSON.stringify(this.userData) && (n.userData = this.userData),
        i)
      ) {
        const r = e(t.textures),
          a = e(t.images);
        (r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a));
      }
      return n;
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    copy: function (t) {
      ((this.name = t.name),
        (this.fog = t.fog),
        (this.lights = t.lights),
        (this.blending = t.blending),
        (this.side = t.side),
        (this.flatShading = t.flatShading),
        (this.vertexColors = t.vertexColors),
        (this.opacity = t.opacity),
        (this.transparent = t.transparent),
        (this.blendSrc = t.blendSrc),
        (this.blendDst = t.blendDst),
        (this.blendEquation = t.blendEquation),
        (this.blendSrcAlpha = t.blendSrcAlpha),
        (this.blendDstAlpha = t.blendDstAlpha),
        (this.blendEquationAlpha = t.blendEquationAlpha),
        (this.depthFunc = t.depthFunc),
        (this.depthTest = t.depthTest),
        (this.depthWrite = t.depthWrite),
        (this.colorWrite = t.colorWrite),
        (this.precision = t.precision),
        (this.polygonOffset = t.polygonOffset),
        (this.polygonOffsetFactor = t.polygonOffsetFactor),
        (this.polygonOffsetUnits = t.polygonOffsetUnits),
        (this.dithering = t.dithering),
        (this.alphaTest = t.alphaTest),
        (this.premultipliedAlpha = t.premultipliedAlpha),
        (this.overdraw = t.overdraw),
        (this.visible = t.visible),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        (this.clipShadows = t.clipShadows),
        (this.clipIntersection = t.clipIntersection));
      let e = t.clippingPlanes,
        i = null;
      if (null !== e) {
        const n = e.length;
        i = new Array(n);
        for (let r = 0; r !== n; ++r) i[r] = e[r].clone();
      }
      return ((this.clippingPlanes = i), this);
    },
    dispose: function () {
      this.dispatchEvent({ type: 'dispose' });
    },
  }),
    ((S.prototype = Object.create(T.prototype)).constructor = S),
    (S.prototype.isMeshDepthMaterial = !0),
    (S.prototype.copy = function (t) {
      return (
        T.prototype.copy.call(this, t),
        (this.depthPacking = t.depthPacking),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        this
      );
    }),
    ((A.prototype = Object.create(T.prototype)).constructor = A),
    (A.prototype.isMeshDistanceMaterial = !0),
    (A.prototype.copy = function (t) {
      return (
        T.prototype.copy.call(this, t),
        this.referencePosition.copy(t.referencePosition),
        (this.nearDistance = t.nearDistance),
        (this.farDistance = t.farDistance),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        this
      );
    }),
    Object.assign(R.prototype, {
      isBox3: !0,
      set: function (t, e) {
        return (this.min.copy(t), this.max.copy(e), this);
      },
      setFromArray: function (t) {
        for (
          var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = t.length;
          s < c;
          s += 3
        ) {
          const h = t[s],
            l = t[s + 1],
            u = t[s + 2];
          (h < e && (e = h), l < i && (i = l), u < n && (n = u), h > r && (r = h), l > a && (a = l), u > o && (o = u));
        }
        return (this.min.set(e, i, n), this.max.set(r, a, o), this);
      },
      setFromBufferAttribute: function (t) {
        for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = t.count; s < c; s++) {
          const h = t.getX(s),
            l = t.getY(s),
            u = t.getZ(s);
          (h < e && (e = h), l < i && (i = l), u < n && (n = u), h > r && (r = h), l > a && (a = l), u > o && (o = u));
        }
        return (this.min.set(e, i, n), this.max.set(r, a, o), this);
      },
      setFromPoints: function (t) {
        this.makeEmpty();
        for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
        return this;
      },
      setFromCenterAndSize: (function () {
        const t = new a();
        return function (e, i) {
          const n = t.copy(i).multiplyScalar(0.5);
          return (this.min.copy(e).sub(n), this.max.copy(e).add(n), this);
        };
      })(),
      setFromObject: function (t) {
        return (this.makeEmpty(), this.expandByObject(t));
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (this.min.copy(t.min), this.max.copy(t.max), this);
      },
      makeEmpty: function () {
        return ((this.min.x = this.min.y = this.min.z = 1 / 0), (this.max.x = this.max.y = this.max.z = -1 / 0), this);
      },
      isEmpty: function () {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
      },
      getCenter: function (t) {
        const e = t || new a();
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
      },
      getSize: function (t) {
        const e = t || new a();
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
      },
      expandByPoint: function (t) {
        return (this.min.min(t), this.max.max(t), this);
      },
      expandByVector: function (t) {
        return (this.min.sub(t), this.max.add(t), this);
      },
      expandByScalar: function (t) {
        return (this.min.addScalar(-t), this.max.addScalar(t), this);
      },
      expandByObject: (function () {
        let t,
          e,
          i,
          n = new a();
        return function (r) {
          return (
            (t = this),
            r.updateMatrixWorld(!0),
            r.traverse(function (r) {
              const a = r.geometry;
              if (void 0 !== a)
                if (a.isGeometry) {
                  const o = a.vertices;
                  for (e = 0, i = o.length; e < i; e++)
                    (n.copy(o[e]), n.applyMatrix4(r.matrixWorld), t.expandByPoint(n));
                } else if (a.isBufferGeometry) {
                  const s = a.attributes.position;
                  if (void 0 !== s)
                    for (e = 0, i = s.count; e < i; e++)
                      (n.fromBufferAttribute(s, e).applyMatrix4(r.matrixWorld), t.expandByPoint(n));
                }
            }),
            this
          );
        };
      })(),
      containsPoint: function (t) {
        return !(
          t.x < this.min.x ||
          t.x > this.max.x ||
          t.y < this.min.y ||
          t.y > this.max.y ||
          t.z < this.min.z ||
          t.z > this.max.z
        );
      },
      containsBox: function (t) {
        return (
          this.min.x <= t.min.x &&
          t.max.x <= this.max.x &&
          this.min.y <= t.min.y &&
          t.max.y <= this.max.y &&
          this.min.z <= t.min.z &&
          t.max.z <= this.max.z
        );
      },
      getParameter: function (t, e) {
        return (e || new a()).set(
          (t.x - this.min.x) / (this.max.x - this.min.x),
          (t.y - this.min.y) / (this.max.y - this.min.y),
          (t.z - this.min.z) / (this.max.z - this.min.z)
        );
      },
      intersectsBox: function (t) {
        return !(
          t.max.x < this.min.x ||
          t.min.x > this.max.x ||
          t.max.y < this.min.y ||
          t.min.y > this.max.y ||
          t.max.z < this.min.z ||
          t.min.z > this.max.z
        );
      },
      intersectsSphere: (function () {
        const t = new a();
        return function (e) {
          return (this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius);
        };
      })(),
      intersectsPlane: function (t) {
        let e, i;
        return (
          t.normal.x > 0
            ? ((e = t.normal.x * this.min.x), (i = t.normal.x * this.max.x))
            : ((e = t.normal.x * this.max.x), (i = t.normal.x * this.min.x)),
          t.normal.y > 0
            ? ((e += t.normal.y * this.min.y), (i += t.normal.y * this.max.y))
            : ((e += t.normal.y * this.max.y), (i += t.normal.y * this.min.y)),
          t.normal.z > 0
            ? ((e += t.normal.z * this.min.z), (i += t.normal.z * this.max.z))
            : ((e += t.normal.z * this.max.z), (i += t.normal.z * this.min.z)),
          e <= t.constant && i >= t.constant
        );
      },
      clampPoint: function (t, e) {
        return (e || new a()).copy(t).clamp(this.min, this.max);
      },
      distanceToPoint: (function () {
        const t = new a();
        return function (e) {
          return t.copy(e).clamp(this.min, this.max).sub(e).length();
        };
      })(),
      getBoundingSphere: (function () {
        const t = new a();
        return function (e) {
          const i = e || new L();
          return (this.getCenter(i.center), (i.radius = 0.5 * this.getSize(t).length()), i);
        };
      })(),
      intersect: function (t) {
        return (this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this);
      },
      union: function (t) {
        return (this.min.min(t.min), this.max.max(t.max), this);
      },
      applyMatrix4: (function () {
        const t = [new a(), new a(), new a(), new a(), new a(), new a(), new a(), new a()];
        return function (e) {
          return this.isEmpty()
            ? this
            : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints(t),
              this);
        };
      })(),
      translate: function (t) {
        return (this.min.add(t), this.max.add(t), this);
      },
      equals: function (t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      },
    }),
    Object.assign(L.prototype, {
      set: function (t, e) {
        return (this.center.copy(t), (this.radius = e), this);
      },
      setFromPoints: (function () {
        const t = new R();
        return function (e, i) {
          const n = this.center;
          void 0 !== i ? n.copy(i) : t.setFromPoints(e).getCenter(n);
          for (var r = 0, a = 0, o = e.length; a < o; a++) r = Math.max(r, n.distanceToSquared(e[a]));
          return ((this.radius = Math.sqrt(r)), this);
        };
      })(),
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (this.center.copy(t.center), (this.radius = t.radius), this);
      },
      empty: function () {
        return this.radius <= 0;
      },
      containsPoint: function (t) {
        return t.distanceToSquared(this.center) <= this.radius * this.radius;
      },
      distanceToPoint: function (t) {
        return t.distanceTo(this.center) - this.radius;
      },
      intersectsSphere: function (t) {
        const e = this.radius + t.radius;
        return t.center.distanceToSquared(this.center) <= e * e;
      },
      intersectsBox: function (t) {
        return t.intersectsSphere(this);
      },
      intersectsPlane: function (t) {
        return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
      },
      clampPoint: function (t, e) {
        const i = this.center.distanceToSquared(t),
          n = e || new a();
        return (
          n.copy(t),
          i > this.radius * this.radius &&
            (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)),
          n
        );
      },
      getBoundingBox: function (t) {
        const e = t || new R();
        return (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
      },
      applyMatrix4: function (t) {
        return (this.center.applyMatrix4(t), (this.radius = this.radius * t.getMaxScaleOnAxis()), this);
      },
      translate: function (t) {
        return (this.center.add(t), this);
      },
      equals: function (t) {
        return t.center.equals(this.center) && t.radius === this.radius;
      },
    }),
    Object.assign(P.prototype, {
      set: function (t, e) {
        return (this.normal.copy(t), (this.constant = e), this);
      },
      setComponents: function (t, e, i, n) {
        return (this.normal.set(t, e, i), (this.constant = n), this);
      },
      setFromNormalAndCoplanarPoint: function (t, e) {
        return (this.normal.copy(t), (this.constant = -e.dot(this.normal)), this);
      },
      setFromCoplanarPoints: (function () {
        const t = new a(),
          e = new a();
        return function (i, n, r) {
          const a = t.subVectors(r, n).cross(e.subVectors(i, n)).normalize();
          return (this.setFromNormalAndCoplanarPoint(a, i), this);
        };
      })(),
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (this.normal.copy(t.normal), (this.constant = t.constant), this);
      },
      normalize: function () {
        const t = 1 / this.normal.length();
        return (this.normal.multiplyScalar(t), (this.constant *= t), this);
      },
      negate: function () {
        return ((this.constant *= -1), this.normal.negate(), this);
      },
      distanceToPoint: function (t) {
        return this.normal.dot(t) + this.constant;
      },
      distanceToSphere: function (t) {
        return this.distanceToPoint(t.center) - t.radius;
      },
      projectPoint: function (t, e) {
        return (e || new a()).copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
      },
      intersectLine: (function () {
        const t = new a();
        return function (e, i) {
          const n = i || new a(),
            r = e.delta(t),
            o = this.normal.dot(r);
          if (0 !== o) {
            const s = -(e.start.dot(this.normal) + this.constant) / o;
            if (!(s < 0 || s > 1)) return n.copy(r).multiplyScalar(s).add(e.start);
          } else if (0 === this.distanceToPoint(e.start)) return n.copy(e.start);
        };
      })(),
      intersectsLine: function (t) {
        const e = this.distanceToPoint(t.start),
          i = this.distanceToPoint(t.end);
        return (e < 0 && i > 0) || (i < 0 && e > 0);
      },
      intersectsBox: function (t) {
        return t.intersectsPlane(this);
      },
      intersectsSphere: function (t) {
        return t.intersectsPlane(this);
      },
      coplanarPoint: function (t) {
        return (t || new a()).copy(this.normal).multiplyScalar(-this.constant);
      },
      applyMatrix4: (function () {
        const t = new a(),
          e = new o();
        return function (i, n) {
          const r = n || e.getNormalMatrix(i),
            a = this.coplanarPoint(t).applyMatrix4(i),
            o = this.normal.applyMatrix3(r).normalize();
          return ((this.constant = -a.dot(o)), this);
        };
      })(),
      translate: function (t) {
        return ((this.constant -= t.dot(this.normal)), this);
      },
      equals: function (t) {
        return t.normal.equals(this.normal) && t.constant === this.constant;
      },
    }),
    Object.assign(C.prototype, {
      set: function (t, e, i, n, r, a) {
        const o = this.planes;
        return (o[0].copy(t), o[1].copy(e), o[2].copy(i), o[3].copy(n), o[4].copy(r), o[5].copy(a), this);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        for (let e = this.planes, i = 0; i < 6; i++) e[i].copy(t.planes[i]);
        return this;
      },
      setFromMatrix: function (t) {
        const e = this.planes,
          i = t.elements,
          n = i[0],
          r = i[1],
          a = i[2],
          o = i[3],
          s = i[4],
          c = i[5],
          h = i[6],
          l = i[7],
          u = i[8],
          p = i[9],
          d = i[10],
          f = i[11],
          m = i[12],
          v = i[13],
          g = i[14],
          y = i[15];
        return (
          e[0].setComponents(o - n, l - s, f - u, y - m).normalize(),
          e[1].setComponents(o + n, l + s, f + u, y + m).normalize(),
          e[2].setComponents(o + r, l + c, f + p, y + v).normalize(),
          e[3].setComponents(o - r, l - c, f - p, y - v).normalize(),
          e[4].setComponents(o - a, l - h, f - d, y - g).normalize(),
          e[5].setComponents(o + a, l + h, f + d, y + g).normalize(),
          this
        );
      },
      intersectsObject: (function () {
        const t = new L();
        return function (e) {
          const i = e.geometry;
          return (
            null === i.boundingSphere && i.computeBoundingSphere(),
            t.copy(i.boundingSphere).applyMatrix4(e.matrixWorld),
            this.intersectsSphere(t)
          );
        };
      })(),
      intersectsSprite: (function () {
        const t = new L();
        return function (e) {
          return (
            t.center.set(0, 0, 0),
            (t.radius = 0.7071067811865476),
            t.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(t)
          );
        };
      })(),
      intersectsSphere: function (t) {
        for (let e = this.planes, i = t.center, n = -t.radius, r = 0; r < 6; r++) {
          if (e[r].distanceToPoint(i) < n) return !1;
        }
        return !0;
      },
      intersectsBox: (function () {
        const t = new a(),
          e = new a();
        return function (i) {
          for (let n = this.planes, r = 0; r < 6; r++) {
            const a = n[r];
            ((t.x = a.normal.x > 0 ? i.min.x : i.max.x),
              (e.x = a.normal.x > 0 ? i.max.x : i.min.x),
              (t.y = a.normal.y > 0 ? i.min.y : i.max.y),
              (e.y = a.normal.y > 0 ? i.max.y : i.min.y),
              (t.z = a.normal.z > 0 ? i.min.z : i.max.z),
              (e.z = a.normal.z > 0 ? i.max.z : i.min.z));
            const o = a.distanceToPoint(t),
              s = a.distanceToPoint(e);
            if (o < 0 && s < 0) return !1;
          }
          return !0;
        };
      })(),
      containsPoint: function (t) {
        for (let e = this.planes, i = 0; i < 6; i++) if (e[i].distanceToPoint(t) < 0) return !1;
        return !0;
      },
    }),
    (D.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX']),
    (D.DefaultOrder = 'XYZ'),
    Object.defineProperties(D.prototype, {
      x: {
        get: function () {
          return this._x;
        },
        set: function (t) {
          ((this._x = t), this.onChangeCallback());
        },
      },
      y: {
        get: function () {
          return this._y;
        },
        set: function (t) {
          ((this._y = t), this.onChangeCallback());
        },
      },
      z: {
        get: function () {
          return this._z;
        },
        set: function (t) {
          ((this._z = t), this.onChangeCallback());
        },
      },
      order: {
        get: function () {
          return this._order;
        },
        set: function (t) {
          ((this._order = t), this.onChangeCallback());
        },
      },
    }),
    Object.assign(D.prototype, {
      isEuler: !0,
      set: function (t, e, i, n) {
        return (
          (this._x = t),
          (this._y = e),
          (this._z = i),
          (this._order = n || this._order),
          this.onChangeCallback(),
          this
        );
      },
      clone: function () {
        return new this.constructor(this._x, this._y, this._z, this._order);
      },
      copy: function (t) {
        return (
          (this._x = t._x),
          (this._y = t._y),
          (this._z = t._z),
          (this._order = t._order),
          this.onChangeCallback(),
          this
        );
      },
      setFromRotationMatrix: function (t, e, i) {
        const n = Wa.clamp,
          r = t.elements,
          a = r[0],
          o = r[4],
          s = r[8],
          c = r[1],
          h = r[5],
          l = r[9],
          u = r[2],
          p = r[6],
          d = r[10];
        return (
          'XYZ' === (e = e || this._order)
            ? ((this._y = Math.asin(n(s, -1, 1))),
              Math.abs(s) < 0.99999
                ? ((this._x = Math.atan2(-l, d)), (this._z = Math.atan2(-o, a)))
                : ((this._x = Math.atan2(p, h)), (this._z = 0)))
            : 'YXZ' === e
              ? ((this._x = Math.asin(-n(l, -1, 1))),
                Math.abs(l) < 0.99999
                  ? ((this._y = Math.atan2(s, d)), (this._z = Math.atan2(c, h)))
                  : ((this._y = Math.atan2(-u, a)), (this._z = 0)))
              : 'ZXY' === e
                ? ((this._x = Math.asin(n(p, -1, 1))),
                  Math.abs(p) < 0.99999
                    ? ((this._y = Math.atan2(-u, d)), (this._z = Math.atan2(-o, h)))
                    : ((this._y = 0), (this._z = Math.atan2(c, a))))
                : 'ZYX' === e
                  ? ((this._y = Math.asin(-n(u, -1, 1))),
                    Math.abs(u) < 0.99999
                      ? ((this._x = Math.atan2(p, d)), (this._z = Math.atan2(c, a)))
                      : ((this._x = 0), (this._z = Math.atan2(-o, h))))
                  : 'YZX' === e
                    ? ((this._z = Math.asin(n(c, -1, 1))),
                      Math.abs(c) < 0.99999
                        ? ((this._x = Math.atan2(-l, h)), (this._y = Math.atan2(-u, a)))
                        : ((this._x = 0), (this._y = Math.atan2(s, d))))
                    : 'XZY' === e
                      ? ((this._z = Math.asin(-n(o, -1, 1))),
                        Math.abs(o) < 0.99999
                          ? ((this._x = Math.atan2(p, h)), (this._y = Math.atan2(s, a)))
                          : ((this._x = Math.atan2(-l, d)), (this._y = 0)))
                      : console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + e),
          (this._order = e),
          !1 !== i && this.onChangeCallback(),
          this
        );
      },
      setFromQuaternion: (function () {
        const t = new n();
        return function (e, i, n) {
          return (t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, i, n));
        };
      })(),
      setFromVector3: function (t, e) {
        return this.set(t.x, t.y, t.z, e || this._order);
      },
      reorder: (function () {
        const t = new r();
        return function (e) {
          return (t.setFromEuler(this), this.setFromQuaternion(t, e));
        };
      })(),
      equals: function (t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
      },
      fromArray: function (t) {
        return (
          (this._x = t[0]),
          (this._y = t[1]),
          (this._z = t[2]),
          void 0 !== t[3] && (this._order = t[3]),
          this.onChangeCallback(),
          this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this._x),
          (t[e + 1] = this._y),
          (t[e + 2] = this._z),
          (t[e + 3] = this._order),
          t
        );
      },
      toVector3: function (t) {
        return t ? t.set(this._x, this._y, this._z) : new a(this._x, this._y, this._z);
      },
      onChange: function (t) {
        return ((this.onChangeCallback = t), this);
      },
      onChangeCallback: function () {},
    }),
    Object.assign(O.prototype, {
      set: function (t) {
        this.mask = (1 << t) | 0;
      },
      enable: function (t) {
        this.mask |= (1 << t) | 0;
      },
      toggle: function (t) {
        this.mask ^= (1 << t) | 0;
      },
      disable: function (t) {
        this.mask &= ~((1 << t) | 0);
      },
      test: function (t) {
        return 0 != (this.mask & t.mask);
      },
    }));
  var oo = 0;
  ((U.DefaultUp = new a(0, 1, 0)),
    (U.DefaultMatrixAutoUpdate = !0),
    Object.assign(U.prototype, e.prototype, {
      isObject3D: !0,
      onBeforeRender: function () {},
      onAfterRender: function () {},
      applyMatrix: function (t) {
        (this.matrix.multiplyMatrices(t, this.matrix),
          this.matrix.decompose(this.position, this.quaternion, this.scale));
      },
      applyQuaternion: function (t) {
        return (this.quaternion.premultiply(t), this);
      },
      setRotationFromAxisAngle: function (t, e) {
        this.quaternion.setFromAxisAngle(t, e);
      },
      setRotationFromEuler: function (t) {
        this.quaternion.setFromEuler(t, !0);
      },
      setRotationFromMatrix: function (t) {
        this.quaternion.setFromRotationMatrix(t);
      },
      setRotationFromQuaternion: function (t) {
        this.quaternion.copy(t);
      },
      rotateOnAxis: (function () {
        const t = new r();
        return function (e, i) {
          return (t.setFromAxisAngle(e, i), this.quaternion.multiply(t), this);
        };
      })(),
      rotateOnWorldAxis: (function () {
        const t = new r();
        return function (e, i) {
          return (t.setFromAxisAngle(e, i), this.quaternion.premultiply(t), this);
        };
      })(),
      rotateX: (function () {
        const t = new a(1, 0, 0);
        return function (e) {
          return this.rotateOnAxis(t, e);
        };
      })(),
      rotateY: (function () {
        const t = new a(0, 1, 0);
        return function (e) {
          return this.rotateOnAxis(t, e);
        };
      })(),
      rotateZ: (function () {
        const t = new a(0, 0, 1);
        return function (e) {
          return this.rotateOnAxis(t, e);
        };
      })(),
      translateOnAxis: (function () {
        const t = new a();
        return function (e, i) {
          return (t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(i)), this);
        };
      })(),
      translateX: (function () {
        const t = new a(1, 0, 0);
        return function (e) {
          return this.translateOnAxis(t, e);
        };
      })(),
      translateY: (function () {
        const t = new a(0, 1, 0);
        return function (e) {
          return this.translateOnAxis(t, e);
        };
      })(),
      translateZ: (function () {
        const t = new a(0, 0, 1);
        return function (e) {
          return this.translateOnAxis(t, e);
        };
      })(),
      localToWorld: function (t) {
        return t.applyMatrix4(this.matrixWorld);
      },
      worldToLocal: (function () {
        const t = new n();
        return function (e) {
          return e.applyMatrix4(t.getInverse(this.matrixWorld));
        };
      })(),
      lookAt: (function () {
        const t = new n(),
          e = new a();
        return function (i, n, r) {
          (i.isVector3 ? e.copy(i) : e.set(i, n, r),
            this.isCamera ? t.lookAt(this.position, e, this.up) : t.lookAt(e, this.position, this.up),
            this.quaternion.setFromRotationMatrix(t));
        };
      })(),
      add: function (t) {
        if (arguments.length > 1) {
          for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
          return this;
        }
        return t === this
          ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this)
          : (t && t.isObject3D
              ? (null !== t.parent && t.parent.remove(t),
                (t.parent = this),
                t.dispatchEvent({ type: 'added' }),
                this.children.push(t))
              : console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', t),
            this);
      },
      remove: function (t) {
        if (arguments.length > 1) {
          for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
          return this;
        }
        const i = this.children.indexOf(t);
        return (
          -1 !== i && ((t.parent = null), t.dispatchEvent({ type: 'removed' }), this.children.splice(i, 1)),
          this
        );
      },
      getObjectById: function (t) {
        return this.getObjectByProperty('id', t);
      },
      getObjectByName: function (t) {
        return this.getObjectByProperty('name', t);
      },
      getObjectByProperty: function (t, e) {
        if (this[t] === e) return this;
        for (let i = 0, n = this.children.length; i < n; i++) {
          const r = this.children[i].getObjectByProperty(t, e);
          if (void 0 !== r) return r;
        }
      },
      getWorldPosition: function (t) {
        const e = t || new a();
        return (this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld));
      },
      getWorldQuaternion: (function () {
        const t = new a(),
          e = new a();
        return function (i) {
          const n = i || new r();
          return (this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, n, e), n);
        };
      })(),
      getWorldRotation: (function () {
        const t = new r();
        return function (e) {
          const i = e || new D();
          return (this.getWorldQuaternion(t), i.setFromQuaternion(t, this.rotation.order, !1));
        };
      })(),
      getWorldScale: (function () {
        const t = new a(),
          e = new r();
        return function (i) {
          const n = i || new a();
          return (this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, n), n);
        };
      })(),
      getWorldDirection: (function () {
        const t = new r();
        return function (e) {
          const i = e || new a();
          return (this.getWorldQuaternion(t), i.set(0, 0, 1).applyQuaternion(t));
        };
      })(),
      raycast: function () {},
      traverse: function (t) {
        t(this);
        for (let e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverse(t);
      },
      traverseVisible: function (t) {
        if (!1 !== this.visible) {
          t(this);
          for (let e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t);
        }
      },
      traverseAncestors: function (t) {
        const e = this.parent;
        null !== e && (t(e), e.traverseAncestors(t));
      },
      updateMatrix: function () {
        (this.matrix.compose(this.position, this.quaternion, this.scale), (this.matrixWorldNeedsUpdate = !0));
      },
      updateMatrixWorld: function (t) {
        (this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrixWorldNeedsUpdate || t) &&
            (null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            (this.matrixWorldNeedsUpdate = !1),
            (t = !0)));
        for (let e = this.children, i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t);
      },
      toJSON: function (t) {
        function e(e, i) {
          return (void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid);
        }
        function i(t) {
          const e = [];
          for (const i in t) {
            const n = t[i];
            (delete n.metadata, e.push(n));
          }
          return e;
        }
        const n = void 0 === t || 'string' == typeof t,
          r = {};
        n &&
          ((t = { geometries: {}, materials: {}, textures: {}, images: {} }),
          (r.metadata = { version: 4.5, type: 'Object', generator: 'Object3D.toJSON' }));
        const a = {};
        if (
          ((a.uuid = this.uuid),
          (a.type = this.type),
          '' !== this.name && (a.name = this.name),
          !0 === this.castShadow && (a.castShadow = !0),
          !0 === this.receiveShadow && (a.receiveShadow = !0),
          !1 === this.visible && (a.visible = !1),
          '{}' !== JSON.stringify(this.userData) && (a.userData = this.userData),
          (a.matrix = this.matrix.toArray()),
          void 0 !== this.geometry && (a.geometry = e(t.geometries, this.geometry)),
          void 0 !== this.material)
        )
          if (Array.isArray(this.material)) {
            for (var o = [], s = 0, c = this.material.length; s < c; s++) o.push(e(t.materials, this.material[s]));
            a.material = o;
          } else a.material = e(t.materials, this.material);
        if (this.children.length > 0) {
          a.children = [];
          for (s = 0; s < this.children.length; s++) a.children.push(this.children[s].toJSON(t).object);
        }
        if (n) {
          const h = i(t.geometries),
            l = i(t.materials),
            u = i(t.textures),
            p = i(t.images);
          (h.length > 0 && (r.geometries = h),
            l.length > 0 && (r.materials = l),
            u.length > 0 && (r.textures = u),
            p.length > 0 && (r.images = p));
        }
        return ((r.object = a), r);
      },
      clone: function (t) {
        return new this.constructor().copy(this, t);
      },
      copy: function (t, e) {
        if (
          (void 0 === e && (e = !0),
          (this.name = t.name),
          this.up.copy(t.up),
          this.position.copy(t.position),
          this.quaternion.copy(t.quaternion),
          this.scale.copy(t.scale),
          this.matrix.copy(t.matrix),
          this.matrixWorld.copy(t.matrixWorld),
          (this.matrixAutoUpdate = t.matrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
          (this.layers.mask = t.layers.mask),
          (this.visible = t.visible),
          (this.castShadow = t.castShadow),
          (this.receiveShadow = t.receiveShadow),
          (this.frustumCulled = t.frustumCulled),
          (this.renderOrder = t.renderOrder),
          (this.userData = JSON.parse(JSON.stringify(t.userData))),
          !0 === e)
        )
          for (let i = 0; i < t.children.length; i++) {
            const n = t.children[i];
            this.add(n.clone());
          }
        return this;
      },
    }),
    (N.prototype = Object.assign(Object.create(U.prototype), {
      constructor: N,
      isCamera: !0,
      copy: function (t, e) {
        return (
          U.prototype.copy.call(this, t, e),
          this.matrixWorldInverse.copy(t.matrixWorldInverse),
          this.projectionMatrix.copy(t.projectionMatrix),
          this
        );
      },
      getWorldDirection: (function () {
        const t = new r();
        return function (e) {
          const i = e || new a();
          return (this.getWorldQuaternion(t), i.set(0, 0, -1).applyQuaternion(t));
        };
      })(),
      updateMatrixWorld: function (t) {
        (U.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld));
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
    })),
    (B.prototype = Object.assign(Object.create(N.prototype), {
      constructor: B,
      isOrthographicCamera: !0,
      copy: function (t, e) {
        return (
          N.prototype.copy.call(this, t, e),
          (this.left = t.left),
          (this.right = t.right),
          (this.top = t.top),
          (this.bottom = t.bottom),
          (this.near = t.near),
          (this.far = t.far),
          (this.zoom = t.zoom),
          (this.view = null === t.view ? null : Object.assign({}, t.view)),
          this
        );
      },
      setViewOffset: function (t, e, i, n, r, a) {
        (null === this.view &&
          (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }),
          (this.view.enabled = !0),
          (this.view.fullWidth = t),
          (this.view.fullHeight = e),
          (this.view.offsetX = i),
          (this.view.offsetY = n),
          (this.view.width = r),
          (this.view.height = a),
          this.updateProjectionMatrix());
      },
      clearViewOffset: function () {
        (null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix());
      },
      updateProjectionMatrix: function () {
        let t = (this.right - this.left) / (2 * this.zoom),
          e = (this.top - this.bottom) / (2 * this.zoom),
          i = (this.right + this.left) / 2,
          n = (this.top + this.bottom) / 2,
          r = i - t,
          a = i + t,
          o = n + e,
          s = n - e;
        if (null !== this.view && this.view.enabled) {
          const c = this.zoom / (this.view.width / this.view.fullWidth),
            h = this.zoom / (this.view.height / this.view.fullHeight),
            l = (this.right - this.left) / this.view.width,
            u = (this.top - this.bottom) / this.view.height;
          ((a = (r += l * (this.view.offsetX / c)) + l * (this.view.width / c)),
            (s = (o -= u * (this.view.offsetY / h)) - u * (this.view.height / h)));
        }
        this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far);
      },
      toJSON: function (t) {
        const e = U.prototype.toJSON.call(this, t);
        return (
          (e.object.zoom = this.zoom),
          (e.object.left = this.left),
          (e.object.right = this.right),
          (e.object.top = this.top),
          (e.object.bottom = this.bottom),
          (e.object.near = this.near),
          (e.object.far = this.far),
          null !== this.view && (e.object.view = Object.assign({}, this.view)),
          e
        );
      },
    })),
    Object.assign(F.prototype, {
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        ((this.a = t.a),
          (this.b = t.b),
          (this.c = t.c),
          this.normal.copy(t.normal),
          this.color.copy(t.color),
          (this.materialIndex = t.materialIndex));
        for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
        for (var e = 0, i = t.vertexColors.length; e < i; e++) this.vertexColors[e] = t.vertexColors[e].clone();
        return this;
      },
    }));
  var so = 0;
  (Object.assign(z.prototype, e.prototype, {
    isGeometry: !0,
    applyMatrix: function (t) {
      for (var e = new o().getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++) {
        this.vertices[i].applyMatrix4(t);
      }
      for (var i = 0, n = this.faces.length; i < n; i++) {
        const r = this.faces[i];
        r.normal.applyMatrix3(e).normalize();
        for (let a = 0, s = r.vertexNormals.length; a < s; a++) r.vertexNormals[a].applyMatrix3(e).normalize();
      }
      return (
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        (this.verticesNeedUpdate = !0),
        (this.normalsNeedUpdate = !0),
        this
      );
    },
    rotateX: (function () {
      const t = new n();
      return function (e) {
        return (t.makeRotationX(e), this.applyMatrix(t), this);
      };
    })(),
    rotateY: (function () {
      const t = new n();
      return function (e) {
        return (t.makeRotationY(e), this.applyMatrix(t), this);
      };
    })(),
    rotateZ: (function () {
      const t = new n();
      return function (e) {
        return (t.makeRotationZ(e), this.applyMatrix(t), this);
      };
    })(),
    translate: (function () {
      const t = new n();
      return function (e, i, n) {
        return (t.makeTranslation(e, i, n), this.applyMatrix(t), this);
      };
    })(),
    scale: (function () {
      const t = new n();
      return function (e, i, n) {
        return (t.makeScale(e, i, n), this.applyMatrix(t), this);
      };
    })(),
    lookAt: (function () {
      const t = new U();
      return function (e) {
        (t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix));
      };
    })(),
    fromBufferGeometry: function (t) {
      function e(t, e, i, r) {
        const a = new F(
          t,
          e,
          i,
          void 0 !== c ? [p[t].clone(), p[e].clone(), p[i].clone()] : [],
          void 0 !== h ? [n.colors[t].clone(), n.colors[e].clone(), n.colors[i].clone()] : [],
          r
        );
        (n.faces.push(a),
          void 0 !== l && n.faceVertexUvs[0].push([d[t].clone(), d[e].clone(), d[i].clone()]),
          void 0 !== u && n.faceVertexUvs[1].push([f[t].clone(), f[e].clone(), f[i].clone()]));
      }
      var n = this,
        r = null !== t.index ? t.index.array : void 0,
        o = t.attributes,
        s = o.position.array,
        c = void 0 !== o.normal ? o.normal.array : void 0,
        h = void 0 !== o.color ? o.color.array : void 0,
        l = void 0 !== o.uv ? o.uv.array : void 0,
        u = void 0 !== o.uv2 ? o.uv2.array : void 0;
      void 0 !== u && (this.faceVertexUvs[1] = []);
      for (var p = [], d = [], f = [], m = 0, v = 0; m < s.length; m += 3, v += 2)
        (n.vertices.push(new a(s[m], s[m + 1], s[m + 2])),
          void 0 !== c && p.push(new a(c[m], c[m + 1], c[m + 2])),
          void 0 !== h && n.colors.push(new w(h[m], h[m + 1], h[m + 2])),
          void 0 !== l && d.push(new i(l[v], l[v + 1])),
          void 0 !== u && f.push(new i(u[v], u[v + 1])));
      const g = t.groups;
      if (g.length > 0)
        for (m = 0; m < g.length; m++)
          for (var y = g[m], x = y.start, v = x, b = x + y.count; v < b; v += 3)
            void 0 !== r ? e(r[v], r[v + 1], r[v + 2], y.materialIndex) : e(v, v + 1, v + 2, y.materialIndex);
      else if (void 0 !== r) for (m = 0; m < r.length; m += 3) e(r[m], r[m + 1], r[m + 2]);
      else for (m = 0; m < s.length / 3; m += 3) e(m, m + 1, m + 2);
      return (
        this.computeFaceNormals(),
        null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
        null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
        this
      );
    },
    center: function () {
      this.computeBoundingBox();
      const t = this.boundingBox.getCenter().negate();
      return (this.translate(t.x, t.y, t.z), t);
    },
    normalize: function () {
      this.computeBoundingSphere();
      const t = this.boundingSphere.center,
        e = this.boundingSphere.radius,
        i = 0 === e ? 1 : 1 / e,
        r = new n();
      return (r.set(i, 0, 0, -i * t.x, 0, i, 0, -i * t.y, 0, 0, i, -i * t.z, 0, 0, 0, 1), this.applyMatrix(r), this);
    },
    computeFaceNormals: function () {
      for (let t = new a(), e = new a(), i = 0, n = this.faces.length; i < n; i++) {
        const r = this.faces[i],
          o = this.vertices[r.a],
          s = this.vertices[r.b],
          c = this.vertices[r.c];
        (t.subVectors(c, s), e.subVectors(o, s), t.cross(e), t.normalize(), r.normal.copy(t));
      }
    },
    computeVertexNormals: function (t) {
      void 0 === t && (t = !0);
      let e, i, n, r, o, s;
      for (s = new Array(this.vertices.length), e = 0, i = this.vertices.length; e < i; e++) s[e] = new a();
      if (t) {
        let c,
          h,
          l,
          u = new a(),
          p = new a();
        for (n = 0, r = this.faces.length; n < r; n++)
          ((o = this.faces[n]),
            (c = this.vertices[o.a]),
            (h = this.vertices[o.b]),
            (l = this.vertices[o.c]),
            u.subVectors(l, h),
            p.subVectors(c, h),
            u.cross(p),
            s[o.a].add(u),
            s[o.b].add(u),
            s[o.c].add(u));
      } else
        for (this.computeFaceNormals(), n = 0, r = this.faces.length; n < r; n++)
          (s[(o = this.faces[n]).a].add(o.normal), s[o.b].add(o.normal), s[o.c].add(o.normal));
      for (e = 0, i = this.vertices.length; e < i; e++) s[e].normalize();
      for (n = 0, r = this.faces.length; n < r; n++) {
        const d = (o = this.faces[n]).vertexNormals;
        3 === d.length
          ? (d[0].copy(s[o.a]), d[1].copy(s[o.b]), d[2].copy(s[o.c]))
          : ((d[0] = s[o.a].clone()), (d[1] = s[o.b].clone()), (d[2] = s[o.c].clone()));
      }
      this.faces.length > 0 && (this.normalsNeedUpdate = !0);
    },
    computeFlatVertexNormals: function () {
      let t, e, i;
      for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
        const n = (i = this.faces[t]).vertexNormals;
        3 === n.length
          ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal))
          : ((n[0] = i.normal.clone()), (n[1] = i.normal.clone()), (n[2] = i.normal.clone()));
      }
      this.faces.length > 0 && (this.normalsNeedUpdate = !0);
    },
    computeMorphNormals: function () {
      let t, e, i, n, r;
      for (i = 0, n = this.faces.length; i < n; i++)
        for (
          (r = this.faces[i]).__originalFaceNormal
            ? r.__originalFaceNormal.copy(r.normal)
            : (r.__originalFaceNormal = r.normal.clone()),
            r.__originalVertexNormals || (r.__originalVertexNormals = []),
            t = 0,
            e = r.vertexNormals.length;
          t < e;
          t++
        )
          r.__originalVertexNormals[t]
            ? r.__originalVertexNormals[t].copy(r.vertexNormals[t])
            : (r.__originalVertexNormals[t] = r.vertexNormals[t].clone());
      const o = new z();
      for (o.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
        if (!this.morphNormals[t]) {
          ((this.morphNormals[t] = {}),
            (this.morphNormals[t].faceNormals = []),
            (this.morphNormals[t].vertexNormals = []));
          const s = this.morphNormals[t].faceNormals,
            c = this.morphNormals[t].vertexNormals;
          for (i = 0, n = this.faces.length; i < n; i++)
            ((l = new a()), (u = { a: new a(), b: new a(), c: new a() }), s.push(l), c.push(u));
        }
        const h = this.morphNormals[t];
        ((o.vertices = this.morphTargets[t].vertices), o.computeFaceNormals(), o.computeVertexNormals());
        var l, u;
        for (i = 0, n = this.faces.length; i < n; i++)
          ((r = this.faces[i]),
            (l = h.faceNormals[i]),
            (u = h.vertexNormals[i]),
            l.copy(r.normal),
            u.a.copy(r.vertexNormals[0]),
            u.b.copy(r.vertexNormals[1]),
            u.c.copy(r.vertexNormals[2]));
      }
      for (i = 0, n = this.faces.length; i < n; i++)
        (((r = this.faces[i]).normal = r.__originalFaceNormal), (r.vertexNormals = r.__originalVertexNormals));
    },
    computeLineDistances: function () {
      for (let t = 0, e = this.vertices, i = 0, n = e.length; i < n; i++)
        (i > 0 && (t += e[i].distanceTo(e[i - 1])), (this.lineDistances[i] = t));
    },
    computeBoundingBox: function () {
      (null === this.boundingBox && (this.boundingBox = new R()), this.boundingBox.setFromPoints(this.vertices));
    },
    computeBoundingSphere: function () {
      (null === this.boundingSphere && (this.boundingSphere = new L()),
        this.boundingSphere.setFromPoints(this.vertices));
    },
    merge: function (t, e, i) {
      if (t && t.isGeometry) {
        let n,
          r = this.vertices.length,
          a = this.vertices,
          s = t.vertices,
          c = this.faces,
          h = t.faces,
          l = this.faceVertexUvs[0],
          u = t.faceVertexUvs[0],
          p = this.colors,
          d = t.colors;
        (void 0 === i && (i = 0), void 0 !== e && (n = new o().getNormalMatrix(e)));
        for (var f = 0, m = s.length; f < m; f++) {
          const v = s[f].clone();
          (void 0 !== e && v.applyMatrix4(e), a.push(v));
        }
        for (var f = 0, m = d.length; f < m; f++) p.push(d[f].clone());
        for (f = 0, m = h.length; f < m; f++) {
          var g,
            y,
            x,
            b = h[f],
            _ = b.vertexNormals,
            w = b.vertexColors;
          ((g = new F(b.a + r, b.b + r, b.c + r)).normal.copy(b.normal),
            void 0 !== n && g.normal.applyMatrix3(n).normalize());
          for (var E = 0, M = _.length; E < M; E++)
            ((y = _[E].clone()), void 0 !== n && y.applyMatrix3(n).normalize(), g.vertexNormals.push(y));
          g.color.copy(b.color);
          for (var E = 0, M = w.length; E < M; E++) ((x = w[E]), g.vertexColors.push(x.clone()));
          ((g.materialIndex = b.materialIndex + i), c.push(g));
        }
        for (f = 0, m = u.length; f < m; f++) {
          const T = u[f],
            S = [];
          if (void 0 !== T) {
            for (var E = 0, M = T.length; E < M; E++) S.push(T[E].clone());
            l.push(S);
          }
        }
      } else console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', t);
    },
    mergeMesh: function (t) {
      t && t.isMesh
        ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix))
        : console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', t);
    },
    mergeVertices: function () {
      let t,
        e,
        i,
        n,
        r,
        a,
        o,
        s,
        c = {},
        h = [],
        l = [],
        u = Math.pow(10, 4);
      for (i = 0, n = this.vertices.length; i < n; i++)
        ((t = this.vertices[i]),
          void 0 === c[(e = Math.round(t.x * u) + '_' + Math.round(t.y * u) + '_' + Math.round(t.z * u))]
            ? ((c[e] = i), h.push(this.vertices[i]), (l[i] = h.length - 1))
            : (l[i] = l[c[e]]));
      const p = [];
      for (i = 0, n = this.faces.length; i < n; i++) {
        (((r = this.faces[i]).a = l[r.a]), (r.b = l[r.b]), (r.c = l[r.c]), (a = [r.a, r.b, r.c]));
        for (let d = 0; d < 3; d++)
          if (a[d] === a[(d + 1) % 3]) {
            p.push(i);
            break;
          }
      }
      for (i = p.length - 1; i >= 0; i--) {
        const f = p[i];
        for (this.faces.splice(f, 1), o = 0, s = this.faceVertexUvs.length; o < s; o++)
          this.faceVertexUvs[o].splice(f, 1);
      }
      const m = this.vertices.length - h.length;
      return ((this.vertices = h), m);
    },
    setFromPoints: function (t) {
      this.vertices = [];
      for (let e = 0, i = t.length; e < i; e++) {
        const n = t[e];
        this.vertices.push(new a(n.x, n.y, n.z || 0));
      }
      return this;
    },
    sortFacesByMaterialIndex: function () {
      for (var t = this.faces, e = t.length, i = 0; i < e; i++) t[i]._id = i;
      t.sort(function (t, e) {
        return t.materialIndex - e.materialIndex;
      });
      let n,
        r,
        a = this.faceVertexUvs[0],
        o = this.faceVertexUvs[1];
      (a && a.length === e && (n = []), o && o.length === e && (r = []));
      for (i = 0; i < e; i++) {
        const s = t[i]._id;
        (n && n.push(a[s]), r && r.push(o[s]));
      }
      (n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r));
    },
    toJSON: function () {
      function t(t, e, i) {
        return i ? t | (1 << e) : t & ~(1 << e);
      }
      function e(t) {
        const e = t.x.toString() + t.y.toString() + t.z.toString();
        return void 0 !== p[e] ? p[e] : ((p[e] = u.length / 3), u.push(t.x, t.y, t.z), p[e]);
      }
      function i(t) {
        const e = t.r.toString() + t.g.toString() + t.b.toString();
        return void 0 !== f[e] ? f[e] : ((f[e] = d.length), d.push(t.getHex()), f[e]);
      }
      function n(t) {
        const e = t.x.toString() + t.y.toString();
        return void 0 !== v[e] ? v[e] : ((v[e] = m.length / 2), m.push(t.x, t.y), v[e]);
      }
      const r = { metadata: { version: 4.5, type: 'Geometry', generator: 'Geometry.toJSON' } };
      if (
        ((r.uuid = this.uuid),
        (r.type = this.type),
        '' !== this.name && (r.name = this.name),
        void 0 !== this.parameters)
      ) {
        const a = this.parameters;
        for (const o in a) void 0 !== a[o] && (r[o] = a[o]);
        return r;
      }
      for (var s = [], c = 0; c < this.vertices.length; c++) {
        const h = this.vertices[c];
        s.push(h.x, h.y, h.z);
      }
      for (var l = [], u = [], p = {}, d = [], f = {}, m = [], v = {}, c = 0; c < this.faces.length; c++) {
        let g = this.faces[c],
          y = void 0 !== this.faceVertexUvs[0][c],
          x = g.normal.length() > 0,
          b = g.vertexNormals.length > 0,
          _ = 1 !== g.color.r || 1 !== g.color.g || 1 !== g.color.b,
          w = g.vertexColors.length > 0,
          E = 0;
        if (
          ((E = t(E, 0, 0)),
          (E = t(E, 1, !0)),
          (E = t(E, 2, !1)),
          (E = t(E, 3, y)),
          (E = t(E, 4, x)),
          (E = t(E, 5, b)),
          (E = t(E, 6, _)),
          (E = t(E, 7, w)),
          l.push(E),
          l.push(g.a, g.b, g.c),
          l.push(g.materialIndex),
          y)
        ) {
          const M = this.faceVertexUvs[0][c];
          l.push(n(M[0]), n(M[1]), n(M[2]));
        }
        if ((x && l.push(e(g.normal)), b)) {
          const T = g.vertexNormals;
          l.push(e(T[0]), e(T[1]), e(T[2]));
        }
        if ((_ && l.push(i(g.color)), w)) {
          const S = g.vertexColors;
          l.push(i(S[0]), i(S[1]), i(S[2]));
        }
      }
      return (
        (r.data = {}),
        (r.data.vertices = s),
        (r.data.normals = u),
        d.length > 0 && (r.data.colors = d),
        m.length > 0 && (r.data.uvs = [m]),
        (r.data.faces = l),
        r
      );
    },
    clone: function () {
      return new z().copy(this);
    },
    copy: function (t) {
      let e, i, n, r, a, o;
      ((this.vertices = []),
        (this.colors = []),
        (this.faces = []),
        (this.faceVertexUvs = [[]]),
        (this.morphTargets = []),
        (this.morphNormals = []),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.lineDistances = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.name = t.name));
      const s = t.vertices;
      for (e = 0, i = s.length; e < i; e++) this.vertices.push(s[e].clone());
      const c = t.colors;
      for (e = 0, i = c.length; e < i; e++) this.colors.push(c[e].clone());
      const h = t.faces;
      for (e = 0, i = h.length; e < i; e++) this.faces.push(h[e].clone());
      for (e = 0, i = t.faceVertexUvs.length; e < i; e++) {
        const l = t.faceVertexUvs[e];
        for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), n = 0, r = l.length; n < r; n++) {
          const u = l[n],
            p = [];
          for (a = 0, o = u.length; a < o; a++) {
            const d = u[a];
            p.push(d.clone());
          }
          this.faceVertexUvs[e].push(p);
        }
      }
      const f = t.morphTargets;
      for (e = 0, i = f.length; e < i; e++) {
        const m = {};
        if (((m.name = f[e].name), void 0 !== f[e].vertices))
          for (m.vertices = [], n = 0, r = f[e].vertices.length; n < r; n++) m.vertices.push(f[e].vertices[n].clone());
        if (void 0 !== f[e].normals)
          for (m.normals = [], n = 0, r = f[e].normals.length; n < r; n++) m.normals.push(f[e].normals[n].clone());
        this.morphTargets.push(m);
      }
      const v = t.morphNormals;
      for (e = 0, i = v.length; e < i; e++) {
        const g = {};
        if (void 0 !== v[e].vertexNormals)
          for (g.vertexNormals = [], n = 0, r = v[e].vertexNormals.length; n < r; n++) {
            const y = v[e].vertexNormals[n],
              x = {};
            ((x.a = y.a.clone()), (x.b = y.b.clone()), (x.c = y.c.clone()), g.vertexNormals.push(x));
          }
        if (void 0 !== v[e].faceNormals)
          for (g.faceNormals = [], n = 0, r = v[e].faceNormals.length; n < r; n++)
            g.faceNormals.push(v[e].faceNormals[n].clone());
        this.morphNormals.push(g);
      }
      const b = t.skinWeights;
      for (e = 0, i = b.length; e < i; e++) this.skinWeights.push(b[e].clone());
      const _ = t.skinIndices;
      for (e = 0, i = _.length; e < i; e++) this.skinIndices.push(_[e].clone());
      const w = t.lineDistances;
      for (e = 0, i = w.length; e < i; e++) this.lineDistances.push(w[e]);
      const E = t.boundingBox;
      null !== E && (this.boundingBox = E.clone());
      const M = t.boundingSphere;
      return (
        null !== M && (this.boundingSphere = M.clone()),
        (this.elementsNeedUpdate = t.elementsNeedUpdate),
        (this.verticesNeedUpdate = t.verticesNeedUpdate),
        (this.uvsNeedUpdate = t.uvsNeedUpdate),
        (this.normalsNeedUpdate = t.normalsNeedUpdate),
        (this.colorsNeedUpdate = t.colorsNeedUpdate),
        (this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
        (this.groupsNeedUpdate = t.groupsNeedUpdate),
        this
      );
    },
    dispose: function () {
      this.dispatchEvent({ type: 'dispose' });
    },
  }),
    Object.defineProperty(G.prototype, 'needsUpdate', {
      set: function (t) {
        !0 === t && this.version++;
      },
    }),
    Object.assign(G.prototype, {
      isBufferAttribute: !0,
      setArray: function (t) {
        if (Array.isArray(t)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        ((this.count = void 0 !== t ? t.length / this.itemSize : 0), (this.array = t));
      },
      setDynamic: function (t) {
        return ((this.dynamic = t), this);
      },
      copy: function (t) {
        return (
          (this.array = new t.array.constructor(t.array)),
          (this.itemSize = t.itemSize),
          (this.count = t.count),
          (this.normalized = t.normalized),
          (this.dynamic = t.dynamic),
          this
        );
      },
      copyAt: function (t, e, i) {
        ((t *= this.itemSize), (i *= e.itemSize));
        for (let n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
        return this;
      },
      copyArray: function (t) {
        return (this.array.set(t), this);
      },
      copyColorsArray: function (t) {
        for (let e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
          let a = t[n];
          (void 0 === a &&
            (console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', n), (a = new w())),
            (e[i++] = a.r),
            (e[i++] = a.g),
            (e[i++] = a.b));
        }
        return this;
      },
      copyIndicesArray: function (t) {
        for (let e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
          const a = t[n];
          ((e[i++] = a.a), (e[i++] = a.b), (e[i++] = a.c));
        }
        return this;
      },
      copyVector2sArray: function (t) {
        for (let e = this.array, n = 0, r = 0, a = t.length; r < a; r++) {
          let o = t[r];
          (void 0 === o &&
            (console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', r), (o = new i())),
            (e[n++] = o.x),
            (e[n++] = o.y));
        }
        return this;
      },
      copyVector3sArray: function (t) {
        for (let e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
          let o = t[n];
          (void 0 === o &&
            (console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', n), (o = new a())),
            (e[i++] = o.x),
            (e[i++] = o.y),
            (e[i++] = o.z));
        }
        return this;
      },
      copyVector4sArray: function (t) {
        for (let e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
          let a = t[n];
          (void 0 === a &&
            (console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', n), (a = new c())),
            (e[i++] = a.x),
            (e[i++] = a.y),
            (e[i++] = a.z),
            (e[i++] = a.w));
        }
        return this;
      },
      set: function (t, e) {
        return (void 0 === e && (e = 0), this.array.set(t, e), this);
      },
      getX: function (t) {
        return this.array[t * this.itemSize];
      },
      setX: function (t, e) {
        return ((this.array[t * this.itemSize] = e), this);
      },
      getY: function (t) {
        return this.array[t * this.itemSize + 1];
      },
      setY: function (t, e) {
        return ((this.array[t * this.itemSize + 1] = e), this);
      },
      getZ: function (t) {
        return this.array[t * this.itemSize + 2];
      },
      setZ: function (t, e) {
        return ((this.array[t * this.itemSize + 2] = e), this);
      },
      getW: function (t) {
        return this.array[t * this.itemSize + 3];
      },
      setW: function (t, e) {
        return ((this.array[t * this.itemSize + 3] = e), this);
      },
      setXY: function (t, e, i) {
        return ((t *= this.itemSize), (this.array[t + 0] = e), (this.array[t + 1] = i), this);
      },
      setXYZ: function (t, e, i, n) {
        return ((t *= this.itemSize), (this.array[t + 0] = e), (this.array[t + 1] = i), (this.array[t + 2] = n), this);
      },
      setXYZW: function (t, e, i, n, r) {
        return (
          (t *= this.itemSize),
          (this.array[t + 0] = e),
          (this.array[t + 1] = i),
          (this.array[t + 2] = n),
          (this.array[t + 3] = r),
          this
        );
      },
      onUpload: function (t) {
        return ((this.onUploadCallback = t), this);
      },
      clone: function () {
        return new this.constructor(this.array, this.itemSize).copy(this);
      },
    }),
    ((H.prototype = Object.create(G.prototype)).constructor = H),
    ((V.prototype = Object.create(G.prototype)).constructor = V),
    ((k.prototype = Object.create(G.prototype)).constructor = k),
    ((j.prototype = Object.create(G.prototype)).constructor = j),
    ((W.prototype = Object.create(G.prototype)).constructor = W),
    ((X.prototype = Object.create(G.prototype)).constructor = X),
    ((q.prototype = Object.create(G.prototype)).constructor = q),
    ((Y.prototype = Object.create(G.prototype)).constructor = Y),
    ((Z.prototype = Object.create(G.prototype)).constructor = Z),
    Object.assign(Q.prototype, {
      computeGroups: function (t) {
        for (var e, i = [], n = void 0, r = t.faces, a = 0; a < r.length; a++) {
          const o = r[a];
          o.materialIndex !== n &&
            ((n = o.materialIndex),
            void 0 !== e && ((e.count = 3 * a - e.start), i.push(e)),
            (e = { start: 3 * a, materialIndex: n }));
        }
        (void 0 !== e && ((e.count = 3 * a - e.start), i.push(e)), (this.groups = i));
      },
      fromGeometry: function (t) {
        let e,
          n = t.faces,
          r = t.vertices,
          a = t.faceVertexUvs,
          o = a[0] && a[0].length > 0,
          s = a[1] && a[1].length > 0,
          c = t.morphTargets,
          h = c.length;
        if (h > 0) {
          e = [];
          for (g = 0; g < h; g++) e[g] = [];
          this.morphTargets.position = e;
        }
        let l,
          u = t.morphNormals,
          p = u.length;
        if (p > 0) {
          l = [];
          for (g = 0; g < p; g++) l[g] = [];
          this.morphTargets.normal = l;
        }
        for (
          var d = t.skinIndices, f = t.skinWeights, m = d.length === r.length, v = f.length === r.length, g = 0;
          g < n.length;
          g++
        ) {
          const y = n[g];
          this.vertices.push(r[y.a], r[y.b], r[y.c]);
          const x = y.vertexNormals;
          if (3 === x.length) this.normals.push(x[0], x[1], x[2]);
          else {
            const b = y.normal;
            this.normals.push(b, b, b);
          }
          const _ = y.vertexColors;
          if (3 === _.length) this.colors.push(_[0], _[1], _[2]);
          else {
            const w = y.color;
            this.colors.push(w, w, w);
          }
          if (!0 === o) {
            void 0 !== (E = a[0][g])
              ? this.uvs.push(E[0], E[1], E[2])
              : (console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', g),
                this.uvs.push(new i(), new i(), new i()));
          }
          if (!0 === s) {
            var E = a[1][g];
            void 0 !== E
              ? this.uvs2.push(E[0], E[1], E[2])
              : (console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', g),
                this.uvs2.push(new i(), new i(), new i()));
          }
          for (T = 0; T < h; T++) {
            const M = c[T].vertices;
            e[T].push(M[y.a], M[y.b], M[y.c]);
          }
          for (var T = 0; T < p; T++) {
            const S = u[T].vertexNormals[g];
            l[T].push(S.a, S.b, S.c);
          }
          (m && this.skinIndices.push(d[y.a], d[y.b], d[y.c]), v && this.skinWeights.push(f[y.a], f[y.b], f[y.c]));
        }
        return (
          this.computeGroups(t),
          (this.verticesNeedUpdate = t.verticesNeedUpdate),
          (this.normalsNeedUpdate = t.normalsNeedUpdate),
          (this.colorsNeedUpdate = t.colorsNeedUpdate),
          (this.uvsNeedUpdate = t.uvsNeedUpdate),
          (this.groupsNeedUpdate = t.groupsNeedUpdate),
          this
        );
      },
    }));
  var co = 1;
  (Object.assign(K.prototype, e.prototype, {
    isBufferGeometry: !0,
    getIndex: function () {
      return this.index;
    },
    setIndex: function (t) {
      Array.isArray(t) ? (this.index = new (J(t) > 65535 ? q : W)(t, 1)) : (this.index = t);
    },
    addAttribute: function (t, e) {
      return (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)
        ? 'index' === t
          ? (console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.'),
            void this.setIndex(e))
          : ((this.attributes[t] = e), this)
        : (console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).'),
          void this.addAttribute(t, new G(arguments[1], arguments[2])));
    },
    getAttribute: function (t) {
      return this.attributes[t];
    },
    removeAttribute: function (t) {
      return (delete this.attributes[t], this);
    },
    addGroup: function (t, e, i) {
      this.groups.push({ start: t, count: e, materialIndex: void 0 !== i ? i : 0 });
    },
    clearGroups: function () {
      this.groups = [];
    },
    setDrawRange: function (t, e) {
      ((this.drawRange.start = t), (this.drawRange.count = e));
    },
    applyMatrix: function (t) {
      const e = this.attributes.position;
      void 0 !== e && (t.applyToBufferAttribute(e), (e.needsUpdate = !0));
      const i = this.attributes.normal;
      if (void 0 !== i) {
        (new o().getNormalMatrix(t).applyToBufferAttribute(i), (i.needsUpdate = !0));
      }
      return (
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this
      );
    },
    rotateX: (function () {
      const t = new n();
      return function (e) {
        return (t.makeRotationX(e), this.applyMatrix(t), this);
      };
    })(),
    rotateY: (function () {
      const t = new n();
      return function (e) {
        return (t.makeRotationY(e), this.applyMatrix(t), this);
      };
    })(),
    rotateZ: (function () {
      const t = new n();
      return function (e) {
        return (t.makeRotationZ(e), this.applyMatrix(t), this);
      };
    })(),
    translate: (function () {
      const t = new n();
      return function (e, i, n) {
        return (t.makeTranslation(e, i, n), this.applyMatrix(t), this);
      };
    })(),
    scale: (function () {
      const t = new n();
      return function (e, i, n) {
        return (t.makeScale(e, i, n), this.applyMatrix(t), this);
      };
    })(),
    lookAt: (function () {
      const t = new U();
      return function (e) {
        (t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix));
      };
    })(),
    center: function () {
      this.computeBoundingBox();
      const t = this.boundingBox.getCenter().negate();
      return (this.translate(t.x, t.y, t.z), t);
    },
    setFromObject: function (t) {
      const e = t.geometry;
      if (t.isPoints || t.isLine) {
        const i = new Y(3 * e.vertices.length, 3),
          n = new Y(3 * e.colors.length, 3);
        if (
          (this.addAttribute('position', i.copyVector3sArray(e.vertices)),
          this.addAttribute('color', n.copyColorsArray(e.colors)),
          e.lineDistances && e.lineDistances.length === e.vertices.length)
        ) {
          const r = new Y(e.lineDistances.length, 1);
          this.addAttribute('lineDistance', r.copyArray(e.lineDistances));
        }
        (null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
          null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()));
      } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
      return this;
    },
    setFromPoints: function (t) {
      for (var e = [], i = 0, n = t.length; i < n; i++) {
        const r = t[i];
        e.push(r.x, r.y, r.z || 0);
      }
      return (this.addAttribute('position', new Y(e, 3)), this);
    },
    updateFromObject: function (t) {
      let e = t.geometry;
      if (t.isMesh) {
        let i = e.__directGeometry;
        if ((!0 === e.elementsNeedUpdate && ((i = void 0), (e.elementsNeedUpdate = !1)), void 0 === i))
          return this.fromGeometry(e);
        ((i.verticesNeedUpdate = e.verticesNeedUpdate),
          (i.normalsNeedUpdate = e.normalsNeedUpdate),
          (i.colorsNeedUpdate = e.colorsNeedUpdate),
          (i.uvsNeedUpdate = e.uvsNeedUpdate),
          (i.groupsNeedUpdate = e.groupsNeedUpdate),
          (e.verticesNeedUpdate = !1),
          (e.normalsNeedUpdate = !1),
          (e.colorsNeedUpdate = !1),
          (e.uvsNeedUpdate = !1),
          (e.groupsNeedUpdate = !1),
          (e = i));
      }
      let n;
      return (
        !0 === e.verticesNeedUpdate &&
          (void 0 !== (n = this.attributes.position) && (n.copyVector3sArray(e.vertices), (n.needsUpdate = !0)),
          (e.verticesNeedUpdate = !1)),
        !0 === e.normalsNeedUpdate &&
          (void 0 !== (n = this.attributes.normal) && (n.copyVector3sArray(e.normals), (n.needsUpdate = !0)),
          (e.normalsNeedUpdate = !1)),
        !0 === e.colorsNeedUpdate &&
          (void 0 !== (n = this.attributes.color) && (n.copyColorsArray(e.colors), (n.needsUpdate = !0)),
          (e.colorsNeedUpdate = !1)),
        e.uvsNeedUpdate &&
          (void 0 !== (n = this.attributes.uv) && (n.copyVector2sArray(e.uvs), (n.needsUpdate = !0)),
          (e.uvsNeedUpdate = !1)),
        e.lineDistancesNeedUpdate &&
          (void 0 !== (n = this.attributes.lineDistance) && (n.copyArray(e.lineDistances), (n.needsUpdate = !0)),
          (e.lineDistancesNeedUpdate = !1)),
        e.groupsNeedUpdate && (e.computeGroups(t.geometry), (this.groups = e.groups), (e.groupsNeedUpdate = !1)),
        this
      );
    },
    fromGeometry: function (t) {
      return ((t.__directGeometry = new Q().fromGeometry(t)), this.fromDirectGeometry(t.__directGeometry));
    },
    fromDirectGeometry: function (t) {
      const e = new Float32Array(3 * t.vertices.length);
      if ((this.addAttribute('position', new G(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0)) {
        const i = new Float32Array(3 * t.normals.length);
        this.addAttribute('normal', new G(i, 3).copyVector3sArray(t.normals));
      }
      if (t.colors.length > 0) {
        const n = new Float32Array(3 * t.colors.length);
        this.addAttribute('color', new G(n, 3).copyColorsArray(t.colors));
      }
      if (t.uvs.length > 0) {
        const r = new Float32Array(2 * t.uvs.length);
        this.addAttribute('uv', new G(r, 2).copyVector2sArray(t.uvs));
      }
      if (t.uvs2.length > 0) {
        const a = new Float32Array(2 * t.uvs2.length);
        this.addAttribute('uv2', new G(a, 2).copyVector2sArray(t.uvs2));
      }
      if (t.indices.length > 0) {
        const o = new (J(t.indices) > 65535 ? Uint32Array : Uint16Array)(3 * t.indices.length);
        this.setIndex(new G(o, 1).copyIndicesArray(t.indices));
      }
      this.groups = t.groups;
      for (const s in t.morphTargets) {
        for (var c = [], h = t.morphTargets[s], l = 0, u = h.length; l < u; l++) {
          const p = h[l],
            d = new Y(3 * p.length, 3);
          c.push(d.copyVector3sArray(p));
        }
        this.morphAttributes[s] = c;
      }
      if (t.skinIndices.length > 0) {
        const f = new Y(4 * t.skinIndices.length, 4);
        this.addAttribute('skinIndex', f.copyVector4sArray(t.skinIndices));
      }
      if (t.skinWeights.length > 0) {
        const m = new Y(4 * t.skinWeights.length, 4);
        this.addAttribute('skinWeight', m.copyVector4sArray(t.skinWeights));
      }
      return (
        null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
        null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
        this
      );
    },
    computeBoundingBox: function () {
      null === this.boundingBox && (this.boundingBox = new R());
      const t = this.attributes.position;
      (void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(),
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
            this
          ));
    },
    computeBoundingSphere: (function () {
      const t = new R(),
        e = new a();
      return function () {
        null === this.boundingSphere && (this.boundingSphere = new L());
        const i = this.attributes.position;
        if (i) {
          const n = this.boundingSphere.center;
          (t.setFromBufferAttribute(i), t.getCenter(n));
          for (var r = 0, a = 0, o = i.count; a < o; a++)
            ((e.x = i.getX(a)), (e.y = i.getY(a)), (e.z = i.getZ(a)), (r = Math.max(r, n.distanceToSquared(e))));
          ((this.boundingSphere.radius = Math.sqrt(r)),
            isNaN(this.boundingSphere.radius) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                this
              ));
        }
      };
    })(),
    computeFaceNormals: function () {},
    computeVertexNormals: function () {
      const t = this.index,
        e = this.attributes,
        i = this.groups;
      if (e.position) {
        const n = e.position.array;
        if (void 0 === e.normal) this.addAttribute('normal', new G(new Float32Array(n.length), 3));
        else for (var r = e.normal.array, o = 0, s = r.length; o < s; o++) r[o] = 0;
        let c,
          h,
          l,
          u = e.normal.array,
          p = new a(),
          d = new a(),
          f = new a(),
          m = new a(),
          v = new a();
        if (t) {
          const g = t.array;
          0 === i.length && this.addGroup(0, g.length);
          for (let y = 0, x = i.length; y < x; ++y)
            for (var b = i[y], _ = b.start, o = _, s = _ + b.count; o < s; o += 3)
              ((c = 3 * g[o + 0]),
                (h = 3 * g[o + 1]),
                (l = 3 * g[o + 2]),
                p.fromArray(n, c),
                d.fromArray(n, h),
                f.fromArray(n, l),
                m.subVectors(f, d),
                v.subVectors(p, d),
                m.cross(v),
                (u[c] += m.x),
                (u[c + 1] += m.y),
                (u[c + 2] += m.z),
                (u[h] += m.x),
                (u[h + 1] += m.y),
                (u[h + 2] += m.z),
                (u[l] += m.x),
                (u[l + 1] += m.y),
                (u[l + 2] += m.z));
        } else
          for (var o = 0, s = n.length; o < s; o += 9)
            (p.fromArray(n, o),
              d.fromArray(n, o + 3),
              f.fromArray(n, o + 6),
              m.subVectors(f, d),
              v.subVectors(p, d),
              m.cross(v),
              (u[o] = m.x),
              (u[o + 1] = m.y),
              (u[o + 2] = m.z),
              (u[o + 3] = m.x),
              (u[o + 4] = m.y),
              (u[o + 5] = m.z),
              (u[o + 6] = m.x),
              (u[o + 7] = m.y),
              (u[o + 8] = m.z));
        (this.normalizeNormals(), (e.normal.needsUpdate = !0));
      }
    },
    merge: function (t, e) {
      if (t && t.isBufferGeometry) {
        void 0 === e && (e = 0);
        const i = this.attributes;
        for (const n in i)
          if (void 0 !== t.attributes[n])
            for (
              let r = i[n].array, a = t.attributes[n], o = a.array, s = 0, c = a.itemSize * e;
              s < o.length;
              s++, c++
            )
              r[c] = o[s];
        return this;
      }
      console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', t);
    },
    normalizeNormals: (function () {
      const t = new a();
      return function () {
        for (let e = this.attributes.normal, i = 0, n = e.count; i < n; i++)
          ((t.x = e.getX(i)), (t.y = e.getY(i)), (t.z = e.getZ(i)), t.normalize(), e.setXYZ(i, t.x, t.y, t.z));
      };
    })(),
    toNonIndexed: function () {
      if (null === this.index)
        return (console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.'), this);
      const t = new K(),
        e = this.index.array,
        i = this.attributes;
      for (const n in i) {
        for (
          var r = i[n],
            a = r.array,
            o = r.itemSize,
            s = new a.constructor(e.length * o),
            c = 0,
            h = 0,
            l = 0,
            u = e.length;
          l < u;
          l++
        ) {
          c = e[l] * o;
          for (let p = 0; p < o; p++) s[h++] = a[c++];
        }
        t.addAttribute(n, new G(s, o));
      }
      return t;
    },
    toJSON: function () {
      const t = { metadata: { version: 4.5, type: 'BufferGeometry', generator: 'BufferGeometry.toJSON' } };
      if (
        ((t.uuid = this.uuid),
        (t.type = this.type),
        '' !== this.name && (t.name = this.name),
        void 0 !== this.parameters)
      ) {
        const e = this.parameters;
        for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
        return t;
      }
      t.data = { attributes: {} };
      const n = this.index;
      if (null !== n) {
        o = Array.prototype.slice.call(n.array);
        t.data.index = { type: n.array.constructor.name, array: o };
      }
      const r = this.attributes;
      for (var i in r) {
        var a = r[i],
          o = Array.prototype.slice.call(a.array);
        t.data.attributes[i] = {
          itemSize: a.itemSize,
          type: a.array.constructor.name,
          array: o,
          normalized: a.normalized,
        };
      }
      const s = this.groups;
      s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
      const c = this.boundingSphere;
      return (null !== c && (t.data.boundingSphere = { center: c.center.toArray(), radius: c.radius }), t);
    },
    clone: function () {
      return new K().copy(this);
    },
    copy: function (t) {
      let e, i, n;
      ((this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.name = t.name));
      const r = t.index;
      null !== r && this.setIndex(r.clone());
      const a = t.attributes;
      for (e in a) {
        const o = a[e];
        this.addAttribute(e, o.clone());
      }
      const s = t.morphAttributes;
      for (e in s) {
        const c = [],
          h = s[e];
        for (i = 0, n = h.length; i < n; i++) c.push(h[i].clone());
        this.morphAttributes[e] = c;
      }
      const l = t.groups;
      for (i = 0, n = l.length; i < n; i++) {
        const u = l[i];
        this.addGroup(u.start, u.count, u.materialIndex);
      }
      const p = t.boundingBox;
      null !== p && (this.boundingBox = p.clone());
      const d = t.boundingSphere;
      return (
        null !== d && (this.boundingSphere = d.clone()),
        (this.drawRange.start = t.drawRange.start),
        (this.drawRange.count = t.drawRange.count),
        this
      );
    },
    dispose: function () {
      this.dispatchEvent({ type: 'dispose' });
    },
  }),
    (($.prototype = Object.create(z.prototype)).constructor = $),
    ((tt.prototype = Object.create(K.prototype)).constructor = tt),
    ((et.prototype = Object.create(z.prototype)).constructor = et),
    ((it.prototype = Object.create(K.prototype)).constructor = it),
    ((nt.prototype = Object.create(T.prototype)).constructor = nt),
    (nt.prototype.isMeshBasicMaterial = !0),
    (nt.prototype.copy = function (t) {
      return (
        T.prototype.copy.call(this, t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        this
      );
    }),
    ((rt.prototype = Object.create(T.prototype)).constructor = rt),
    (rt.prototype.isShaderMaterial = !0),
    (rt.prototype.copy = function (t) {
      return (
        T.prototype.copy.call(this, t),
        (this.fragmentShader = t.fragmentShader),
        (this.vertexShader = t.vertexShader),
        (this.uniforms = io.clone(t.uniforms)),
        (this.defines = t.defines),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.lights = t.lights),
        (this.clipping = t.clipping),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        (this.extensions = t.extensions),
        this
      );
    }),
    (rt.prototype.toJSON = function (t) {
      const e = T.prototype.toJSON.call(this, t);
      return (
        (e.uniforms = this.uniforms),
        (e.vertexShader = this.vertexShader),
        (e.fragmentShader = this.fragmentShader),
        e
      );
    }),
    Object.assign(at.prototype, {
      set: function (t, e) {
        return (this.origin.copy(t), this.direction.copy(e), this);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (this.origin.copy(t.origin), this.direction.copy(t.direction), this);
      },
      at: function (t, e) {
        return (e || new a()).copy(this.direction).multiplyScalar(t).add(this.origin);
      },
      lookAt: function (t) {
        return (this.direction.copy(t).sub(this.origin).normalize(), this);
      },
      recast: (function () {
        const t = new a();
        return function (e) {
          return (this.origin.copy(this.at(e, t)), this);
        };
      })(),
      closestPointToPoint: function (t, e) {
        const i = e || new a();
        i.subVectors(t, this.origin);
        const n = i.dot(this.direction);
        return n < 0 ? i.copy(this.origin) : i.copy(this.direction).multiplyScalar(n).add(this.origin);
      },
      distanceToPoint: function (t) {
        return Math.sqrt(this.distanceSqToPoint(t));
      },
      distanceSqToPoint: (function () {
        const t = new a();
        return function (e) {
          const i = t.subVectors(e, this.origin).dot(this.direction);
          return i < 0
            ? this.origin.distanceToSquared(e)
            : (t.copy(this.direction).multiplyScalar(i).add(this.origin), t.distanceToSquared(e));
        };
      })(),
      distanceSqToSegment: (function () {
        const t = new a(),
          e = new a(),
          i = new a();
        return function (n, r, a, o) {
          (t.copy(n).add(r).multiplyScalar(0.5), e.copy(r).sub(n).normalize(), i.copy(this.origin).sub(t));
          let s,
            c,
            h,
            l,
            u = 0.5 * n.distanceTo(r),
            p = -this.direction.dot(e),
            d = i.dot(this.direction),
            f = -i.dot(e),
            m = i.lengthSq(),
            v = Math.abs(1 - p * p);
          if (v > 0)
            if (((s = p * f - d), (c = p * d - f), (l = u * v), s >= 0))
              if (c >= -l)
                if (c <= l) {
                  const g = 1 / v;
                  h = (s *= g) * (s + p * (c *= g) + 2 * d) + c * (p * s + c + 2 * f) + m;
                } else ((c = u), (h = -(s = Math.max(0, -(p * c + d))) * s + c * (c + 2 * f) + m));
              else ((c = -u), (h = -(s = Math.max(0, -(p * c + d))) * s + c * (c + 2 * f) + m));
            else
              c <= -l
                ? (h =
                    -(s = Math.max(0, -(-p * u + d))) * s +
                    (c = s > 0 ? -u : Math.min(Math.max(-u, -f), u)) * (c + 2 * f) +
                    m)
                : c <= l
                  ? ((s = 0), (h = (c = Math.min(Math.max(-u, -f), u)) * (c + 2 * f) + m))
                  : (h =
                      -(s = Math.max(0, -(p * u + d))) * s +
                      (c = s > 0 ? u : Math.min(Math.max(-u, -f), u)) * (c + 2 * f) +
                      m);
          else ((c = p > 0 ? -u : u), (h = -(s = Math.max(0, -(p * c + d))) * s + c * (c + 2 * f) + m));
          return (
            a && a.copy(this.direction).multiplyScalar(s).add(this.origin),
            o && o.copy(e).multiplyScalar(c).add(t),
            h
          );
        };
      })(),
      intersectSphere: (function () {
        const t = new a();
        return function (e, i) {
          t.subVectors(e.center, this.origin);
          const n = t.dot(this.direction),
            r = t.dot(t) - n * n,
            a = e.radius * e.radius;
          if (r > a) return null;
          const o = Math.sqrt(a - r),
            s = n - o,
            c = n + o;
          return s < 0 && c < 0 ? null : s < 0 ? this.at(c, i) : this.at(s, i);
        };
      })(),
      intersectsSphere: function (t) {
        return this.distanceToPoint(t.center) <= t.radius;
      },
      distanceToPlane: function (t) {
        const e = t.normal.dot(this.direction);
        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
        const i = -(this.origin.dot(t.normal) + t.constant) / e;
        return i >= 0 ? i : null;
      },
      intersectPlane: function (t, e) {
        const i = this.distanceToPlane(t);
        return null === i ? null : this.at(i, e);
      },
      intersectsPlane: function (t) {
        const e = t.distanceToPoint(this.origin);
        if (0 === e) return !0;
        return t.normal.dot(this.direction) * e < 0;
      },
      intersectBox: function (t, e) {
        let i,
          n,
          r,
          a,
          o,
          s,
          c = 1 / this.direction.x,
          h = 1 / this.direction.y,
          l = 1 / this.direction.z,
          u = this.origin;
        return (
          c >= 0
            ? ((i = (t.min.x - u.x) * c), (n = (t.max.x - u.x) * c))
            : ((i = (t.max.x - u.x) * c), (n = (t.min.x - u.x) * c)),
          h >= 0
            ? ((r = (t.min.y - u.y) * h), (a = (t.max.y - u.y) * h))
            : ((r = (t.max.y - u.y) * h), (a = (t.min.y - u.y) * h)),
          i > a || r > n
            ? null
            : ((r > i || i != i) && (i = r),
              (a < n || n != n) && (n = a),
              l >= 0
                ? ((o = (t.min.z - u.z) * l), (s = (t.max.z - u.z) * l))
                : ((o = (t.max.z - u.z) * l), (s = (t.min.z - u.z) * l)),
              i > s || o > n
                ? null
                : ((o > i || i != i) && (i = o),
                  (s < n || n != n) && (n = s),
                  n < 0 ? null : this.at(i >= 0 ? i : n, e)))
        );
      },
      intersectsBox: (function () {
        const t = new a();
        return function (e) {
          return null !== this.intersectBox(e, t);
        };
      })(),
      intersectTriangle: (function () {
        const t = new a(),
          e = new a(),
          i = new a(),
          n = new a();
        return function (r, a, o, s, c) {
          (e.subVectors(a, r), i.subVectors(o, r), n.crossVectors(e, i));
          let h,
            l = this.direction.dot(n);
          if (l > 0) {
            if (s) return null;
            h = 1;
          } else {
            if (!(l < 0)) return null;
            ((h = -1), (l = -l));
          }
          t.subVectors(this.origin, r);
          const u = h * this.direction.dot(i.crossVectors(t, i));
          if (u < 0) return null;
          const p = h * this.direction.dot(e.cross(t));
          if (p < 0) return null;
          if (u + p > l) return null;
          const d = -h * t.dot(n);
          return d < 0 ? null : this.at(d / l, c);
        };
      })(),
      applyMatrix4: function (t) {
        return (this.origin.applyMatrix4(t), this.direction.transformDirection(t), this);
      },
      equals: function (t) {
        return t.origin.equals(this.origin) && t.direction.equals(this.direction);
      },
    }),
    Object.assign(ot.prototype, {
      set: function (t, e) {
        return (this.start.copy(t), this.end.copy(e), this);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (this.start.copy(t.start), this.end.copy(t.end), this);
      },
      getCenter: function (t) {
        return (t || new a()).addVectors(this.start, this.end).multiplyScalar(0.5);
      },
      delta: function (t) {
        return (t || new a()).subVectors(this.end, this.start);
      },
      distanceSq: function () {
        return this.start.distanceToSquared(this.end);
      },
      distance: function () {
        return this.start.distanceTo(this.end);
      },
      at: function (t, e) {
        const i = e || new a();
        return this.delta(i).multiplyScalar(t).add(this.start);
      },
      closestPointToPointParameter: (function () {
        const t = new a(),
          e = new a();
        return function (i, n) {
          (t.subVectors(i, this.start), e.subVectors(this.end, this.start));
          let r = e.dot(e),
            a = e.dot(t) / r;
          return (n && (a = Wa.clamp(a, 0, 1)), a);
        };
      })(),
      closestPointToPoint: function (t, e, i) {
        const n = this.closestPointToPointParameter(t, e),
          r = i || new a();
        return this.delta(r).multiplyScalar(n).add(this.start);
      },
      applyMatrix4: function (t) {
        return (this.start.applyMatrix4(t), this.end.applyMatrix4(t), this);
      },
      equals: function (t) {
        return t.start.equals(this.start) && t.end.equals(this.end);
      },
    }),
    Object.assign(st, {
      normal: (function () {
        const t = new a();
        return function (e, i, n, r) {
          const o = r || new a();
          (o.subVectors(n, i), t.subVectors(e, i), o.cross(t));
          const s = o.lengthSq();
          return s > 0 ? o.multiplyScalar(1 / Math.sqrt(s)) : o.set(0, 0, 0);
        };
      })(),
      barycoordFromPoint: (function () {
        const t = new a(),
          e = new a(),
          i = new a();
        return function (n, r, o, s, c) {
          (t.subVectors(s, r), e.subVectors(o, r), i.subVectors(n, r));
          const h = t.dot(t),
            l = t.dot(e),
            u = t.dot(i),
            p = e.dot(e),
            d = e.dot(i),
            f = h * p - l * l,
            m = c || new a();
          if (0 === f) return m.set(-2, -1, -1);
          const v = 1 / f,
            g = (p * u - l * d) * v,
            y = (h * d - l * u) * v;
          return m.set(1 - g - y, y, g);
        };
      })(),
      containsPoint: (function () {
        const t = new a();
        return function (e, i, n, r) {
          const a = st.barycoordFromPoint(e, i, n, r, t);
          return a.x >= 0 && a.y >= 0 && a.x + a.y <= 1;
        };
      })(),
    }),
    Object.assign(st.prototype, {
      set: function (t, e, i) {
        return (this.a.copy(t), this.b.copy(e), this.c.copy(i), this);
      },
      setFromPointsAndIndices: function (t, e, i, n) {
        return (this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this);
      },
      area: (function () {
        const t = new a(),
          e = new a();
        return function () {
          return (t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), 0.5 * t.cross(e).length());
        };
      })(),
      midpoint: function (t) {
        return (t || new a())
          .addVectors(this.a, this.b)
          .add(this.c)
          .multiplyScalar(1 / 3);
      },
      normal: function (t) {
        return st.normal(this.a, this.b, this.c, t);
      },
      plane: function (t) {
        return (t || new P()).setFromCoplanarPoints(this.a, this.b, this.c);
      },
      barycoordFromPoint: function (t, e) {
        return st.barycoordFromPoint(t, this.a, this.b, this.c, e);
      },
      containsPoint: function (t) {
        return st.containsPoint(t, this.a, this.b, this.c);
      },
      closestPointToPoint: (function () {
        const t = new P(),
          e = [new ot(), new ot(), new ot()],
          i = new a(),
          n = new a();
        return function (r, o) {
          let s = o || new a(),
            c = 1 / 0;
          if ((t.setFromCoplanarPoints(this.a, this.b, this.c), t.projectPoint(r, i), !0 === this.containsPoint(i)))
            s.copy(i);
          else {
            (e[0].set(this.a, this.b), e[1].set(this.b, this.c), e[2].set(this.c, this.a));
            for (let h = 0; h < e.length; h++) {
              e[h].closestPointToPoint(i, !0, n);
              const l = i.distanceToSquared(n);
              l < c && ((c = l), s.copy(n));
            }
          }
          return s;
        };
      })(),
      equals: function (t) {
        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
      },
    }),
    (ct.prototype = Object.assign(Object.create(U.prototype), {
      constructor: ct,
      isMesh: !0,
      setDrawMode: function (t) {
        this.drawMode = t;
      },
      copy: function (t) {
        return (
          U.prototype.copy.call(this, t),
          (this.drawMode = t.drawMode),
          void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
          void 0 !== t.morphTargetDictionary &&
            (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
          this
        );
      },
      updateMorphTargets: function () {
        let t,
          e,
          i,
          n = this.geometry;
        if (n.isBufferGeometry) {
          const r = n.morphAttributes,
            a = Object.keys(r);
          if (a.length > 0) {
            const o = r[a[0]];
            if (void 0 !== o)
              for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = o.length; t < e; t++)
                ((i = o[t].name || String(t)), this.morphTargetInfluences.push(0), (this.morphTargetDictionary[i] = t));
          }
        } else {
          const s = n.morphTargets;
          if (void 0 !== s && s.length > 0)
            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = s.length; t < e; t++)
              ((i = s[t].name || String(t)), this.morphTargetInfluences.push(0), (this.morphTargetDictionary[i] = t));
        }
      },
      raycast: (function () {
        function t(t, e, i, n, r, a, o) {
          return (
            st.barycoordFromPoint(t, e, i, n, y),
            r.multiplyScalar(y.x),
            a.multiplyScalar(y.y),
            o.multiplyScalar(y.z),
            r.add(a).add(o),
            r.clone()
          );
        }
        function e(t, e, i, n, r, a, o, s) {
          if (
            null ===
            (e.side === Jn ? n.intersectTriangle(o, a, r, !0, s) : n.intersectTriangle(r, a, o, e.side !== Kn, s))
          )
            return null;
          (b.copy(s), b.applyMatrix4(t.matrixWorld));
          const c = i.ray.origin.distanceTo(b);
          return c < i.near || c > i.far ? null : { distance: c, point: b.clone(), object: t };
        }
        function r(i, n, r, a, o, s, c, p) {
          (h.fromBufferAttribute(a, s), l.fromBufferAttribute(a, c), u.fromBufferAttribute(a, p));
          const d = e(i, i.material, n, r, h, l, u, x);
          return (
            d &&
              (o &&
                (m.fromBufferAttribute(o, s),
                v.fromBufferAttribute(o, c),
                g.fromBufferAttribute(o, p),
                (d.uv = t(x, h, l, u, m, v, g))),
              (d.face = new F(s, c, p, st.normal(h, l, u))),
              (d.faceIndex = s)),
            d
          );
        }
        var o = new n(),
          s = new at(),
          c = new L(),
          h = new a(),
          l = new a(),
          u = new a(),
          p = new a(),
          d = new a(),
          f = new a(),
          m = new i(),
          v = new i(),
          g = new i(),
          y = new a(),
          x = new a(),
          b = new a();
        return function (i, n) {
          const a = this.geometry,
            y = this.material,
            b = this.matrixWorld;
          if (
            void 0 !== y &&
            (null === a.boundingSphere && a.computeBoundingSphere(),
            c.copy(a.boundingSphere),
            c.applyMatrix4(b),
            !1 !== i.ray.intersectsSphere(c) &&
              (o.getInverse(b),
              s.copy(i.ray).applyMatrix4(o),
              null === a.boundingBox || !1 !== s.intersectsBox(a.boundingBox)))
          ) {
            let _;
            if (a.isBufferGeometry) {
              let w,
                E,
                M,
                T,
                S,
                A = a.index,
                R = a.attributes.position,
                L = a.attributes.uv;
              if (null !== A)
                for (T = 0, S = A.count; T < S; T += 3)
                  ((w = A.getX(T)),
                    (E = A.getX(T + 1)),
                    (M = A.getX(T + 2)),
                    (_ = r(this, i, s, R, L, w, E, M)) && ((_.faceIndex = Math.floor(T / 3)), n.push(_)));
              else if (void 0 !== R)
                for (T = 0, S = R.count; T < S; T += 3)
                  (_ = r(this, i, s, R, L, (w = T), (E = T + 1), (M = T + 2))) && ((_.index = w), n.push(_));
            } else if (a.isGeometry) {
              let P,
                C,
                I,
                D,
                O = Array.isArray(y),
                U = a.vertices,
                N = a.faces,
                B = a.faceVertexUvs[0];
              B.length > 0 && (D = B);
              for (let F = 0, z = N.length; F < z; F++) {
                const G = N[F],
                  H = O ? y[G.materialIndex] : y;
                if (void 0 !== H) {
                  if (((P = U[G.a]), (C = U[G.b]), (I = U[G.c]), !0 === H.morphTargets)) {
                    const V = a.morphTargets,
                      k = this.morphTargetInfluences;
                    (h.set(0, 0, 0), l.set(0, 0, 0), u.set(0, 0, 0));
                    for (let j = 0, W = V.length; j < W; j++) {
                      const X = k[j];
                      if (0 !== X) {
                        const q = V[j].vertices;
                        (h.addScaledVector(p.subVectors(q[G.a], P), X),
                          l.addScaledVector(d.subVectors(q[G.b], C), X),
                          u.addScaledVector(f.subVectors(q[G.c], I), X));
                      }
                    }
                    (h.add(P), l.add(C), u.add(I), (P = h), (C = l), (I = u));
                  }
                  if ((_ = e(this, H, i, s, P, C, I, x))) {
                    if (D && D[F]) {
                      const Y = D[F];
                      (m.copy(Y[0]), v.copy(Y[1]), g.copy(Y[2]), (_.uv = t(x, P, C, I, m, v, g)));
                    }
                    ((_.face = G), (_.faceIndex = F), n.push(_));
                  }
                }
              }
            }
          }
        };
      })(),
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      },
    })));
  var ho = 0;
  ((vt.prototype = Object.assign(Object.create(N.prototype), {
    constructor: vt,
    isPerspectiveCamera: !0,
    copy: function (t, e) {
      return (
        N.prototype.copy.call(this, t, e),
        (this.fov = t.fov),
        (this.zoom = t.zoom),
        (this.near = t.near),
        (this.far = t.far),
        (this.focus = t.focus),
        (this.aspect = t.aspect),
        (this.view = null === t.view ? null : Object.assign({}, t.view)),
        (this.filmGauge = t.filmGauge),
        (this.filmOffset = t.filmOffset),
        this
      );
    },
    setFocalLength: function (t) {
      const e = (0.5 * this.getFilmHeight()) / t;
      ((this.fov = 2 * Wa.RAD2DEG * Math.atan(e)), this.updateProjectionMatrix());
    },
    getFocalLength: function () {
      const t = Math.tan(0.5 * Wa.DEG2RAD * this.fov);
      return (0.5 * this.getFilmHeight()) / t;
    },
    getEffectiveFOV: function () {
      return 2 * Wa.RAD2DEG * Math.atan(Math.tan(0.5 * Wa.DEG2RAD * this.fov) / this.zoom);
    },
    getFilmWidth: function () {
      return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function () {
      return this.filmGauge / Math.max(this.aspect, 1);
    },
    setViewOffset: function (t, e, i, n, r, a) {
      ((this.aspect = t / e),
        null === this.view &&
          (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }),
        (this.view.enabled = !0),
        (this.view.fullWidth = t),
        (this.view.fullHeight = e),
        (this.view.offsetX = i),
        (this.view.offsetY = n),
        (this.view.width = r),
        (this.view.height = a),
        this.updateProjectionMatrix());
    },
    clearViewOffset: function () {
      (null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix());
    },
    updateProjectionMatrix: function () {
      let t = this.near,
        e = (t * Math.tan(0.5 * Wa.DEG2RAD * this.fov)) / this.zoom,
        i = 2 * e,
        n = this.aspect * i,
        r = -0.5 * n,
        a = this.view;
      if (null !== this.view && this.view.enabled) {
        const o = a.fullWidth,
          s = a.fullHeight;
        ((r += (a.offsetX * n) / o), (e -= (a.offsetY * i) / s), (n *= a.width / o), (i *= a.height / s));
      }
      const c = this.filmOffset;
      (0 !== c && (r += (t * c) / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far));
    },
    toJSON: function (t) {
      const e = U.prototype.toJSON.call(this, t);
      return (
        (e.object.fov = this.fov),
        (e.object.zoom = this.zoom),
        (e.object.near = this.near),
        (e.object.far = this.far),
        (e.object.focus = this.focus),
        (e.object.aspect = this.aspect),
        null !== this.view && (e.object.view = Object.assign({}, this.view)),
        (e.object.filmGauge = this.filmGauge),
        (e.object.filmOffset = this.filmOffset),
        e
      );
    },
  })),
    (gt.prototype = Object.assign(Object.create(vt.prototype), { constructor: gt, isArrayCamera: !0 })),
    (_t.prototype.isFogExp2 = !0),
    (_t.prototype.clone = function () {
      return new _t(this.color.getHex(), this.density);
    }),
    (_t.prototype.toJSON = function () {
      return { type: 'FogExp2', color: this.color.getHex(), density: this.density };
    }),
    (wt.prototype.isFog = !0),
    (wt.prototype.clone = function () {
      return new wt(this.color.getHex(), this.near, this.far);
    }),
    (wt.prototype.toJSON = function () {
      return { type: 'Fog', color: this.color.getHex(), near: this.near, far: this.far };
    }),
    (Et.prototype = Object.assign(Object.create(U.prototype), {
      constructor: Et,
      copy: function (t, e) {
        return (
          U.prototype.copy.call(this, t, e),
          null !== t.background && (this.background = t.background.clone()),
          null !== t.fog && (this.fog = t.fog.clone()),
          null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
          (this.autoUpdate = t.autoUpdate),
          (this.matrixAutoUpdate = t.matrixAutoUpdate),
          this
        );
      },
      toJSON: function (t) {
        const e = U.prototype.toJSON.call(this, t);
        return (
          null !== this.background && (e.object.background = this.background.toJSON(t)),
          null !== this.fog && (e.object.fog = this.fog.toJSON()),
          e
        );
      },
    })),
    (Mt.prototype = Object.assign(Object.create(U.prototype), {
      constructor: Mt,
      isLensFlare: !0,
      copy: function (t) {
        (U.prototype.copy.call(this, t),
          this.positionScreen.copy(t.positionScreen),
          (this.customUpdateCallback = t.customUpdateCallback));
        for (let e = 0, i = t.lensFlares.length; e < i; e++) this.lensFlares.push(t.lensFlares[e]);
        return this;
      },
      add: function (t, e, i, n, r, a) {
        (void 0 === e && (e = -1),
          void 0 === i && (i = 0),
          void 0 === a && (a = 1),
          void 0 === r && (r = new w(16777215)),
          void 0 === n && (n = nr),
          (i = Math.min(i, Math.max(0, i))),
          this.lensFlares.push({
            texture: t,
            size: e,
            distance: i,
            x: 0,
            y: 0,
            z: 0,
            scale: 1,
            rotation: 0,
            opacity: a,
            color: r,
            blending: n,
          }));
      },
      updateLensFlares: function () {
        let t,
          e,
          i = this.lensFlares.length,
          n = 2 * -this.positionScreen.x,
          r = 2 * -this.positionScreen.y;
        for (t = 0; t < i; t++)
          (((e = this.lensFlares[t]).x = this.positionScreen.x + n * e.distance),
            (e.y = this.positionScreen.y + r * e.distance),
            (e.wantedRotation = e.x * Math.PI * 0.25),
            (e.rotation += 0.25 * (e.wantedRotation - e.rotation)));
      },
    })),
    ((Tt.prototype = Object.create(T.prototype)).constructor = Tt),
    (Tt.prototype.isSpriteMaterial = !0),
    (Tt.prototype.copy = function (t) {
      return (
        T.prototype.copy.call(this, t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.rotation = t.rotation),
        this
      );
    }),
    (St.prototype = Object.assign(Object.create(U.prototype), {
      constructor: St,
      isSprite: !0,
      raycast: (function () {
        const t = new a(),
          e = new a(),
          i = new a();
        return function (n, r) {
          (e.setFromMatrixPosition(this.matrixWorld),
            n.ray.closestPointToPoint(e, t),
            i.setFromMatrixScale(this.matrixWorld));
          const a = (i.x * i.y) / 4;
          if (!(e.distanceToSquared(t) > a)) {
            const o = n.ray.origin.distanceTo(t);
            o < n.near || o > n.far || r.push({ distance: o, point: t.clone(), face: null, object: this });
          }
        };
      })(),
      clone: function () {
        return new this.constructor(this.material).copy(this);
      },
    })),
    (At.prototype = Object.assign(Object.create(U.prototype), {
      constructor: At,
      copy: function (t) {
        U.prototype.copy.call(this, t, !1);
        for (let e = t.levels, i = 0, n = e.length; i < n; i++) {
          const r = e[i];
          this.addLevel(r.object.clone(), r.distance);
        }
        return this;
      },
      addLevel: function (t, e) {
        (void 0 === e && (e = 0), (e = Math.abs(e)));
        for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++);
        (i.splice(n, 0, { distance: e, object: t }), this.add(t));
      },
      getObjectForDistance: function (t) {
        for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++);
        return e[i - 1].object;
      },
      raycast: (function () {
        const t = new a();
        return function (e, i) {
          t.setFromMatrixPosition(this.matrixWorld);
          const n = e.ray.origin.distanceTo(t);
          this.getObjectForDistance(n).raycast(e, i);
        };
      })(),
      update: (function () {
        const t = new a(),
          e = new a();
        return function (i) {
          const n = this.levels;
          if (n.length > 1) {
            (t.setFromMatrixPosition(i.matrixWorld), e.setFromMatrixPosition(this.matrixWorld));
            const r = t.distanceTo(e);
            n[0].object.visible = !0;
            for (var a = 1, o = n.length; a < o && r >= n[a].distance; a++)
              ((n[a - 1].object.visible = !1), (n[a].object.visible = !0));
            for (; a < o; a++) n[a].object.visible = !1;
          }
        };
      })(),
      toJSON: function (t) {
        const e = U.prototype.toJSON.call(this, t);
        e.object.levels = [];
        for (let i = this.levels, n = 0, r = i.length; n < r; n++) {
          const a = i[n];
          e.object.levels.push({ object: a.object.uuid, distance: a.distance });
        }
        return e;
      },
    })),
    Object.assign(Rt.prototype, {
      calculateInverses: function () {
        this.boneInverses = [];
        for (let t = 0, e = this.bones.length; t < e; t++) {
          const i = new n();
          (this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i));
        }
      },
      pose: function () {
        let t, e, i;
        for (e = 0, i = this.bones.length; e < i; e++)
          (t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
        for (e = 0, i = this.bones.length; e < i; e++)
          (t = this.bones[e]) &&
            (t.parent && t.parent.isBone
              ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld))
              : t.matrix.copy(t.matrixWorld),
            t.matrix.decompose(t.position, t.quaternion, t.scale));
      },
      update: (function () {
        const t = new n(),
          e = new n();
        return function () {
          for (
            var i = this.bones, n = this.boneInverses, r = this.boneMatrices, a = this.boneTexture, o = 0, s = i.length;
            o < s;
            o++
          ) {
            const c = i[o] ? i[o].matrixWorld : e;
            (t.multiplyMatrices(c, n[o]), t.toArray(r, 16 * o));
          }
          void 0 !== a && (a.needsUpdate = !0);
        };
      })(),
      clone: function () {
        return new Rt(this.bones, this.boneInverses);
      },
    }),
    (Lt.prototype = Object.assign(Object.create(U.prototype), { constructor: Lt, isBone: !0 })),
    (Pt.prototype = Object.assign(Object.create(ct.prototype), {
      constructor: Pt,
      isSkinnedMesh: !0,
      initBones: function () {
        let t,
          e,
          i,
          n,
          r = [];
        if (this.geometry && void 0 !== this.geometry.bones) {
          for (i = 0, n = this.geometry.bones.length; i < n; i++)
            ((e = this.geometry.bones[i]),
              (t = new Lt()),
              r.push(t),
              (t.name = e.name),
              t.position.fromArray(e.pos),
              t.quaternion.fromArray(e.rotq),
              void 0 !== e.scl && t.scale.fromArray(e.scl));
          for (i = 0, n = this.geometry.bones.length; i < n; i++)
            -1 !== (e = this.geometry.bones[i]).parent && null !== e.parent && void 0 !== r[e.parent]
              ? r[e.parent].add(r[i])
              : this.add(r[i]);
        }
        return (this.updateMatrixWorld(!0), r);
      },
      bind: function (t, e) {
        ((this.skeleton = t),
          void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), (e = this.matrixWorld)),
          this.bindMatrix.copy(e),
          this.bindMatrixInverse.getInverse(e));
      },
      pose: function () {
        this.skeleton.pose();
      },
      normalizeSkinWeights: function () {
        let t, e;
        if (this.geometry && this.geometry.isGeometry)
          for (e = 0; e < this.geometry.skinWeights.length; e++) {
            const i = this.geometry.skinWeights[e];
            (t = 1 / i.manhattanLength()) !== 1 / 0 ? i.multiplyScalar(t) : i.set(1, 0, 0, 0);
          }
        else if (this.geometry && this.geometry.isBufferGeometry) {
          const n = new c(),
            r = this.geometry.attributes.skinWeight;
          for (e = 0; e < r.count; e++)
            ((n.x = r.getX(e)),
              (n.y = r.getY(e)),
              (n.z = r.getZ(e)),
              (n.w = r.getW(e)),
              (t = 1 / n.manhattanLength()) !== 1 / 0 ? n.multiplyScalar(t) : n.set(1, 0, 0, 0),
              r.setXYZW(e, n.x, n.y, n.z, n.w));
        }
      },
      updateMatrixWorld: function (t) {
        (ct.prototype.updateMatrixWorld.call(this, t),
          'attached' === this.bindMode
            ? this.bindMatrixInverse.getInverse(this.matrixWorld)
            : 'detached' === this.bindMode
              ? this.bindMatrixInverse.getInverse(this.bindMatrix)
              : console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode));
      },
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      },
    })),
    ((Ct.prototype = Object.create(T.prototype)).constructor = Ct),
    (Ct.prototype.isLineBasicMaterial = !0),
    (Ct.prototype.copy = function (t) {
      return (
        T.prototype.copy.call(this, t),
        this.color.copy(t.color),
        (this.linewidth = t.linewidth),
        (this.linecap = t.linecap),
        (this.linejoin = t.linejoin),
        this
      );
    }),
    (It.prototype = Object.assign(Object.create(U.prototype), {
      constructor: It,
      isLine: !0,
      raycast: (function () {
        const t = new n(),
          e = new at(),
          i = new L();
        return function (n, r) {
          const o = n.linePrecision,
            s = o * o,
            c = this.geometry,
            h = this.matrixWorld;
          if (
            (null === c.boundingSphere && c.computeBoundingSphere(),
            i.copy(c.boundingSphere),
            i.applyMatrix4(h),
            !1 !== n.ray.intersectsSphere(i))
          ) {
            (t.getInverse(h), e.copy(n.ray).applyMatrix4(t));
            const l = new a(),
              u = new a(),
              p = new a(),
              d = new a(),
              f = this && this.isLineSegments ? 2 : 1;
            if (c.isBufferGeometry) {
              const m = c.index,
                v = c.attributes.position.array;
              if (null !== m)
                for (var g = m.array, y = 0, x = g.length - 1; y < x; y += f) {
                  const b = g[y],
                    _ = g[y + 1];
                  (l.fromArray(v, 3 * b), u.fromArray(v, 3 * _));
                  if (!((M = e.distanceSqToSegment(l, u, d, p)) > s)) {
                    d.applyMatrix4(this.matrixWorld);
                    (T = n.ray.origin.distanceTo(d)) < n.near ||
                      T > n.far ||
                      r.push({
                        distance: T,
                        point: p.clone().applyMatrix4(this.matrixWorld),
                        index: y,
                        face: null,
                        faceIndex: null,
                        object: this,
                      });
                  }
                }
              else
                for (var y = 0, x = v.length / 3 - 1; y < x; y += f) {
                  (l.fromArray(v, 3 * y), u.fromArray(v, 3 * y + 3));
                  if (!((M = e.distanceSqToSegment(l, u, d, p)) > s)) {
                    d.applyMatrix4(this.matrixWorld);
                    (T = n.ray.origin.distanceTo(d)) < n.near ||
                      T > n.far ||
                      r.push({
                        distance: T,
                        point: p.clone().applyMatrix4(this.matrixWorld),
                        index: y,
                        face: null,
                        faceIndex: null,
                        object: this,
                      });
                  }
                }
            } else if (c.isGeometry)
              for (var w = c.vertices, E = w.length, y = 0; y < E - 1; y += f) {
                var M = e.distanceSqToSegment(w[y], w[y + 1], d, p);
                if (!(M > s)) {
                  d.applyMatrix4(this.matrixWorld);
                  var T = n.ray.origin.distanceTo(d);
                  T < n.near ||
                    T > n.far ||
                    r.push({
                      distance: T,
                      point: p.clone().applyMatrix4(this.matrixWorld),
                      index: y,
                      face: null,
                      faceIndex: null,
                      object: this,
                    });
                }
              }
          }
        };
      })(),
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      },
    })),
    (Dt.prototype = Object.assign(Object.create(It.prototype), { constructor: Dt, isLineSegments: !0 })),
    (Ot.prototype = Object.assign(Object.create(It.prototype), { constructor: Ot, isLineLoop: !0 })),
    ((Ut.prototype = Object.create(T.prototype)).constructor = Ut),
    (Ut.prototype.isPointsMaterial = !0),
    (Ut.prototype.copy = function (t) {
      return (
        T.prototype.copy.call(this, t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.size = t.size),
        (this.sizeAttenuation = t.sizeAttenuation),
        this
      );
    }),
    (Nt.prototype = Object.assign(Object.create(U.prototype), {
      constructor: Nt,
      isPoints: !0,
      raycast: (function () {
        const t = new n(),
          e = new at(),
          i = new L();
        return function (n, r) {
          function o(t, i) {
            const a = e.distanceSqToPoint(t);
            if (a < p) {
              const o = e.closestPointToPoint(t);
              o.applyMatrix4(h);
              const c = n.ray.origin.distanceTo(o);
              if (c < n.near || c > n.far) return;
              r.push({ distance: c, distanceToRay: Math.sqrt(a), point: o.clone(), index: i, face: null, object: s });
            }
          }
          var s = this,
            c = this.geometry,
            h = this.matrixWorld,
            l = n.params.Points.threshold;
          if (
            (null === c.boundingSphere && c.computeBoundingSphere(),
            i.copy(c.boundingSphere),
            i.applyMatrix4(h),
            (i.radius += l),
            !1 !== n.ray.intersectsSphere(i))
          ) {
            (t.getInverse(h), e.copy(n.ray).applyMatrix4(t));
            var u = l / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              p = u * u,
              d = new a();
            if (c.isBufferGeometry) {
              const f = c.index,
                m = c.attributes.position.array;
              if (null !== f)
                for (var v = f.array, g = 0, y = v.length; g < y; g++) {
                  const x = v[g];
                  (d.fromArray(m, 3 * x), o(d, x));
                }
              else for (var g = 0, b = m.length / 3; g < b; g++) (d.fromArray(m, 3 * g), o(d, g));
            } else for (var _ = c.vertices, g = 0, b = _.length; g < b; g++) o(_[g], g);
          }
        };
      })(),
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      },
    })),
    (Bt.prototype = Object.assign(Object.create(U.prototype), { constructor: Bt })),
    ((Ft.prototype = Object.create(s.prototype)).constructor = Ft),
    ((zt.prototype = Object.create(s.prototype)).constructor = zt),
    (zt.prototype.isCompressedTexture = !0),
    ((Gt.prototype = Object.create(s.prototype)).constructor = Gt),
    (Gt.prototype.isDepthTexture = !0),
    ((Ht.prototype = Object.create(K.prototype)).constructor = Ht),
    ((Vt.prototype = Object.create(z.prototype)).constructor = Vt),
    ((kt.prototype = Object.create(K.prototype)).constructor = kt),
    ((jt.prototype = Object.create(z.prototype)).constructor = jt),
    ((Wt.prototype = Object.create(K.prototype)).constructor = Wt),
    ((Xt.prototype = Object.create(z.prototype)).constructor = Xt),
    ((qt.prototype = Object.create(Wt.prototype)).constructor = qt),
    ((Yt.prototype = Object.create(z.prototype)).constructor = Yt),
    ((Zt.prototype = Object.create(Wt.prototype)).constructor = Zt),
    ((Qt.prototype = Object.create(z.prototype)).constructor = Qt),
    ((Jt.prototype = Object.create(Wt.prototype)).constructor = Jt),
    ((Kt.prototype = Object.create(z.prototype)).constructor = Kt),
    (($t.prototype = Object.create(Wt.prototype)).constructor = $t),
    ((te.prototype = Object.create(z.prototype)).constructor = te),
    ((ee.prototype = Object.create(K.prototype)).constructor = ee),
    ((ie.prototype = Object.create(z.prototype)).constructor = ie),
    ((ne.prototype = Object.create(K.prototype)).constructor = ne),
    ((re.prototype = Object.create(z.prototype)).constructor = re),
    ((ae.prototype = Object.create(K.prototype)).constructor = ae));
  var lo = {
      triangulate: function (t, e, i) {
        i = i || 2;
        let n = e && e.length,
          r = n ? e[0] * i : t.length,
          a = oe(t, 0, r, i, !0),
          o = [];
        if (!a) return o;
        let s, c, h, l, u, p, d;
        if (
          (n &&
            (a = (function (t, e, i, n) {
              let r,
                a,
                o,
                s = [];
              for (r = 0, a = e.length; r < a; r++)
                ((o = oe(t, e[r] * n, r < a - 1 ? e[r + 1] * n : t.length, n, !1)) === o.next && (o.steiner = !0),
                  s.push(
                    (function (t) {
                      let e = t,
                        i = t;
                      do {
                        (e.x < i.x && (i = e), (e = e.next));
                      } while (e !== t);
                      return i;
                    })(o)
                  ));
              for (
                s.sort(function (t, e) {
                  return t.x - e.x;
                }),
                  r = 0;
                r < s.length;
                r++
              )
                (!(function (t, e) {
                  if (
                    (e = (function (t, e) {
                      let i,
                        n = e,
                        r = t.x,
                        a = t.y,
                        o = -1 / 0;
                      do {
                        if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
                          const s = n.x + ((a - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
                          if (s <= r && s > o) {
                            if (((o = s), s === r)) {
                              if (a === n.y) return n;
                              if (a === n.next.y) return n.next;
                            }
                            i = n.x < n.next.x ? n : n.next;
                          }
                        }
                        n = n.next;
                      } while (n !== e);
                      if (!i) return null;
                      if (r === o) return i.prev;
                      let c,
                        h = i,
                        l = i.x,
                        u = i.y,
                        p = 1 / 0;
                      for (n = i.next; n !== h; )
                        (r >= n.x &&
                          n.x >= l &&
                          r !== n.x &&
                          le(a < u ? r : o, a, l, u, a < u ? o : r, a, n.x, n.y) &&
                          ((c = Math.abs(a - n.y) / (r - n.x)) < p || (c === p && n.x > i.x)) &&
                          fe(n, t) &&
                          ((i = n), (p = c)),
                          (n = n.next));
                      return i;
                    })(t, e))
                  ) {
                    const i = me(e, t);
                    se(i, i.next);
                  }
                })(s[r], i),
                  (i = se(i, i.next)));
              return i;
            })(t, e, a, i)),
          t.length > 80 * i)
        ) {
          ((s = h = t[0]), (c = l = t[1]));
          for (let f = i; f < r; f += i)
            ((u = t[f]), (p = t[f + 1]), u < s && (s = u), p < c && (c = p), u > h && (h = u), p > l && (l = p));
          d = 0 !== (d = Math.max(h - s, l - c)) ? 1 / d : 0;
        }
        return (ce(a, o, i, s, c, d), o);
      },
    },
    uo = {
      area: function (t) {
        for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
        return 0.5 * i;
      },
      isClockWise: function (t) {
        return uo.area(t) < 0;
      },
      triangulateShape: function (t, e) {
        function i(t) {
          const e = t.length;
          e > 2 && t[e - 1].equals(t[0]) && t.pop();
        }
        function n(t, e) {
          for (let i = 0; i < e.length; i++) (t.push(e[i].x), t.push(e[i].y));
        }
        const r = [],
          a = [],
          o = [];
        (i(t), n(r, t));
        let s = t.length;
        for (e.forEach(i), h = 0; h < e.length; h++) (a.push(s), (s += e[h].length), n(r, e[h]));
        for (var c = lo.triangulate(r, a), h = 0; h < c.length; h += 3) o.push(c.slice(h, h + 3));
        return o;
      },
    };
  (((xe.prototype = Object.create(z.prototype)).constructor = xe),
    ((be.prototype = Object.create(K.prototype)).constructor = be),
    (be.prototype.getArrays = function () {
      const t = this.getAttribute('position'),
        e = t ? Array.prototype.slice.call(t.array) : [],
        i = this.getAttribute('uv'),
        n = i ? Array.prototype.slice.call(i.array) : [],
        r = this.index;
      return { position: e, uv: n, index: r ? Array.prototype.slice.call(r.array) : [] };
    }),
    (be.prototype.addShapeList = function (t, e) {
      const i = t.length;
      e.arrays = this.getArrays();
      for (let n = 0; n < i; n++) {
        const r = t[n];
        this.addShape(r, e);
      }
      (this.setIndex(e.arrays.index),
        this.addAttribute('position', new Y(e.arrays.position, 3)),
        this.addAttribute('uv', new Y(e.arrays.uv, 2)));
    }),
    (be.prototype.addShape = function (t, e) {
      function n(t, e, i) {
        return (e || console.error('THREE.ExtrudeGeometry: vec does not exist'), e.clone().multiplyScalar(i).add(t));
      }
      function r(t, e, n) {
        let r,
          a,
          o,
          s = t.x - e.x,
          c = t.y - e.y,
          h = n.x - t.x,
          l = n.y - t.y,
          u = s * s + c * c,
          p = s * l - c * h;
        if (Math.abs(p) > Number.EPSILON) {
          const d = Math.sqrt(u),
            f = Math.sqrt(h * h + l * l),
            m = e.x - c / d,
            v = e.y + s / d,
            g = ((n.x - l / f - m) * l - (n.y + h / f - v) * h) / (s * l - c * h),
            y = (r = m + s * g - t.x) * r + (a = v + c * g - t.y) * a;
          if (y <= 2) return new i(r, a);
          o = Math.sqrt(y / 2);
        } else {
          let x = !1;
          (s > Number.EPSILON
            ? h > Number.EPSILON && (x = !0)
            : s < -Number.EPSILON
              ? h < -Number.EPSILON && (x = !0)
              : Math.sign(c) === Math.sign(l) && (x = !0),
            x ? ((r = -c), (a = s), (o = Math.sqrt(u))) : ((r = s), (a = c), (o = Math.sqrt(u / 2))));
        }
        return new i(r / o, a / o);
      }
      function o(t, e) {
        let i, n;
        for (Q = t.length; --Q >= 0; ) {
          ((i = Q), (n = Q - 1) < 0 && (n = t.length - 1));
          let r = 0,
            a = A + 2 * M;
          for (r = 0; r < a; r++) {
            const o = X * r,
              s = X * (r + 1);
            !(function (t, e, i, n) {
              (h(t), h(e), h(n), h(e), h(i), h(n));
              const r = g.length / 3,
                a = P.generateSideWallUV(O, g, r - 6, r - 3, r - 2, r - 1);
              (l(a[0]), l(a[1]), l(a[3]), l(a[1]), l(a[2]), l(a[3]));
            })(e + i + o, e + n + o, e + n + s, e + i + s);
          }
        }
      }
      function s(t, e, i) {
        (b.push(t), b.push(e), b.push(i));
      }
      function c(t, e, i) {
        (h(t), h(e), h(i));
        const n = g.length / 3,
          r = P.generateTopUV(O, g, n - 3, n - 2, n - 1);
        (l(r[0]), l(r[1]), l(r[2]));
      }
      function h(t) {
        (y.push(g.length / 3), g.push(b[3 * t + 0]), g.push(b[3 * t + 1]), g.push(b[3 * t + 2]));
      }
      function l(t) {
        (x.push(t.x), x.push(t.y));
      }
      var u,
        p,
        d,
        f,
        m,
        v = e.arrays ? e.arrays : this.getArrays(),
        g = v.position,
        y = v.index,
        x = v.uv,
        b = [],
        _ = void 0 !== e.amount ? e.amount : 100,
        w = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
        E = void 0 !== e.bevelSize ? e.bevelSize : w - 2,
        M = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
        T = void 0 === e.bevelEnabled || e.bevelEnabled,
        S = void 0 !== e.curveSegments ? e.curveSegments : 12,
        A = void 0 !== e.steps ? e.steps : 1,
        R = e.extrudePath,
        L = !1,
        P = void 0 !== e.UVGenerator ? e.UVGenerator : xe.WorldUVGenerator;
      (R &&
        ((u = R.getSpacedPoints(A)),
        (L = !0),
        (T = !1),
        (p = void 0 !== e.frames ? e.frames : R.computeFrenetFrames(A, !1)),
        (d = new a()),
        (f = new a()),
        (m = new a())),
        T || ((M = 0), (w = 0), (E = 0)));
      var C,
        I,
        D,
        O = this,
        U = t.extractPoints(S),
        N = U.shape,
        B = U.holes;
      if (!uo.isClockWise(N))
        for (N = N.reverse(), I = 0, D = B.length; I < D; I++) ((C = B[I]), uo.isClockWise(C) && (B[I] = C.reverse()));
      const F = uo.triangulateShape(N, B),
        z = N;
      for (I = 0, D = B.length; I < D; I++) ((C = B[I]), (N = N.concat(C)));
      for (
        var G, H, V, k, j, W, X = N.length, q = F.length, Z = [], Q = 0, J = z.length, K = J - 1, $ = Q + 1;
        Q < J;
        Q++, K++, $++
      )
        (K === J && (K = 0), $ === J && ($ = 0), (Z[Q] = r(z[Q], z[K], z[$])));
      let tt,
        et = [],
        it = Z.concat();
      for (I = 0, D = B.length; I < D; I++) {
        for (C = B[I], tt = [], Q = 0, K = (J = C.length) - 1, $ = Q + 1; Q < J; Q++, K++, $++)
          (K === J && (K = 0), $ === J && ($ = 0), (tt[Q] = r(C[Q], C[K], C[$])));
        (et.push(tt), (it = it.concat(tt)));
      }
      for (G = 0; G < M; G++) {
        for (
          V = G / M, k = w * Math.cos((V * Math.PI) / 2), H = E * Math.sin((V * Math.PI) / 2), Q = 0, J = z.length;
          Q < J;
          Q++
        )
          s((j = n(z[Q], Z[Q], H)).x, j.y, -k);
        for (I = 0, D = B.length; I < D; I++)
          for (C = B[I], tt = et[I], Q = 0, J = C.length; Q < J; Q++) s((j = n(C[Q], tt[Q], H)).x, j.y, -k);
      }
      for (H = E, Q = 0; Q < X; Q++)
        ((j = T ? n(N[Q], it[Q], H) : N[Q]),
          L
            ? (f.copy(p.normals[0]).multiplyScalar(j.x),
              d.copy(p.binormals[0]).multiplyScalar(j.y),
              m.copy(u[0]).add(f).add(d),
              s(m.x, m.y, m.z))
            : s(j.x, j.y, 0));
      let nt;
      for (nt = 1; nt <= A; nt++)
        for (Q = 0; Q < X; Q++)
          ((j = T ? n(N[Q], it[Q], H) : N[Q]),
            L
              ? (f.copy(p.normals[nt]).multiplyScalar(j.x),
                d.copy(p.binormals[nt]).multiplyScalar(j.y),
                m.copy(u[nt]).add(f).add(d),
                s(m.x, m.y, m.z))
              : s(j.x, j.y, (_ / A) * nt));
      for (G = M - 1; G >= 0; G--) {
        for (
          V = G / M, k = w * Math.cos((V * Math.PI) / 2), H = E * Math.sin((V * Math.PI) / 2), Q = 0, J = z.length;
          Q < J;
          Q++
        )
          s((j = n(z[Q], Z[Q], H)).x, j.y, _ + k);
        for (I = 0, D = B.length; I < D; I++)
          for (C = B[I], tt = et[I], Q = 0, J = C.length; Q < J; Q++)
            ((j = n(C[Q], tt[Q], H)), L ? s(j.x, j.y + u[A - 1].y, u[A - 1].x + k) : s(j.x, j.y, _ + k));
      }
      (!(function () {
        const t = g.length / 3;
        if (T) {
          let i = 0,
            n = X * i;
          for (Q = 0; Q < q; Q++) c((W = F[Q])[2] + n, W[1] + n, W[0] + n);
          for (n = X * (i = A + 2 * M), Q = 0; Q < q; Q++) c((W = F[Q])[0] + n, W[1] + n, W[2] + n);
        } else {
          for (Q = 0; Q < q; Q++) c((W = F[Q])[2], W[1], W[0]);
          for (Q = 0; Q < q; Q++) c((W = F[Q])[0] + X * A, W[1] + X * A, W[2] + X * A);
        }
        O.addGroup(t, g.length / 3 - t, void 0 !== e.material ? e.material : 0);
      })(),
        (function () {
          let t = g.length / 3,
            i = 0;
          for (o(z, i), i += z.length, I = 0, D = B.length; I < D; I++) (o((C = B[I]), i), (i += C.length));
          O.addGroup(t, g.length / 3 - t, void 0 !== e.extrudeMaterial ? e.extrudeMaterial : 1);
        })(),
        e.arrays ||
          (this.setIndex(y),
          this.addAttribute('position', new Y(g, 3)),
          this.addAttribute('uv', new Y(e.arrays.uv, 2))));
    }),
    (xe.WorldUVGenerator = {
      generateTopUV: function (t, e, n, r, a) {
        const o = e[3 * n],
          s = e[3 * n + 1],
          c = e[3 * r],
          h = e[3 * r + 1],
          l = e[3 * a],
          u = e[3 * a + 1];
        return [new i(o, s), new i(c, h), new i(l, u)];
      },
      generateSideWallUV: function (t, e, n, r, a, o) {
        const s = e[3 * n],
          c = e[3 * n + 1],
          h = e[3 * n + 2],
          l = e[3 * r],
          u = e[3 * r + 1],
          p = e[3 * r + 2],
          d = e[3 * a],
          f = e[3 * a + 1],
          m = e[3 * a + 2],
          v = e[3 * o],
          g = e[3 * o + 1],
          y = e[3 * o + 2];
        return Math.abs(c - u) < 0.01
          ? [new i(s, 1 - h), new i(l, 1 - p), new i(d, 1 - m), new i(v, 1 - y)]
          : [new i(c, 1 - h), new i(u, 1 - p), new i(f, 1 - m), new i(g, 1 - y)];
      },
    }),
    ((_e.prototype = Object.create(z.prototype)).constructor = _e),
    ((we.prototype = Object.create(be.prototype)).constructor = we),
    ((Ee.prototype = Object.create(z.prototype)).constructor = Ee),
    ((Me.prototype = Object.create(K.prototype)).constructor = Me),
    ((Te.prototype = Object.create(z.prototype)).constructor = Te),
    ((Se.prototype = Object.create(K.prototype)).constructor = Se),
    ((Ae.prototype = Object.create(z.prototype)).constructor = Ae),
    ((Re.prototype = Object.create(K.prototype)).constructor = Re),
    ((Le.prototype = Object.create(z.prototype)).constructor = Le),
    ((Pe.prototype = Object.create(K.prototype)).constructor = Pe),
    ((Ce.prototype = Object.create(K.prototype)).constructor = Ce),
    ((Ie.prototype = Object.create(z.prototype)).constructor = Ie),
    ((De.prototype = Object.create(K.prototype)).constructor = De),
    ((Oe.prototype = Object.create(Ie.prototype)).constructor = Oe),
    ((Ue.prototype = Object.create(De.prototype)).constructor = Ue),
    ((Ne.prototype = Object.create(z.prototype)).constructor = Ne),
    ((Be.prototype = Object.create(K.prototype)).constructor = Be));
  const po = Object.freeze({
    WireframeGeometry: Ht,
    ParametricGeometry: Vt,
    ParametricBufferGeometry: kt,
    TetrahedronGeometry: Xt,
    TetrahedronBufferGeometry: qt,
    OctahedronGeometry: Yt,
    OctahedronBufferGeometry: Zt,
    IcosahedronGeometry: Qt,
    IcosahedronBufferGeometry: Jt,
    DodecahedronGeometry: Kt,
    DodecahedronBufferGeometry: $t,
    PolyhedronGeometry: jt,
    PolyhedronBufferGeometry: Wt,
    TubeGeometry: te,
    TubeBufferGeometry: ee,
    TorusKnotGeometry: ie,
    TorusKnotBufferGeometry: ne,
    TorusGeometry: re,
    TorusBufferGeometry: ae,
    TextGeometry: _e,
    TextBufferGeometry: we,
    SphereGeometry: Ee,
    SphereBufferGeometry: Me,
    RingGeometry: Te,
    RingBufferGeometry: Se,
    PlaneGeometry: et,
    PlaneBufferGeometry: it,
    LatheGeometry: Ae,
    LatheBufferGeometry: Re,
    ShapeGeometry: Le,
    ShapeBufferGeometry: Pe,
    ExtrudeGeometry: xe,
    ExtrudeBufferGeometry: be,
    EdgesGeometry: Ce,
    ConeGeometry: Oe,
    ConeBufferGeometry: Ue,
    CylinderGeometry: Ie,
    CylinderBufferGeometry: De,
    CircleGeometry: Ne,
    CircleBufferGeometry: Be,
    BoxGeometry: $,
    BoxBufferGeometry: tt,
  });
  (((Fe.prototype = Object.create(T.prototype)).constructor = Fe),
    (Fe.prototype.isShadowMaterial = !0),
    ((ze.prototype = Object.create(rt.prototype)).constructor = ze),
    (ze.prototype.isRawShaderMaterial = !0),
    ((Ge.prototype = Object.create(T.prototype)).constructor = Ge),
    (Ge.prototype.isMeshStandardMaterial = !0),
    (Ge.prototype.copy = function (t) {
      return (
        T.prototype.copy.call(this, t),
        (this.defines = { STANDARD: '' }),
        this.color.copy(t.color),
        (this.roughness = t.roughness),
        (this.metalness = t.metalness),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.roughnessMap = t.roughnessMap),
        (this.metalnessMap = t.metalnessMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.envMapIntensity = t.envMapIntensity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        this
      );
    }),
    ((He.prototype = Object.create(Ge.prototype)).constructor = He),
    (He.prototype.isMeshPhysicalMaterial = !0),
    (He.prototype.copy = function (t) {
      return (
        Ge.prototype.copy.call(this, t),
        (this.defines = { PHYSICAL: '' }),
        (this.reflectivity = t.reflectivity),
        (this.clearCoat = t.clearCoat),
        (this.clearCoatRoughness = t.clearCoatRoughness),
        this
      );
    }),
    ((Ve.prototype = Object.create(T.prototype)).constructor = Ve),
    (Ve.prototype.isMeshPhongMaterial = !0),
    (Ve.prototype.copy = function (t) {
      return (
        T.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.specular.copy(t.specular),
        (this.shininess = t.shininess),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        this
      );
    }),
    ((ke.prototype = Object.create(Ve.prototype)).constructor = ke),
    (ke.prototype.isMeshToonMaterial = !0),
    (ke.prototype.copy = function (t) {
      return (Ve.prototype.copy.call(this, t), (this.gradientMap = t.gradientMap), this);
    }),
    ((je.prototype = Object.create(T.prototype)).constructor = je),
    (je.prototype.isMeshNormalMaterial = !0),
    (je.prototype.copy = function (t) {
      return (
        T.prototype.copy.call(this, t),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        this
      );
    }),
    ((We.prototype = Object.create(T.prototype)).constructor = We),
    (We.prototype.isMeshLambertMaterial = !0),
    (We.prototype.copy = function (t) {
      return (
        T.prototype.copy.call(this, t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        this
      );
    }),
    ((Xe.prototype = Object.create(Ct.prototype)).constructor = Xe),
    (Xe.prototype.isLineDashedMaterial = !0),
    (Xe.prototype.copy = function (t) {
      return (
        Ct.prototype.copy.call(this, t),
        (this.scale = t.scale),
        (this.dashSize = t.dashSize),
        (this.gapSize = t.gapSize),
        this
      );
    }));
  var fo = Object.freeze({
      ShadowMaterial: Fe,
      SpriteMaterial: Tt,
      RawShaderMaterial: ze,
      ShaderMaterial: rt,
      PointsMaterial: Ut,
      MeshPhysicalMaterial: He,
      MeshStandardMaterial: Ge,
      MeshPhongMaterial: Ve,
      MeshToonMaterial: ke,
      MeshNormalMaterial: je,
      MeshLambertMaterial: We,
      MeshDepthMaterial: S,
      MeshDistanceMaterial: A,
      MeshBasicMaterial: nt,
      LineDashedMaterial: Xe,
      LineBasicMaterial: Ct,
      Material: T,
    }),
    mo = {
      enabled: !1,
      files: {},
      add: function (t, e) {
        !1 !== this.enabled && (this.files[t] = e);
      },
      get: function (t) {
        if (!1 !== this.enabled) return this.files[t];
      },
      remove: function (t) {
        delete this.files[t];
      },
      clear: function () {
        this.files = {};
      },
    },
    vo = new qe(),
    go = {};
  (Object.assign(Ye.prototype, {
    load: function (t, e, i, n) {
      (void 0 === t && (t = ''), void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t)));
      const r = this,
        a = mo.get(t);
      if (void 0 !== a)
        return (
          r.manager.itemStart(t),
          setTimeout(function () {
            (e && e(a), r.manager.itemEnd(t));
          }, 0),
          a
        );
      if (void 0 === go[t]) {
        const o = t.match(/^data:(.*?)(;base64)?,(.*)$/);
        if (o) {
          let s = o[1],
            c = !!o[2],
            h = o[3];
          ((h = window.decodeURIComponent(h)), c && (h = window.atob(h)));
          try {
            let l,
              u = (this.responseType || '').toLowerCase();
            switch (u) {
              case 'arraybuffer':
              case 'blob':
                for (var p = new Uint8Array(h.length), d = 0; d < h.length; d++) p[d] = h.charCodeAt(d);
                l = 'blob' === u ? new Blob([p.buffer], { type: s }) : p.buffer;
                break;
              case 'document':
                var f = new DOMParser();
                l = f.parseFromString(h, s);
                break;
              case 'json':
                l = JSON.parse(h);
                break;
              default:
                l = h;
            }
            window.setTimeout(function () {
              (e && e(l), r.manager.itemEnd(t));
            }, 0);
          } catch (e) {
            window.setTimeout(function () {
              (n && n(e), r.manager.itemEnd(t), r.manager.itemError(t));
            }, 0);
          }
        } else {
          ((go[t] = []), go[t].push({ onLoad: e, onProgress: i, onError: n }));
          var m = new XMLHttpRequest();
          (m.open('GET', t, !0),
            m.addEventListener(
              'load',
              function (e) {
                const i = e.target.response;
                mo.add(t, i);
                const n = go[t];
                if ((delete go[t], 200 === this.status)) {
                  for (var a = 0, o = n.length; a < o; a++) {
                    (s = n[a]).onLoad && s.onLoad(i);
                  }
                  r.manager.itemEnd(t);
                } else if (0 === this.status) {
                  console.warn('THREE.FileLoader: HTTP Status 0 received.');
                  for (var a = 0, o = n.length; a < o; a++) {
                    (s = n[a]).onLoad && s.onLoad(i);
                  }
                  r.manager.itemEnd(t);
                } else {
                  for (var a = 0, o = n.length; a < o; a++) {
                    var s = n[a];
                    s.onError && s.onError(e);
                  }
                  (r.manager.itemEnd(t), r.manager.itemError(t));
                }
              },
              !1
            ),
            m.addEventListener(
              'progress',
              function (e) {
                for (let i = go[t], n = 0, r = i.length; n < r; n++) {
                  const a = i[n];
                  a.onProgress && a.onProgress(e);
                }
              },
              !1
            ),
            m.addEventListener(
              'error',
              function (e) {
                const i = go[t];
                delete go[t];
                for (let n = 0, a = i.length; n < a; n++) {
                  const o = i[n];
                  o.onError && o.onError(e);
                }
                (r.manager.itemEnd(t), r.manager.itemError(t));
              },
              !1
            ),
            void 0 !== this.responseType && (m.responseType = this.responseType),
            void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials),
            m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : 'text/plain'));
          for (const v in this.requestHeader) m.setRequestHeader(v, this.requestHeader[v]);
          m.send(null);
        }
        return (r.manager.itemStart(t), m);
      }
      go[t].push({ onLoad: e, onProgress: i, onError: n });
    },
    setPath: function (t) {
      return ((this.path = t), this);
    },
    setResponseType: function (t) {
      return ((this.responseType = t), this);
    },
    setWithCredentials: function (t) {
      return ((this.withCredentials = t), this);
    },
    setMimeType: function (t) {
      return ((this.mimeType = t), this);
    },
    setRequestHeader: function (t) {
      return ((this.requestHeader = t), this);
    },
  }),
    Object.assign(Ze.prototype, {
      load: function (t, e, i, n) {
        const r = this,
          a = [],
          o = new zt();
        o.image = a;
        const s = new Ye(this.manager);
        if ((s.setPath(this.path), s.setResponseType('arraybuffer'), Array.isArray(t)))
          for (var c = 0, h = 0, l = t.length; h < l; ++h)
            !(function (h) {
              s.load(
                t[h],
                function (t) {
                  const i = r._parser(t, !0);
                  ((a[h] = { width: i.width, height: i.height, format: i.format, mipmaps: i.mipmaps }),
                    6 === (c += 1) &&
                      (1 === i.mipmapCount && (o.minFilter = $r),
                      (o.format = i.format),
                      (o.needsUpdate = !0),
                      e && e(o)));
                },
                i,
                n
              );
            })(h);
        else
          s.load(
            t,
            function (t) {
              const i = r._parser(t, !0);
              if (i.isCubemap)
                for (let n = i.mipmaps.length / i.mipmapCount, s = 0; s < n; s++) {
                  a[s] = { mipmaps: [] };
                  for (let c = 0; c < i.mipmapCount; c++)
                    (a[s].mipmaps.push(i.mipmaps[s * i.mipmapCount + c]),
                      (a[s].format = i.format),
                      (a[s].width = i.width),
                      (a[s].height = i.height));
                }
              else ((o.image.width = i.width), (o.image.height = i.height), (o.mipmaps = i.mipmaps));
              (1 === i.mipmapCount && (o.minFilter = $r), (o.format = i.format), (o.needsUpdate = !0), e && e(o));
            },
            i,
            n
          );
        return o;
      },
      setPath: function (t) {
        return ((this.path = t), this);
      },
    }),
    Object.assign(Qe.prototype, {
      load: function (t, e, i, n) {
        const r = this,
          a = new u(),
          o = new Ye(this.manager);
        return (
          o.setResponseType('arraybuffer'),
          o.load(
            t,
            function (t) {
              const i = r._parser(t);
              i &&
                (void 0 !== i.image
                  ? (a.image = i.image)
                  : void 0 !== i.data &&
                    ((a.image.width = i.width), (a.image.height = i.height), (a.image.data = i.data)),
                (a.wrapS = void 0 !== i.wrapS ? i.wrapS : Yr),
                (a.wrapT = void 0 !== i.wrapT ? i.wrapT : Yr),
                (a.magFilter = void 0 !== i.magFilter ? i.magFilter : $r),
                (a.minFilter = void 0 !== i.minFilter ? i.minFilter : ea),
                (a.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1),
                void 0 !== i.format && (a.format = i.format),
                void 0 !== i.type && (a.type = i.type),
                void 0 !== i.mipmaps && (a.mipmaps = i.mipmaps),
                1 === i.mipmapCount && (a.minFilter = $r),
                (a.needsUpdate = !0),
                e && e(a, i));
            },
            i,
            n
          ),
          a
        );
      },
    }),
    Object.assign(Je.prototype, {
      crossOrigin: 'Anonymous',
      load: function (t, e, i, n) {
        (void 0 === t && (t = ''), void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t)));
        const r = this,
          a = mo.get(t);
        if (void 0 !== a)
          return (
            r.manager.itemStart(t),
            setTimeout(function () {
              (e && e(a), r.manager.itemEnd(t));
            }, 0),
            a
          );
        const o = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
        return (
          o.addEventListener(
            'load',
            function () {
              (mo.add(t, this), e && e(this), r.manager.itemEnd(t));
            },
            !1
          ),
          o.addEventListener(
            'error',
            function (e) {
              (n && n(e), r.manager.itemEnd(t), r.manager.itemError(t));
            },
            !1
          ),
          'data:' !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin),
          r.manager.itemStart(t),
          (o.src = t),
          o
        );
      },
      setCrossOrigin: function (t) {
        return ((this.crossOrigin = t), this);
      },
      setPath: function (t) {
        return ((this.path = t), this);
      },
    }),
    Object.assign(Ke.prototype, {
      crossOrigin: 'Anonymous',
      load: function (t, e, i, n) {
        const r = new p(),
          a = new Je(this.manager);
        (a.setCrossOrigin(this.crossOrigin), a.setPath(this.path));
        for (var o = 0, s = 0; s < t.length; ++s)
          !(function (i) {
            a.load(
              t[i],
              function (t) {
                ((r.images[i] = t), 6 == ++o && ((r.needsUpdate = !0), e && e(r)));
              },
              void 0,
              n
            );
          })(s);
        return r;
      },
      setCrossOrigin: function (t) {
        return ((this.crossOrigin = t), this);
      },
      setPath: function (t) {
        return ((this.path = t), this);
      },
    }),
    Object.assign($e.prototype, {
      crossOrigin: 'Anonymous',
      load: function (t, e, i, n) {
        const r = new s(),
          a = new Je(this.manager);
        return (
          a.setCrossOrigin(this.crossOrigin),
          a.setPath(this.path),
          a.load(
            t,
            function (i) {
              r.image = i;
              const n = t.search(/\.(jpg|jpeg)$/) > 0 || 0 === t.search(/^data\:image\/jpeg/);
              ((r.format = n ? ma : va), (r.needsUpdate = !0), void 0 !== e && e(r));
            },
            i,
            n
          ),
          r
        );
      },
      setCrossOrigin: function (t) {
        return ((this.crossOrigin = t), this);
      },
      setPath: function (t) {
        return ((this.path = t), this);
      },
    }),
    (ti.prototype = Object.assign(Object.create(U.prototype), {
      constructor: ti,
      isLight: !0,
      copy: function (t) {
        return (U.prototype.copy.call(this, t), this.color.copy(t.color), (this.intensity = t.intensity), this);
      },
      toJSON: function (t) {
        const e = U.prototype.toJSON.call(this, t);
        return (
          (e.object.color = this.color.getHex()),
          (e.object.intensity = this.intensity),
          void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
          void 0 !== this.distance && (e.object.distance = this.distance),
          void 0 !== this.angle && (e.object.angle = this.angle),
          void 0 !== this.decay && (e.object.decay = this.decay),
          void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
          void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
          e
        );
      },
    })),
    (ei.prototype = Object.assign(Object.create(ti.prototype), {
      constructor: ei,
      isHemisphereLight: !0,
      copy: function (t) {
        return (ti.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this);
      },
    })),
    Object.assign(ii.prototype, {
      copy: function (t) {
        return (
          (this.camera = t.camera.clone()),
          (this.bias = t.bias),
          (this.radius = t.radius),
          this.mapSize.copy(t.mapSize),
          this
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      toJSON: function () {
        const t = {};
        return (
          0 !== this.bias && (t.bias = this.bias),
          1 !== this.radius && (t.radius = this.radius),
          (512 === this.mapSize.x && 512 === this.mapSize.y) || (t.mapSize = this.mapSize.toArray()),
          (t.camera = this.camera.toJSON(!1).object),
          delete t.camera.matrix,
          t
        );
      },
    }),
    (ni.prototype = Object.assign(Object.create(ii.prototype), {
      constructor: ni,
      isSpotLightShadow: !0,
      update: function (t) {
        const e = this.camera,
          i = 2 * Wa.RAD2DEG * t.angle,
          n = this.mapSize.width / this.mapSize.height,
          r = t.distance || e.far;
        (i === e.fov && n === e.aspect && r === e.far) ||
          ((e.fov = i), (e.aspect = n), (e.far = r), e.updateProjectionMatrix());
      },
    })),
    (ri.prototype = Object.assign(Object.create(ti.prototype), {
      constructor: ri,
      isSpotLight: !0,
      copy: function (t) {
        return (
          ti.prototype.copy.call(this, t),
          (this.distance = t.distance),
          (this.angle = t.angle),
          (this.penumbra = t.penumbra),
          (this.decay = t.decay),
          (this.target = t.target.clone()),
          (this.shadow = t.shadow.clone()),
          this
        );
      },
    })),
    (ai.prototype = Object.assign(Object.create(ti.prototype), {
      constructor: ai,
      isPointLight: !0,
      copy: function (t) {
        return (
          ti.prototype.copy.call(this, t),
          (this.distance = t.distance),
          (this.decay = t.decay),
          (this.shadow = t.shadow.clone()),
          this
        );
      },
    })),
    (oi.prototype = Object.assign(Object.create(ii.prototype), { constructor: oi })),
    (si.prototype = Object.assign(Object.create(ti.prototype), {
      constructor: si,
      isDirectionalLight: !0,
      copy: function (t) {
        return (
          ti.prototype.copy.call(this, t),
          (this.target = t.target.clone()),
          (this.shadow = t.shadow.clone()),
          this
        );
      },
    })),
    (ci.prototype = Object.assign(Object.create(ti.prototype), { constructor: ci, isAmbientLight: !0 })),
    (hi.prototype = Object.assign(Object.create(ti.prototype), {
      constructor: hi,
      isRectAreaLight: !0,
      copy: function (t) {
        return (ti.prototype.copy.call(this, t), (this.width = t.width), (this.height = t.height), this);
      },
      toJSON: function (t) {
        const e = ti.prototype.toJSON.call(this, t);
        return ((e.object.width = this.width), (e.object.height = this.height), e);
      },
    })),
    (li.prototype = Object.assign(Object.create(bi.prototype), {
      constructor: li,
      ValueTypeName: 'string',
      ValueBufferType: Array,
      DefaultInterpolation: 2300,
      InterpolantFactoryMethodLinear: void 0,
      InterpolantFactoryMethodSmooth: void 0,
    })),
    (ui.prototype = Object.assign(Object.create(bi.prototype), {
      constructor: ui,
      ValueTypeName: 'bool',
      ValueBufferType: Array,
      DefaultInterpolation: 2300,
      InterpolantFactoryMethodLinear: void 0,
      InterpolantFactoryMethodSmooth: void 0,
    })),
    Object.assign(pi.prototype, {
      evaluate: function (t) {
        let e = this.parameterPositions,
          i = this._cachedIndex,
          n = e[i],
          r = e[i - 1];
        t: {
          e: {
            let a;
            i: {
              n: if (!(t < n)) {
                for (s = i + 2; ; ) {
                  if (void 0 === n) {
                    if (t < r) break n;
                    return ((i = e.length), (this._cachedIndex = i), this.afterEnd_(i - 1, t, r));
                  }
                  if (i === s) break;
                  if (((r = n), (n = e[++i]), t < n)) break e;
                }
                a = e.length;
                break i;
              }
              {
                if (t >= r) break t;
                const o = e[1];
                t < o && ((i = 2), (r = o));
                for (var s = i - 2; ; ) {
                  if (void 0 === r) return ((this._cachedIndex = 0), this.beforeStart_(0, t, n));
                  if (i === s) break;
                  if (((n = r), (r = e[--i - 1]), t >= r)) break e;
                }
                ((a = i), (i = 0));
              }
            }
            for (; i < a; ) {
              const c = (i + a) >>> 1;
              t < e[c] ? (a = c) : (i = c + 1);
            }
            if (((n = e[i]), void 0 === (r = e[i - 1]))) return ((this._cachedIndex = 0), this.beforeStart_(0, t, n));
            if (void 0 === n) return ((i = e.length), (this._cachedIndex = i), this.afterEnd_(i - 1, r, t));
          }
          ((this._cachedIndex = i), this.intervalChanged_(i, r, n));
        }
        return this.interpolate_(i, r, t, n);
      },
      settings: null,
      DefaultSettings_: {},
      getSettings_: function () {
        return this.settings || this.DefaultSettings_;
      },
      copySampleValue_: function (t) {
        for (var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = t * n, a = 0; a !== n; ++a)
          e[a] = i[r + a];
        return e;
      },
      interpolate_: function () {
        throw new Error('call to abstract method');
      },
      intervalChanged_: function () {},
    }),
    Object.assign(pi.prototype, {
      beforeStart_: pi.prototype.copySampleValue_,
      afterEnd_: pi.prototype.copySampleValue_,
    }),
    (di.prototype = Object.assign(Object.create(pi.prototype), {
      constructor: di,
      interpolate_: function (t, e, i, n) {
        for (
          var a = this.resultBuffer,
            o = this.sampleValues,
            s = this.valueSize,
            c = t * s,
            h = (i - e) / (n - e),
            l = c + s;
          c !== l;
          c += 4
        )
          r.slerpFlat(a, 0, o, c - s, o, c, h);
        return a;
      },
    })),
    (fi.prototype = Object.assign(Object.create(bi.prototype), {
      constructor: fi,
      ValueTypeName: 'quaternion',
      DefaultInterpolation: 2301,
      InterpolantFactoryMethodLinear: function (t) {
        return new di(this.times, this.values, this.getValueSize(), t);
      },
      InterpolantFactoryMethodSmooth: void 0,
    })),
    (mi.prototype = Object.assign(Object.create(bi.prototype), { constructor: mi, ValueTypeName: 'color' })),
    (vi.prototype = Object.assign(Object.create(bi.prototype), { constructor: vi, ValueTypeName: 'number' })),
    (gi.prototype = Object.assign(Object.create(pi.prototype), {
      constructor: gi,
      DefaultSettings_: { endingStart: Ia, endingEnd: Ia },
      intervalChanged_: function (t, e, i) {
        let n = this.parameterPositions,
          r = t - 2,
          a = t + 1,
          o = n[r],
          s = n[a];
        if (void 0 === o)
          switch (this.getSettings_().endingStart) {
            case 2401:
              ((r = t), (o = 2 * e - i));
              break;
            case 2402:
              o = e + n[(r = n.length - 2)] - n[r + 1];
              break;
            default:
              ((r = t), (o = i));
          }
        if (void 0 === s)
          switch (this.getSettings_().endingEnd) {
            case 2401:
              ((a = t), (s = 2 * i - e));
              break;
            case 2402:
              ((a = 1), (s = i + n[1] - n[0]));
              break;
            default:
              ((a = t - 1), (s = e));
          }
        const c = 0.5 * (i - e),
          h = this.valueSize;
        ((this._weightPrev = c / (e - o)),
          (this._weightNext = c / (s - i)),
          (this._offsetPrev = r * h),
          (this._offsetNext = a * h));
      },
      interpolate_: function (t, e, i, n) {
        for (
          var r = this.resultBuffer,
            a = this.sampleValues,
            o = this.valueSize,
            s = t * o,
            c = s - o,
            h = this._offsetPrev,
            l = this._offsetNext,
            u = this._weightPrev,
            p = this._weightNext,
            d = (i - e) / (n - e),
            f = d * d,
            m = f * d,
            v = -u * m + 2 * u * f - u * d,
            g = (1 + u) * m + (-1.5 - 2 * u) * f + (-0.5 + u) * d + 1,
            y = (-1 - p) * m + (1.5 + p) * f + 0.5 * d,
            x = p * m - p * f,
            b = 0;
          b !== o;
          ++b
        )
          r[b] = v * a[h + b] + g * a[c + b] + y * a[s + b] + x * a[l + b];
        return r;
      },
    })),
    (yi.prototype = Object.assign(Object.create(pi.prototype), {
      constructor: yi,
      interpolate_: function (t, e, i, n) {
        for (
          var r = this.resultBuffer,
            a = this.sampleValues,
            o = this.valueSize,
            s = t * o,
            c = s - o,
            h = (i - e) / (n - e),
            l = 1 - h,
            u = 0;
          u !== o;
          ++u
        )
          r[u] = a[c + u] * l + a[s + u] * h;
        return r;
      },
    })),
    (xi.prototype = Object.assign(Object.create(pi.prototype), {
      constructor: xi,
      interpolate_: function (t) {
        return this.copySampleValue_(t - 1);
      },
    })));
  var yo = {
    arraySlice: function (t, e, i) {
      return yo.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i);
    },
    convertArray: function (t, e, i) {
      return !t || (!i && t.constructor === e)
        ? t
        : 'number' == typeof e.BYTES_PER_ELEMENT
          ? new e(t)
          : Array.prototype.slice.call(t);
    },
    isTypedArray: function (t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView);
    },
    getKeyframeOrder: function (t) {
      for (var e = t.length, i = new Array(e), n = 0; n !== e; ++n) i[n] = n;
      return (
        i.sort(function (e, i) {
          return t[e] - t[i];
        }),
        i
      );
    },
    sortedArray: function (t, e, i) {
      for (var n = t.length, r = new t.constructor(n), a = 0, o = 0; o !== n; ++a)
        for (let s = i[a] * e, c = 0; c !== e; ++c) r[o++] = t[s + c];
      return r;
    },
    flattenJSON: function (t, e, i, n) {
      for (var r = 1, a = t[0]; void 0 !== a && void 0 === a[n]; ) a = t[r++];
      if (void 0 !== a) {
        let o = a[n];
        if (void 0 !== o)
          if (Array.isArray(o))
            do {
              (void 0 !== (o = a[n]) && (e.push(a.time), i.push.apply(i, o)), (a = t[r++]));
            } while (void 0 !== a);
          else if (void 0 !== o.toArray)
            do {
              (void 0 !== (o = a[n]) && (e.push(a.time), o.toArray(i, i.length)), (a = t[r++]));
            } while (void 0 !== a);
          else
            do {
              (void 0 !== (o = a[n]) && (e.push(a.time), i.push(o)), (a = t[r++]));
            } while (void 0 !== a);
      }
    },
  };
  (Object.assign(bi, {
    parse: function (t) {
      if (void 0 === t.type) throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
      const e = bi._getTrackTypeForValueTypeName(t.type);
      if (void 0 === t.times) {
        const i = [],
          n = [];
        (yo.flattenJSON(t.keys, i, n, 'value'), (t.times = i), (t.values = n));
      }
      return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation);
    },
    toJSON: function (t) {
      let e,
        i = t.constructor;
      if (void 0 !== i.toJSON) e = i.toJSON(t);
      else {
        e = { name: t.name, times: yo.convertArray(t.times, Array), values: yo.convertArray(t.values, Array) };
        const n = t.getInterpolation();
        n !== t.DefaultInterpolation && (e.interpolation = n);
      }
      return ((e.type = t.ValueTypeName), e);
    },
    _getTrackTypeForValueTypeName: function (t) {
      switch (t.toLowerCase()) {
        case 'scalar':
        case 'double':
        case 'float':
        case 'number':
        case 'integer':
          return vi;
        case 'vector':
        case 'vector2':
        case 'vector3':
        case 'vector4':
          return _i;
        case 'color':
          return mi;
        case 'quaternion':
          return fi;
        case 'bool':
        case 'boolean':
          return ui;
        case 'string':
          return li;
      }
      throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + t);
    },
  }),
    Object.assign(bi.prototype, {
      constructor: bi,
      TimeBufferType: Float32Array,
      ValueBufferType: Float32Array,
      DefaultInterpolation: 2301,
      InterpolantFactoryMethodDiscrete: function (t) {
        return new xi(this.times, this.values, this.getValueSize(), t);
      },
      InterpolantFactoryMethodLinear: function (t) {
        return new yi(this.times, this.values, this.getValueSize(), t);
      },
      InterpolantFactoryMethodSmooth: function (t) {
        return new gi(this.times, this.values, this.getValueSize(), t);
      },
      setInterpolation: function (t) {
        let e;
        switch (t) {
          case 2300:
            e = this.InterpolantFactoryMethodDiscrete;
            break;
          case 2301:
            e = this.InterpolantFactoryMethodLinear;
            break;
          case 2302:
            e = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 !== e) this.createInterpolant = e;
        else {
          const i = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
          if (void 0 === this.createInterpolant) {
            if (t === this.DefaultInterpolation) throw new Error(i);
            this.setInterpolation(this.DefaultInterpolation);
          }
          console.warn('THREE.KeyframeTrack:', i);
        }
      },
      getInterpolation: function () {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return 2300;
          case this.InterpolantFactoryMethodLinear:
            return 2301;
          case this.InterpolantFactoryMethodSmooth:
            return 2302;
        }
      },
      getValueSize: function () {
        return this.values.length / this.times.length;
      },
      shift: function (t) {
        if (0 !== t) for (let e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] += t;
        return this;
      },
      scale: function (t) {
        if (1 !== t) for (let e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] *= t;
        return this;
      },
      trim: function (t, e) {
        for (var i = this.times, n = i.length, r = 0, a = n - 1; r !== n && i[r] < t; ) ++r;
        for (; -1 !== a && i[a] > e; ) --a;
        if ((++a, 0 !== r || a !== n)) {
          r >= a && ((a = Math.max(a, 1)), (r = a - 1));
          const o = this.getValueSize();
          ((this.times = yo.arraySlice(i, r, a)), (this.values = yo.arraySlice(this.values, r * o, a * o)));
        }
        return this;
      },
      validate: function () {
        let t = !0,
          e = this.getValueSize();
        e - Math.floor(e) != 0 && (console.error('THREE.KeyframeTrack: Invalid value size in track.', this), (t = !1));
        const i = this.times,
          n = this.values,
          r = i.length;
        0 === r && (console.error('THREE.KeyframeTrack: Track is empty.', this), (t = !1));
        for (var a = null, o = 0; o !== r; o++) {
          const s = i[o];
          if ('number' == typeof s && isNaN(s)) {
            (console.error('THREE.KeyframeTrack: Time is not a valid number.', this, o, s), (t = !1));
            break;
          }
          if (null !== a && a > s) {
            (console.error('THREE.KeyframeTrack: Out of order keys.', this, o, s, a), (t = !1));
            break;
          }
          a = s;
        }
        if (void 0 !== n && yo.isTypedArray(n))
          for (var o = 0, c = n.length; o !== c; ++o) {
            const h = n[o];
            if (isNaN(h)) {
              (console.error('THREE.KeyframeTrack: Value is not a valid number.', this, o, h), (t = !1));
              break;
            }
          }
        return t;
      },
      optimize: function () {
        for (
          var t = this.times,
            e = this.values,
            i = this.getValueSize(),
            n = 2302 === this.getInterpolation(),
            r = 1,
            a = t.length - 1,
            o = 1;
          o < a;
          ++o
        ) {
          let s = !1,
            c = t[o];
          if (c !== t[o + 1] && (1 !== o || c !== c[0]))
            if (n) s = !0;
            else
              for (var h = o * i, l = h - i, u = h + i, p = 0; p !== i; ++p) {
                const d = e[h + p];
                if (d !== e[l + p] || d !== e[u + p]) {
                  s = !0;
                  break;
                }
              }
          if (s) {
            if (o !== r) {
              t[r] = t[o];
              for (var f = o * i, m = r * i, p = 0; p !== i; ++p) e[m + p] = e[f + p];
            }
            ++r;
          }
        }
        if (a > 0) {
          t[r] = t[a];
          for (var f = a * i, m = r * i, p = 0; p !== i; ++p) e[m + p] = e[f + p];
          ++r;
        }
        return (
          r !== t.length && ((this.times = yo.arraySlice(t, 0, r)), (this.values = yo.arraySlice(e, 0, r * i))),
          this
        );
      },
    }),
    (_i.prototype = Object.assign(Object.create(bi.prototype), { constructor: _i, ValueTypeName: 'vector' })),
    Object.assign(wi, {
      parse: function (t) {
        for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, a = i.length; r !== a; ++r)
          e.push(bi.parse(i[r]).scale(n));
        return new wi(t.name, t.duration, e);
      },
      toJSON: function (t) {
        for (
          var e = [], i = t.tracks, n = { name: t.name, duration: t.duration, tracks: e }, r = 0, a = i.length;
          r !== a;
          ++r
        )
          e.push(bi.toJSON(i[r]));
        return n;
      },
      CreateFromMorphTargetSequence: function (t, e, i, n) {
        for (var r = e.length, a = [], o = 0; o < r; o++) {
          let s = [],
            c = [];
          (s.push((o + r - 1) % r, o, (o + 1) % r), c.push(0, 1, 0));
          const h = yo.getKeyframeOrder(s);
          ((s = yo.sortedArray(s, 1, h)),
            (c = yo.sortedArray(c, 1, h)),
            n || 0 !== s[0] || (s.push(r), c.push(c[0])),
            a.push(new vi('.morphTargetInfluences[' + e[o].name + ']', s, c).scale(1 / i)));
        }
        return new wi(t, -1, a);
      },
      findByName: function (t, e) {
        let i = t;
        if (!Array.isArray(t)) {
          const n = t;
          i = (n.geometry && n.geometry.animations) || n.animations;
        }
        for (let r = 0; r < i.length; r++) if (i[r].name === e) return i[r];
        return null;
      },
      CreateClipsFromMorphTargetSequences: function (t, e, i) {
        for (var n = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length; a < o; a++) {
          const s = t[a],
            c = s.name.match(r);
          if (c && c.length > 1) {
            let h = n[(u = c[1])];
            (h || (n[u] = h = []), h.push(s));
          }
        }
        const l = [];
        for (var u in n) l.push(wi.CreateFromMorphTargetSequence(u, n[u], e, i));
        return l;
      },
      parseAnimation: function (t, e) {
        if (!t) return (console.error('THREE.AnimationClip: No animation in JSONLoader data.'), null);
        for (
          var i = function (t, e, i, n, r) {
              if (0 !== i.length) {
                const a = [],
                  o = [];
                (yo.flattenJSON(i, a, o, n), 0 !== a.length && r.push(new t(e, a, o)));
              }
            },
            n = [],
            r = t.name || 'default',
            a = t.length || -1,
            o = t.fps || 30,
            s = t.hierarchy || [],
            c = 0;
          c < s.length;
          c++
        ) {
          const h = s[c].keys;
          if (h && 0 !== h.length)
            if (h[0].morphTargets) {
              for (var l = {}, u = 0; u < h.length; u++)
                if (h[u].morphTargets) for (m = 0; m < h[u].morphTargets.length; m++) l[h[u].morphTargets[m]] = -1;
              for (const p in l) {
                for (var d = [], f = [], m = 0; m !== h[u].morphTargets.length; ++m) {
                  const v = h[u];
                  (d.push(v.time), f.push(v.morphTarget === p ? 1 : 0));
                }
                n.push(new vi('.morphTargetInfluence[' + p + ']', d, f));
              }
              a = l.length * (o || 1);
            } else {
              const g = '.bones[' + e[c].name + ']';
              (i(_i, g + '.position', h, 'pos', n),
                i(fi, g + '.quaternion', h, 'rot', n),
                i(_i, g + '.scale', h, 'scl', n));
            }
        }
        if (0 === n.length) return null;
        return new wi(r, a, n);
      },
    }),
    Object.assign(wi.prototype, {
      resetDuration: function () {
        for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) {
          const n = this.tracks[e];
          t = Math.max(t, n.times[n.times.length - 1]);
        }
        this.duration = t;
      },
      trim: function () {
        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
        return this;
      },
      optimize: function () {
        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
        return this;
      },
    }),
    Object.assign(Ei.prototype, {
      load: function (t, e, i, n) {
        const r = this;
        new Ye(r.manager).load(
          t,
          function (t) {
            e(r.parse(JSON.parse(t)));
          },
          i,
          n
        );
      },
      setTextures: function (t) {
        this.textures = t;
      },
      parse: function (t) {
        function e(t) {
          return (void 0 === n[t] && console.warn('THREE.MaterialLoader: Undefined texture', t), n[t]);
        }
        var n = this.textures,
          r = new fo[t.type]();
        if (
          (void 0 !== t.uuid && (r.uuid = t.uuid),
          void 0 !== t.name && (r.name = t.name),
          void 0 !== t.color && r.color.setHex(t.color),
          void 0 !== t.roughness && (r.roughness = t.roughness),
          void 0 !== t.metalness && (r.metalness = t.metalness),
          void 0 !== t.emissive && r.emissive.setHex(t.emissive),
          void 0 !== t.specular && r.specular.setHex(t.specular),
          void 0 !== t.shininess && (r.shininess = t.shininess),
          void 0 !== t.clearCoat && (r.clearCoat = t.clearCoat),
          void 0 !== t.clearCoatRoughness && (r.clearCoatRoughness = t.clearCoatRoughness),
          void 0 !== t.uniforms && (r.uniforms = t.uniforms),
          void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader),
          void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader),
          void 0 !== t.vertexColors && (r.vertexColors = t.vertexColors),
          void 0 !== t.fog && (r.fog = t.fog),
          void 0 !== t.flatShading && (r.flatShading = t.flatShading),
          void 0 !== t.blending && (r.blending = t.blending),
          void 0 !== t.side && (r.side = t.side),
          void 0 !== t.opacity && (r.opacity = t.opacity),
          void 0 !== t.transparent && (r.transparent = t.transparent),
          void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest),
          void 0 !== t.depthTest && (r.depthTest = t.depthTest),
          void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite),
          void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite),
          void 0 !== t.wireframe && (r.wireframe = t.wireframe),
          void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth),
          void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap),
          void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin),
          void 0 !== t.rotation && (r.rotation = t.rotation),
          1 !== t.linewidth && (r.linewidth = t.linewidth),
          void 0 !== t.dashSize && (r.dashSize = t.dashSize),
          void 0 !== t.gapSize && (r.gapSize = t.gapSize),
          void 0 !== t.scale && (r.scale = t.scale),
          void 0 !== t.skinning && (r.skinning = t.skinning),
          void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets),
          void 0 !== t.dithering && (r.dithering = t.dithering),
          void 0 !== t.visible && (r.visible = t.visible),
          void 0 !== t.userData && (r.userData = t.userData),
          void 0 !== t.shading && (r.flatShading = 1 === t.shading),
          void 0 !== t.size && (r.size = t.size),
          void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation),
          void 0 !== t.map && (r.map = e(t.map)),
          void 0 !== t.alphaMap && ((r.alphaMap = e(t.alphaMap)), (r.transparent = !0)),
          void 0 !== t.bumpMap && (r.bumpMap = e(t.bumpMap)),
          void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale),
          void 0 !== t.normalMap && (r.normalMap = e(t.normalMap)),
          void 0 !== t.normalScale)
        ) {
          let a = t.normalScale;
          (!1 === Array.isArray(a) && (a = [a, a]), (r.normalScale = new i().fromArray(a)));
        }
        return (
          void 0 !== t.displacementMap && (r.displacementMap = e(t.displacementMap)),
          void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale),
          void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias),
          void 0 !== t.roughnessMap && (r.roughnessMap = e(t.roughnessMap)),
          void 0 !== t.metalnessMap && (r.metalnessMap = e(t.metalnessMap)),
          void 0 !== t.emissiveMap && (r.emissiveMap = e(t.emissiveMap)),
          void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity),
          void 0 !== t.specularMap && (r.specularMap = e(t.specularMap)),
          void 0 !== t.envMap && (r.envMap = e(t.envMap)),
          void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity),
          void 0 !== t.lightMap && (r.lightMap = e(t.lightMap)),
          void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity),
          void 0 !== t.aoMap && (r.aoMap = e(t.aoMap)),
          void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity),
          void 0 !== t.gradientMap && (r.gradientMap = e(t.gradientMap)),
          r
        );
      },
    }),
    Object.assign(Mi.prototype, {
      load: function (t, e, i, n) {
        const r = this;
        new Ye(r.manager).load(
          t,
          function (t) {
            e(r.parse(JSON.parse(t)));
          },
          i,
          n
        );
      },
      parse: function (t) {
        const e = new K(),
          i = t.data.index;
        if (void 0 !== i) {
          s = new xo[i.type](i.array);
          e.setIndex(new G(s, 1));
        }
        const n = t.data.attributes;
        for (const r in n) {
          var o = n[r],
            s = new xo[o.type](o.array);
          e.addAttribute(r, new G(s, o.itemSize, o.normalized));
        }
        const c = t.data.groups || t.data.drawcalls || t.data.offsets;
        if (void 0 !== c)
          for (let h = 0, l = c.length; h !== l; ++h) {
            const u = c[h];
            e.addGroup(u.start, u.count, u.materialIndex);
          }
        const p = t.data.boundingSphere;
        if (void 0 !== p) {
          const d = new a();
          (void 0 !== p.center && d.fromArray(p.center), (e.boundingSphere = new L(d, p.radius)));
        }
        return e;
      },
    }));
  var xo = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    Uint8ClampedArray: 'undefined' != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array,
  };
  ((Ti.Handlers = {
    handlers: [],
    add: function (t, e) {
      this.handlers.push(t, e);
    },
    get: function (t) {
      for (let e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
        const r = e[i],
          a = e[i + 1];
        if (r.test(t)) return a;
      }
      return null;
    },
  }),
    Object.assign(Ti.prototype, {
      crossOrigin: void 0,
      extractUrlBase: function (t) {
        const e = t.split('/');
        return 1 === e.length ? './' : (e.pop(), e.join('/') + '/');
      },
      initMaterials: function (t, e, i) {
        for (var n = [], r = 0; r < t.length; ++r) n[r] = this.createMaterial(t[r], e, i);
        return n;
      },
      createMaterial: (function () {
        const t = {
            NoBlending: ir,
            NormalBlending: nr,
            AdditiveBlending: rr,
            SubtractiveBlending: ar,
            MultiplyBlending: or,
            CustomBlending: sr,
          },
          e = new w(),
          i = new $e(),
          n = new Ei();
        return function (r, a, o) {
          function s(t, e, n, r, s) {
            let h,
              l = a + t,
              u = Ti.Handlers.get(l);
            (null !== u ? (h = u.load(l)) : (i.setCrossOrigin(o), (h = i.load(l))),
              void 0 !== e && (h.repeat.fromArray(e), 1 !== e[0] && (h.wrapS = qr), 1 !== e[1] && (h.wrapT = qr)),
              void 0 !== n && h.offset.fromArray(n),
              void 0 !== r &&
                ('repeat' === r[0] && (h.wrapS = qr),
                'mirror' === r[0] && (h.wrapS = Zr),
                'repeat' === r[1] && (h.wrapT = qr),
                'mirror' === r[1] && (h.wrapT = Zr)),
              void 0 !== s && (h.anisotropy = s));
            const p = Wa.generateUUID();
            return ((c[p] = h), p);
          }
          var c = {},
            h = { uuid: Wa.generateUUID(), type: 'MeshLambertMaterial' };
          for (const l in r) {
            const u = r[l];
            switch (l) {
              case 'DbgColor':
              case 'DbgIndex':
              case 'opticalDensity':
              case 'illumination':
                break;
              case 'DbgName':
                h.name = u;
                break;
              case 'blending':
                h.blending = t[u];
                break;
              case 'colorAmbient':
              case 'mapAmbient':
                console.warn('THREE.Loader.createMaterial:', l, 'is no longer supported.');
                break;
              case 'colorDiffuse':
                h.color = e.fromArray(u).getHex();
                break;
              case 'colorSpecular':
                h.specular = e.fromArray(u).getHex();
                break;
              case 'colorEmissive':
                h.emissive = e.fromArray(u).getHex();
                break;
              case 'specularCoef':
                h.shininess = u;
                break;
              case 'shading':
                ('basic' === u.toLowerCase() && (h.type = 'MeshBasicMaterial'),
                  'phong' === u.toLowerCase() && (h.type = 'MeshPhongMaterial'),
                  'standard' === u.toLowerCase() && (h.type = 'MeshStandardMaterial'));
                break;
              case 'mapDiffuse':
                h.map = s(u, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
                break;
              case 'mapDiffuseRepeat':
              case 'mapDiffuseOffset':
              case 'mapDiffuseWrap':
              case 'mapDiffuseAnisotropy':
                break;
              case 'mapEmissive':
                h.emissiveMap = s(
                  u,
                  r.mapEmissiveRepeat,
                  r.mapEmissiveOffset,
                  r.mapEmissiveWrap,
                  r.mapEmissiveAnisotropy
                );
                break;
              case 'mapEmissiveRepeat':
              case 'mapEmissiveOffset':
              case 'mapEmissiveWrap':
              case 'mapEmissiveAnisotropy':
                break;
              case 'mapLight':
                h.lightMap = s(u, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
                break;
              case 'mapLightRepeat':
              case 'mapLightOffset':
              case 'mapLightWrap':
              case 'mapLightAnisotropy':
                break;
              case 'mapAO':
                h.aoMap = s(u, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
                break;
              case 'mapAORepeat':
              case 'mapAOOffset':
              case 'mapAOWrap':
              case 'mapAOAnisotropy':
                break;
              case 'mapBump':
                h.bumpMap = s(u, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
                break;
              case 'mapBumpScale':
                h.bumpScale = u;
                break;
              case 'mapBumpRepeat':
              case 'mapBumpOffset':
              case 'mapBumpWrap':
              case 'mapBumpAnisotropy':
                break;
              case 'mapNormal':
                h.normalMap = s(u, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
                break;
              case 'mapNormalFactor':
                h.normalScale = [u, u];
                break;
              case 'mapNormalRepeat':
              case 'mapNormalOffset':
              case 'mapNormalWrap':
              case 'mapNormalAnisotropy':
                break;
              case 'mapSpecular':
                h.specularMap = s(
                  u,
                  r.mapSpecularRepeat,
                  r.mapSpecularOffset,
                  r.mapSpecularWrap,
                  r.mapSpecularAnisotropy
                );
                break;
              case 'mapSpecularRepeat':
              case 'mapSpecularOffset':
              case 'mapSpecularWrap':
              case 'mapSpecularAnisotropy':
                break;
              case 'mapMetalness':
                h.metalnessMap = s(
                  u,
                  r.mapMetalnessRepeat,
                  r.mapMetalnessOffset,
                  r.mapMetalnessWrap,
                  r.mapMetalnessAnisotropy
                );
                break;
              case 'mapMetalnessRepeat':
              case 'mapMetalnessOffset':
              case 'mapMetalnessWrap':
              case 'mapMetalnessAnisotropy':
                break;
              case 'mapRoughness':
                h.roughnessMap = s(
                  u,
                  r.mapRoughnessRepeat,
                  r.mapRoughnessOffset,
                  r.mapRoughnessWrap,
                  r.mapRoughnessAnisotropy
                );
                break;
              case 'mapRoughnessRepeat':
              case 'mapRoughnessOffset':
              case 'mapRoughnessWrap':
              case 'mapRoughnessAnisotropy':
                break;
              case 'mapAlpha':
                h.alphaMap = s(u, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
                break;
              case 'mapAlphaRepeat':
              case 'mapAlphaOffset':
              case 'mapAlphaWrap':
              case 'mapAlphaAnisotropy':
                break;
              case 'flipSided':
                h.side = Jn;
                break;
              case 'doubleSided':
                h.side = Kn;
                break;
              case 'transparency':
                (console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity'),
                  (h.opacity = u));
                break;
              case 'depthTest':
              case 'depthWrite':
              case 'colorWrite':
              case 'opacity':
              case 'reflectivity':
              case 'transparent':
              case 'visible':
              case 'wireframe':
                h[l] = u;
                break;
              case 'vertexColors':
                (!0 === u && (h.vertexColors = er), 'face' === u && (h.vertexColors = tr));
                break;
              default:
                console.error('THREE.Loader.createMaterial: Unsupported', l, u);
            }
          }
          return (
            'MeshBasicMaterial' === h.type && delete h.emissive,
            'MeshPhongMaterial' !== h.type && delete h.specular,
            h.opacity < 1 && (h.transparent = !0),
            n.setTextures(c),
            n.parse(h)
          );
        };
      })(),
    }),
    Object.assign(Si.prototype, {
      load: function (t, e, i, n) {
        const r = this,
          a =
            this.texturePath && 'string' == typeof this.texturePath ? this.texturePath : Ti.prototype.extractUrlBase(t),
          o = new Ye(this.manager);
        (o.setWithCredentials(this.withCredentials),
          o.load(
            t,
            function (i) {
              const n = JSON.parse(i),
                o = n.metadata;
              if (void 0 !== o) {
                const s = o.type;
                if (void 0 !== s) {
                  if ('object' === s.toLowerCase())
                    return void console.error(
                      'THREE.JSONLoader: ' + t + ' should be loaded with THREE.ObjectLoader instead.'
                    );
                  if ('scene' === s.toLowerCase())
                    return void console.error(
                      'THREE.JSONLoader: ' + t + ' should be loaded with THREE.SceneLoader instead.'
                    );
                }
              }
              const c = r.parse(n, a);
              e(c.geometry, c.materials);
            },
            i,
            n
          ));
      },
      setTexturePath: function (t) {
        this.texturePath = t;
      },
      parse: (function () {
        return function (t, e) {
          (void 0 !== t.data && (t = t.data), void 0 !== t.scale ? (t.scale = 1 / t.scale) : (t.scale = 1));
          const n = new z();
          if (
            ((function (t, e) {
              function n(t, e) {
                return t & (1 << e);
              }
              let r,
                o,
                s,
                c,
                h,
                l,
                u,
                p,
                d,
                f,
                m,
                v,
                g,
                y,
                x,
                b,
                _,
                E,
                M,
                T,
                S,
                A,
                R,
                L,
                P,
                C = t.faces,
                I = t.vertices,
                D = t.normals,
                O = t.colors,
                U = t.scale,
                N = 0;
              if (void 0 !== t.uvs) {
                for (r = 0; r < t.uvs.length; r++) t.uvs[r].length && N++;
                for (r = 0; r < N; r++) e.faceVertexUvs[r] = [];
              }
              for (c = 0, h = I.length; c < h; )
                (((E = new a()).x = I[c++] * U), (E.y = I[c++] * U), (E.z = I[c++] * U), e.vertices.push(E));
              for (c = 0, h = C.length; c < h; )
                if (
                  ((f = C[c++]),
                  (m = n(f, 0)),
                  (v = n(f, 1)),
                  (g = n(f, 3)),
                  (y = n(f, 4)),
                  (x = n(f, 5)),
                  (b = n(f, 6)),
                  (_ = n(f, 7)),
                  m)
                ) {
                  if (
                    ((T = new F()),
                    (T.a = C[c]),
                    (T.b = C[c + 1]),
                    (T.c = C[c + 3]),
                    (S = new F()),
                    (S.a = C[c + 1]),
                    (S.b = C[c + 2]),
                    (S.c = C[c + 3]),
                    (c += 4),
                    v && ((d = C[c++]), (T.materialIndex = d), (S.materialIndex = d)),
                    (s = e.faces.length),
                    g)
                  )
                    for (r = 0; r < N; r++)
                      for (L = t.uvs[r], e.faceVertexUvs[r][s] = [], e.faceVertexUvs[r][s + 1] = [], o = 0; o < 4; o++)
                        ((P = new i(L[2 * (p = C[c++])], L[2 * p + 1])),
                          2 !== o && e.faceVertexUvs[r][s].push(P),
                          0 !== o && e.faceVertexUvs[r][s + 1].push(P));
                  if ((y && ((u = 3 * C[c++]), T.normal.set(D[u++], D[u++], D[u]), S.normal.copy(T.normal)), x))
                    for (r = 0; r < 4; r++)
                      ((u = 3 * C[c++]),
                        (R = new a(D[u++], D[u++], D[u])),
                        2 !== r && T.vertexNormals.push(R),
                        0 !== r && S.vertexNormals.push(R));
                  if ((b && ((A = O[(l = C[c++])]), T.color.setHex(A), S.color.setHex(A)), _))
                    for (r = 0; r < 4; r++)
                      ((A = O[(l = C[c++])]),
                        2 !== r && T.vertexColors.push(new w(A)),
                        0 !== r && S.vertexColors.push(new w(A)));
                  (e.faces.push(T), e.faces.push(S));
                } else {
                  if (
                    ((M = new F()),
                    (M.a = C[c++]),
                    (M.b = C[c++]),
                    (M.c = C[c++]),
                    v && ((d = C[c++]), (M.materialIndex = d)),
                    (s = e.faces.length),
                    g)
                  )
                    for (r = 0; r < N; r++)
                      for (L = t.uvs[r], e.faceVertexUvs[r][s] = [], o = 0; o < 3; o++)
                        ((P = new i(L[2 * (p = C[c++])], L[2 * p + 1])), e.faceVertexUvs[r][s].push(P));
                  if ((y && ((u = 3 * C[c++]), M.normal.set(D[u++], D[u++], D[u])), x))
                    for (r = 0; r < 3; r++)
                      ((u = 3 * C[c++]), (R = new a(D[u++], D[u++], D[u])), M.vertexNormals.push(R));
                  if ((b && ((l = C[c++]), M.color.setHex(O[l])), _))
                    for (r = 0; r < 3; r++) ((l = C[c++]), M.vertexColors.push(new w(O[l])));
                  e.faces.push(M);
                }
            })(t, n),
            (function (t, e) {
              const i = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
              if (t.skinWeights)
                for (var n = 0, r = t.skinWeights.length; n < r; n += i) {
                  const a = t.skinWeights[n],
                    o = i > 1 ? t.skinWeights[n + 1] : 0,
                    s = i > 2 ? t.skinWeights[n + 2] : 0,
                    h = i > 3 ? t.skinWeights[n + 3] : 0;
                  e.skinWeights.push(new c(a, o, s, h));
                }
              if (t.skinIndices)
                for (var n = 0, r = t.skinIndices.length; n < r; n += i) {
                  const l = t.skinIndices[n],
                    u = i > 1 ? t.skinIndices[n + 1] : 0,
                    p = i > 2 ? t.skinIndices[n + 2] : 0,
                    d = i > 3 ? t.skinIndices[n + 3] : 0;
                  e.skinIndices.push(new c(l, u, p, d));
                }
              ((e.bones = t.bones),
                e.bones &&
                  e.bones.length > 0 &&
                  (e.skinWeights.length !== e.skinIndices.length || e.skinIndices.length !== e.vertices.length) &&
                  console.warn(
                    'When skinning, number of vertices (' +
                      e.vertices.length +
                      '), skinIndices (' +
                      e.skinIndices.length +
                      '), and skinWeights (' +
                      e.skinWeights.length +
                      ') should match.'
                  ));
            })(t, n),
            (function (t, e) {
              const i = t.scale;
              if (void 0 !== t.morphTargets)
                for (var n = 0, r = t.morphTargets.length; n < r; n++) {
                  ((e.morphTargets[n] = {}),
                    (e.morphTargets[n].name = t.morphTargets[n].name),
                    (e.morphTargets[n].vertices = []));
                  for (
                    let o = e.morphTargets[n].vertices, s = t.morphTargets[n].vertices, c = 0, h = s.length;
                    c < h;
                    c += 3
                  ) {
                    const l = new a();
                    ((l.x = s[c] * i), (l.y = s[c + 1] * i), (l.z = s[c + 2] * i), o.push(l));
                  }
                }
              if (void 0 !== t.morphColors && t.morphColors.length > 0) {
                console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                for (var u = e.faces, p = t.morphColors[0].colors, n = 0, r = u.length; n < r; n++)
                  u[n].color.fromArray(p, 3 * n);
              }
            })(t, n),
            (function (t, e) {
              let i = [],
                n = [];
              (void 0 !== t.animation && n.push(t.animation),
                void 0 !== t.animations && (t.animations.length ? (n = n.concat(t.animations)) : n.push(t.animations)));
              for (let r = 0; r < n.length; r++) {
                const a = wi.parseAnimation(n[r], e.bones);
                a && i.push(a);
              }
              if (e.morphTargets) {
                const o = wi.CreateClipsFromMorphTargetSequences(e.morphTargets, 10);
                i = i.concat(o);
              }
              i.length > 0 && (e.animations = i);
            })(t, n),
            n.computeFaceNormals(),
            n.computeBoundingSphere(),
            void 0 === t.materials || 0 === t.materials.length)
          )
            return { geometry: n };
          return { geometry: n, materials: Ti.prototype.initMaterials(t.materials, e, this.crossOrigin) };
        };
      })(),
    }),
    Object.assign(Ai.prototype, {
      load: function (t, e, i, n) {
        '' === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf('/') + 1));
        const r = this;
        new Ye(r.manager).load(
          t,
          function (i) {
            let a = null;
            try {
              a = JSON.parse(i);
            } catch (e) {
              return (
                void 0 !== n && n(e),
                void console.error("THREE:ObjectLoader: Can't parse " + t + '.', e.message)
              );
            }
            const o = a.metadata;
            void 0 !== o && void 0 !== o.type && 'geometry' !== o.type.toLowerCase()
              ? r.parse(a, e)
              : console.error("THREE.ObjectLoader: Can't load " + t + '. Use THREE.JSONLoader instead.');
          },
          i,
          n
        );
      },
      setTexturePath: function (t) {
        this.texturePath = t;
      },
      setCrossOrigin: function (t) {
        this.crossOrigin = t;
      },
      parse: function (t, e) {
        var i = this.parseGeometries(t.geometries),
          n = this.parseImages(t.images, function () {
            void 0 !== e && e(o);
          }),
          r = this.parseTextures(t.textures, n),
          a = this.parseMaterials(t.materials, r),
          o = this.parseObject(t.object, i, a);
        return (
          t.animations && (o.animations = this.parseAnimations(t.animations)),
          (void 0 !== t.images && 0 !== t.images.length) || (void 0 !== e && e(o)),
          o
        );
      },
      parseGeometries: function (t) {
        const e = {};
        if (void 0 !== t)
          for (let i = new Si(), n = new Mi(), r = 0, a = t.length; r < a; r++) {
            var o,
              s = t[r];
            switch (s.type) {
              case 'PlaneGeometry':
              case 'PlaneBufferGeometry':
                o = new po[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                break;
              case 'BoxGeometry':
              case 'BoxBufferGeometry':
              case 'CubeGeometry':
                o = new po[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                break;
              case 'CircleGeometry':
              case 'CircleBufferGeometry':
                o = new po[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                break;
              case 'CylinderGeometry':
              case 'CylinderBufferGeometry':
                o = new po[s.type](
                  s.radiusTop,
                  s.radiusBottom,
                  s.height,
                  s.radialSegments,
                  s.heightSegments,
                  s.openEnded,
                  s.thetaStart,
                  s.thetaLength
                );
                break;
              case 'ConeGeometry':
              case 'ConeBufferGeometry':
                o = new po[s.type](
                  s.radius,
                  s.height,
                  s.radialSegments,
                  s.heightSegments,
                  s.openEnded,
                  s.thetaStart,
                  s.thetaLength
                );
                break;
              case 'SphereGeometry':
              case 'SphereBufferGeometry':
                o = new po[s.type](
                  s.radius,
                  s.widthSegments,
                  s.heightSegments,
                  s.phiStart,
                  s.phiLength,
                  s.thetaStart,
                  s.thetaLength
                );
                break;
              case 'DodecahedronGeometry':
              case 'DodecahedronBufferGeometry':
              case 'IcosahedronGeometry':
              case 'IcosahedronBufferGeometry':
              case 'OctahedronGeometry':
              case 'OctahedronBufferGeometry':
              case 'TetrahedronGeometry':
              case 'TetrahedronBufferGeometry':
                o = new po[s.type](s.radius, s.detail);
                break;
              case 'RingGeometry':
              case 'RingBufferGeometry':
                o = new po[s.type](
                  s.innerRadius,
                  s.outerRadius,
                  s.thetaSegments,
                  s.phiSegments,
                  s.thetaStart,
                  s.thetaLength
                );
                break;
              case 'TorusGeometry':
              case 'TorusBufferGeometry':
                o = new po[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                break;
              case 'TorusKnotGeometry':
              case 'TorusKnotBufferGeometry':
                o = new po[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                break;
              case 'LatheGeometry':
              case 'LatheBufferGeometry':
                o = new po[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                break;
              case 'PolyhedronGeometry':
              case 'PolyhedronBufferGeometry':
                o = new po[s.type](s.vertices, s.indices, s.radius, s.details);
                break;
              case 'BufferGeometry':
                o = n.parse(s);
                break;
              case 'Geometry':
                o = i.parse(s, this.texturePath).geometry;
                break;
              default:
                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                continue;
            }
            ((o.uuid = s.uuid), void 0 !== s.name && (o.name = s.name), (e[s.uuid] = o));
          }
        return e;
      },
      parseMaterials: function (t, e) {
        const i = {};
        if (void 0 !== t) {
          const n = new Ei();
          n.setTextures(e);
          for (let r = 0, a = t.length; r < a; r++) {
            const o = t[r];
            if ('MultiMaterial' === o.type) {
              for (var s = [], c = 0; c < o.materials.length; c++) s.push(n.parse(o.materials[c]));
              i[o.uuid] = s;
            } else i[o.uuid] = n.parse(o);
          }
        }
        return i;
      },
      parseAnimations: function (t) {
        for (var e = [], i = 0; i < t.length; i++) {
          const n = wi.parse(t[i]);
          e.push(n);
        }
        return e;
      },
      parseImages: function (t, e) {
        const i = this,
          n = {};
        if (void 0 !== t && t.length > 0) {
          const r = new Je(new qe(e));
          r.setCrossOrigin(this.crossOrigin);
          for (let a = 0, o = t.length; a < o; a++) {
            const s = t[a],
              c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(s.url) ? s.url : i.texturePath + s.url;
            n[s.uuid] = (function (t) {
              return (
                i.manager.itemStart(t),
                r.load(
                  t,
                  function () {
                    i.manager.itemEnd(t);
                  },
                  void 0,
                  function () {
                    (i.manager.itemEnd(t), i.manager.itemError(t));
                  }
                )
              );
            })(c);
          }
        }
        return n;
      },
      parseTextures: function (t, e) {
        function i(t, e) {
          return 'number' == typeof t
            ? t
            : (console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', t), e[t]);
        }
        const n = {};
        if (void 0 !== t)
          for (let r = 0, a = t.length; r < a; r++) {
            const o = t[r];
            (void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid),
              void 0 === e[o.image] && console.warn('THREE.ObjectLoader: Undefined image', o.image));
            const c = new s(e[o.image]);
            ((c.needsUpdate = !0),
              (c.uuid = o.uuid),
              void 0 !== o.name && (c.name = o.name),
              void 0 !== o.mapping && (c.mapping = i(o.mapping, bo)),
              void 0 !== o.offset && c.offset.fromArray(o.offset),
              void 0 !== o.repeat && c.repeat.fromArray(o.repeat),
              void 0 !== o.center && c.center.fromArray(o.center),
              void 0 !== o.rotation && (c.rotation = o.rotation),
              void 0 !== o.wrap && ((c.wrapS = i(o.wrap[0], _o)), (c.wrapT = i(o.wrap[1], _o))),
              void 0 !== o.minFilter && (c.minFilter = i(o.minFilter, wo)),
              void 0 !== o.magFilter && (c.magFilter = i(o.magFilter, wo)),
              void 0 !== o.anisotropy && (c.anisotropy = o.anisotropy),
              void 0 !== o.flipY && (c.flipY = o.flipY),
              (n[o.uuid] = c));
          }
        return n;
      },
      parseObject: (function () {
        const t = new n();
        return function (e, i, n) {
          function r(t) {
            return (void 0 === i[t] && console.warn('THREE.ObjectLoader: Undefined geometry', t), i[t]);
          }
          function a(t) {
            if (void 0 !== t) {
              if (Array.isArray(t)) {
                for (var e = [], i = 0, r = t.length; i < r; i++) {
                  const a = t[i];
                  (void 0 === n[a] && console.warn('THREE.ObjectLoader: Undefined material', a), e.push(n[a]));
                }
                return e;
              }
              return (void 0 === n[t] && console.warn('THREE.ObjectLoader: Undefined material', t), n[t]);
            }
          }
          let o;
          switch (e.type) {
            case 'Scene':
              ((o = new Et()),
                void 0 !== e.background && Number.isInteger(e.background) && (o.background = new w(e.background)),
                void 0 !== e.fog &&
                  ('Fog' === e.fog.type
                    ? (o.fog = new wt(e.fog.color, e.fog.near, e.fog.far))
                    : 'FogExp2' === e.fog.type && (o.fog = new _t(e.fog.color, e.fog.density))));
              break;
            case 'PerspectiveCamera':
              ((o = new vt(e.fov, e.aspect, e.near, e.far)),
                void 0 !== e.focus && (o.focus = e.focus),
                void 0 !== e.zoom && (o.zoom = e.zoom),
                void 0 !== e.filmGauge && (o.filmGauge = e.filmGauge),
                void 0 !== e.filmOffset && (o.filmOffset = e.filmOffset),
                void 0 !== e.view && (o.view = Object.assign({}, e.view)));
              break;
            case 'OrthographicCamera':
              o = new B(e.left, e.right, e.top, e.bottom, e.near, e.far);
              break;
            case 'AmbientLight':
              o = new ci(e.color, e.intensity);
              break;
            case 'DirectionalLight':
              o = new si(e.color, e.intensity);
              break;
            case 'PointLight':
              o = new ai(e.color, e.intensity, e.distance, e.decay);
              break;
            case 'RectAreaLight':
              o = new hi(e.color, e.intensity, e.width, e.height);
              break;
            case 'SpotLight':
              o = new ri(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
              break;
            case 'HemisphereLight':
              o = new ei(e.color, e.groundColor, e.intensity);
              break;
            case 'SkinnedMesh':
              console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');
            case 'Mesh':
              var s = r(e.geometry),
                c = a(e.material);
              o = s.bones && s.bones.length > 0 ? new Pt(s, c) : new ct(s, c);
              break;
            case 'LOD':
              o = new At();
              break;
            case 'Line':
              o = new It(r(e.geometry), a(e.material), e.mode);
              break;
            case 'LineLoop':
              o = new Ot(r(e.geometry), a(e.material));
              break;
            case 'LineSegments':
              o = new Dt(r(e.geometry), a(e.material));
              break;
            case 'PointCloud':
            case 'Points':
              o = new Nt(r(e.geometry), a(e.material));
              break;
            case 'Sprite':
              o = new St(a(e.material));
              break;
            case 'Group':
              o = new Bt();
              break;
            default:
              o = new U();
          }
          if (
            ((o.uuid = e.uuid),
            void 0 !== e.name && (o.name = e.name),
            void 0 !== e.matrix
              ? (t.fromArray(e.matrix), t.decompose(o.position, o.quaternion, o.scale))
              : (void 0 !== e.position && o.position.fromArray(e.position),
                void 0 !== e.rotation && o.rotation.fromArray(e.rotation),
                void 0 !== e.quaternion && o.quaternion.fromArray(e.quaternion),
                void 0 !== e.scale && o.scale.fromArray(e.scale)),
            void 0 !== e.castShadow && (o.castShadow = e.castShadow),
            void 0 !== e.receiveShadow && (o.receiveShadow = e.receiveShadow),
            e.shadow &&
              (void 0 !== e.shadow.bias && (o.shadow.bias = e.shadow.bias),
              void 0 !== e.shadow.radius && (o.shadow.radius = e.shadow.radius),
              void 0 !== e.shadow.mapSize && o.shadow.mapSize.fromArray(e.shadow.mapSize),
              void 0 !== e.shadow.camera && (o.shadow.camera = this.parseObject(e.shadow.camera))),
            void 0 !== e.visible && (o.visible = e.visible),
            void 0 !== e.userData && (o.userData = e.userData),
            void 0 !== e.children)
          )
            for (let h = e.children, l = 0; l < h.length; l++) o.add(this.parseObject(h[l], i, n));
          if ('LOD' === e.type)
            for (let u = e.levels, p = 0; p < u.length; p++) {
              const d = u[p],
                f = o.getObjectByProperty('uuid', d.object);
              void 0 !== f && o.addLevel(f, d.distance);
            }
          return o;
        };
      })(),
    }));
  var bo = {
      UVMapping: 300,
      CubeReflectionMapping: Gr,
      CubeRefractionMapping: Hr,
      EquirectangularReflectionMapping: Vr,
      EquirectangularRefractionMapping: kr,
      SphericalReflectionMapping: jr,
      CubeUVReflectionMapping: Wr,
      CubeUVRefractionMapping: Xr,
    },
    _o = { RepeatWrapping: qr, ClampToEdgeWrapping: Yr, MirroredRepeatWrapping: Zr },
    wo = {
      NearestFilter: Qr,
      NearestMipMapNearestFilter: Jr,
      NearestMipMapLinearFilter: Kr,
      LinearFilter: $r,
      LinearMipMapNearestFilter: ta,
      LinearMipMapLinearFilter: ea,
    };
  ((Ri.prototype = {
    constructor: Ri,
    setOptions: function (t) {
      return ((this.options = t), this);
    },
    load: function (t, e, i, n) {
      (void 0 === t && (t = ''), void 0 !== this.path && (t = this.path + t));
      const r = this,
        a = mo.get(t);
      if (void 0 !== a)
        return (
          r.manager.itemStart(t),
          setTimeout(function () {
            (e && e(a), r.manager.itemEnd(t));
          }, 0),
          a
        );
      fetch(t)
        .then(function (t) {
          return t.blob();
        })
        .then(function (t) {
          return createImageBitmap(t, r.options);
        })
        .then(function (i) {
          (mo.add(t, i), e && e(i), r.manager.itemEnd(t));
        })
        .catch(function (e) {
          (n && n(e), r.manager.itemEnd(t), r.manager.itemError(t));
        });
    },
    setCrossOrigin: function () {
      return this;
    },
    setPath: function (t) {
      return ((this.path = t), this);
    },
  }),
    Object.assign(Ii.prototype, {
      getPoint: function () {
        return (console.warn('THREE.Curve: .getPoint() not implemented.'), null);
      },
      getPointAt: function (t, e) {
        const i = this.getUtoTmapping(t);
        return this.getPoint(i, e);
      },
      getPoints: function (t) {
        void 0 === t && (t = 5);
        for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
        return e;
      },
      getSpacedPoints: function (t) {
        void 0 === t && (t = 5);
        for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
        return e;
      },
      getLength: function () {
        const t = this.getLengths();
        return t[t.length - 1];
      },
      getLengths: function (t) {
        if (
          (void 0 === t && (t = this.arcLengthDivisions),
          this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
        )
          return this.cacheArcLengths;
        this.needsUpdate = !1;
        let e,
          i,
          n = [],
          r = this.getPoint(0),
          a = 0;
        for (n.push(0), i = 1; i <= t; i++) ((a += (e = this.getPoint(i / t)).distanceTo(r)), n.push(a), (r = e));
        return ((this.cacheArcLengths = n), n);
      },
      updateArcLengths: function () {
        ((this.needsUpdate = !0), this.getLengths());
      },
      getUtoTmapping: function (t, e) {
        let i,
          n = this.getLengths(),
          r = 0,
          a = n.length;
        i = e || t * n[a - 1];
        for (var o, s = 0, c = a - 1; s <= c; )
          if (((r = Math.floor(s + (c - s) / 2)), (o = n[r] - i) < 0)) s = r + 1;
          else {
            if (!(o > 0)) {
              c = r;
              break;
            }
            c = r - 1;
          }
        if (((r = c), n[r] === i)) return r / (a - 1);
        const h = n[r];
        return (r + (i - h) / (n[r + 1] - h)) / (a - 1);
      },
      getTangent: function (t) {
        let e = t - 1e-4,
          i = t + 1e-4;
        (e < 0 && (e = 0), i > 1 && (i = 1));
        const n = this.getPoint(e);
        return this.getPoint(i).clone().sub(n).normalize();
      },
      getTangentAt: function (t) {
        const e = this.getUtoTmapping(t);
        return this.getTangent(e);
      },
      computeFrenetFrames: function (t, e) {
        let i,
          r,
          o,
          s = new a(),
          c = [],
          h = [],
          l = [],
          u = new a(),
          p = new n();
        for (i = 0; i <= t; i++) ((r = i / t), (c[i] = this.getTangentAt(r)), c[i].normalize());
        ((h[0] = new a()), (l[0] = new a()));
        let d = Number.MAX_VALUE,
          f = Math.abs(c[0].x),
          m = Math.abs(c[0].y),
          v = Math.abs(c[0].z);
        for (
          f <= d && ((d = f), s.set(1, 0, 0)),
            m <= d && ((d = m), s.set(0, 1, 0)),
            v <= d && s.set(0, 0, 1),
            u.crossVectors(c[0], s).normalize(),
            h[0].crossVectors(c[0], u),
            l[0].crossVectors(c[0], h[0]),
            i = 1;
          i <= t;
          i++
        )
          ((h[i] = h[i - 1].clone()),
            (l[i] = l[i - 1].clone()),
            u.crossVectors(c[i - 1], c[i]),
            u.length() > Number.EPSILON &&
              (u.normalize(),
              (o = Math.acos(Wa.clamp(c[i - 1].dot(c[i]), -1, 1))),
              h[i].applyMatrix4(p.makeRotationAxis(u, o))),
            l[i].crossVectors(c[i], h[i]));
        if (!0 === e)
          for (
            o = Math.acos(Wa.clamp(h[0].dot(h[t]), -1, 1)),
              o /= t,
              c[0].dot(u.crossVectors(h[0], h[t])) > 0 && (o = -o),
              i = 1;
            i <= t;
            i++
          )
            (h[i].applyMatrix4(p.makeRotationAxis(c[i], o * i)), l[i].crossVectors(c[i], h[i]));
        return { tangents: c, normals: h, binormals: l };
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return ((this.arcLengthDivisions = t.arcLengthDivisions), this);
      },
    }),
    ((Di.prototype = Object.create(Ii.prototype)).constructor = Di),
    (Di.prototype.isLineCurve = !0),
    (Di.prototype.getPoint = function (t, e) {
      const n = e || new i();
      return (1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n);
    }),
    (Di.prototype.getPointAt = function (t, e) {
      return this.getPoint(t, e);
    }),
    (Di.prototype.getTangent = function () {
      return this.v2.clone().sub(this.v1).normalize();
    }),
    (Di.prototype.copy = function (t) {
      return (Ii.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this);
    }),
    (Oi.prototype = Object.assign(Object.create(Ii.prototype), {
      constructor: Oi,
      add: function (t) {
        this.curves.push(t);
      },
      closePath: function () {
        const t = this.curves[0].getPoint(0),
          e = this.curves[this.curves.length - 1].getPoint(1);
        t.equals(e) || this.curves.push(new Di(e, t));
      },
      getPoint: function (t) {
        for (let e = t * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length; ) {
          if (i[n] >= e) {
            const r = i[n] - e,
              a = this.curves[n],
              o = a.getLength(),
              s = 0 === o ? 0 : 1 - r / o;
            return a.getPointAt(s);
          }
          n++;
        }
        return null;
      },
      getLength: function () {
        const t = this.getCurveLengths();
        return t[t.length - 1];
      },
      updateArcLengths: function () {
        ((this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths());
      },
      getCurveLengths: function () {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++)
          ((e += this.curves[i].getLength()), t.push(e));
        return ((this.cacheLengths = t), t);
      },
      getSpacedPoints: function (t) {
        void 0 === t && (t = 40);
        for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
        return (this.autoClose && e.push(e[0]), e);
      },
      getPoints: function (t) {
        t = t || 12;
        for (var e, i = [], n = 0, r = this.curves; n < r.length; n++)
          for (
            let a = r[n],
              o =
                a && a.isEllipseCurve ? 2 * t : a && a.isLineCurve ? 1 : a && a.isSplineCurve ? t * a.points.length : t,
              s = a.getPoints(o),
              c = 0;
            c < s.length;
            c++
          ) {
            const h = s[c];
            (e && e.equals(h)) || (i.push(h), (e = h));
          }
        return (this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i);
      },
      copy: function (t) {
        (Ii.prototype.copy.call(this, t), (this.curves = []));
        for (let e = 0, i = t.curves.length; e < i; e++) {
          const n = t.curves[e];
          this.curves.push(n.clone());
        }
        return ((this.autoClose = t.autoClose), this);
      },
    })),
    ((Ui.prototype = Object.create(Ii.prototype)).constructor = Ui),
    (Ui.prototype.isEllipseCurve = !0),
    (Ui.prototype.getPoint = function (t, e) {
      for (
        var n = e || new i(), r = 2 * Math.PI, a = this.aEndAngle - this.aStartAngle, o = Math.abs(a) < Number.EPSILON;
        a < 0;
      )
        a += r;
      for (; a > r; ) a -= r;
      (a < Number.EPSILON && (a = o ? 0 : r), !0 !== this.aClockwise || o || (a === r ? (a = -r) : (a -= r)));
      let s = this.aStartAngle + t * a,
        c = this.aX + this.xRadius * Math.cos(s),
        h = this.aY + this.yRadius * Math.sin(s);
      if (0 !== this.aRotation) {
        const l = Math.cos(this.aRotation),
          u = Math.sin(this.aRotation),
          p = c - this.aX,
          d = h - this.aY;
        ((c = p * l - d * u + this.aX), (h = p * u + d * l + this.aY));
      }
      return n.set(c, h);
    }),
    (Ui.prototype.copy = function (t) {
      return (
        Ii.prototype.copy.call(this, t),
        (this.aX = t.aX),
        (this.aY = t.aY),
        (this.xRadius = t.xRadius),
        (this.yRadius = t.yRadius),
        (this.aStartAngle = t.aStartAngle),
        (this.aEndAngle = t.aEndAngle),
        (this.aClockwise = t.aClockwise),
        (this.aRotation = t.aRotation),
        this
      );
    }),
    ((Ni.prototype = Object.create(Ii.prototype)).constructor = Ni),
    (Ni.prototype.isSplineCurve = !0),
    (Ni.prototype.getPoint = function (t, e) {
      const n = e || new i(),
        r = this.points,
        a = (r.length - 1) * t,
        o = Math.floor(a),
        s = a - o,
        c = r[0 === o ? o : o - 1],
        h = r[o],
        l = r[o > r.length - 2 ? r.length - 1 : o + 1],
        u = r[o > r.length - 3 ? r.length - 1 : o + 2];
      return (n.set(Li(s, c.x, h.x, l.x, u.x), Li(s, c.y, h.y, l.y, u.y)), n);
    }),
    (Ni.prototype.copy = function (t) {
      (Ii.prototype.copy.call(this, t), (this.points = []));
      for (let e = 0, i = t.points.length; e < i; e++) {
        const n = t.points[e];
        this.points.push(n.clone());
      }
      return this;
    }),
    ((Bi.prototype = Object.create(Ii.prototype)).constructor = Bi),
    (Bi.prototype.isCubicBezierCurve = !0),
    (Bi.prototype.getPoint = function (t, e) {
      const n = e || new i(),
        r = this.v0,
        a = this.v1,
        o = this.v2,
        s = this.v3;
      return (n.set(Ci(t, r.x, a.x, o.x, s.x), Ci(t, r.y, a.y, o.y, s.y)), n);
    }),
    (Bi.prototype.copy = function (t) {
      return (
        Ii.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
      );
    }),
    ((Fi.prototype = Object.create(Ii.prototype)).constructor = Fi),
    (Fi.prototype.isQuadraticBezierCurve = !0),
    (Fi.prototype.getPoint = function (t, e) {
      const n = e || new i(),
        r = this.v0,
        a = this.v1,
        o = this.v2;
      return (n.set(Pi(t, r.x, a.x, o.x), Pi(t, r.y, a.y, o.y)), n);
    }),
    (Fi.prototype.copy = function (t) {
      return (Ii.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this);
    }),
    (zi.prototype = Object.assign(Object.create(Oi.prototype), {
      constructor: zi,
      setFromPoints: function (t) {
        this.moveTo(t[0].x, t[0].y);
        for (let e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y);
      },
      moveTo: function (t, e) {
        this.currentPoint.set(t, e);
      },
      lineTo: function (t, e) {
        const n = new Di(this.currentPoint.clone(), new i(t, e));
        (this.curves.push(n), this.currentPoint.set(t, e));
      },
      quadraticCurveTo: function (t, e, n, r) {
        const a = new Fi(this.currentPoint.clone(), new i(t, e), new i(n, r));
        (this.curves.push(a), this.currentPoint.set(n, r));
      },
      bezierCurveTo: function (t, e, n, r, a, o) {
        const s = new Bi(this.currentPoint.clone(), new i(t, e), new i(n, r), new i(a, o));
        (this.curves.push(s), this.currentPoint.set(a, o));
      },
      splineThru: function (t) {
        const e = new Ni([this.currentPoint.clone()].concat(t));
        (this.curves.push(e), this.currentPoint.copy(t[t.length - 1]));
      },
      arc: function (t, e, i, n, r, a) {
        const o = this.currentPoint.x,
          s = this.currentPoint.y;
        this.absarc(t + o, e + s, i, n, r, a);
      },
      absarc: function (t, e, i, n, r, a) {
        this.absellipse(t, e, i, i, n, r, a);
      },
      ellipse: function (t, e, i, n, r, a, o, s) {
        const c = this.currentPoint.x,
          h = this.currentPoint.y;
        this.absellipse(t + c, e + h, i, n, r, a, o, s);
      },
      absellipse: function (t, e, i, n, r, a, o, s) {
        const c = new Ui(t, e, i, n, r, a, o, s);
        if (this.curves.length > 0) {
          const h = c.getPoint(0);
          h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
        }
        this.curves.push(c);
        const l = c.getPoint(1);
        this.currentPoint.copy(l);
      },
      copy: function (t) {
        return (Oi.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this);
      },
    })),
    (Gi.prototype = Object.assign(Object.create(zi.prototype), {
      constructor: Gi,
      getPointsHoles: function (t) {
        for (var e = [], i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
        return e;
      },
      extractPoints: function (t) {
        return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
      },
      copy: function (t) {
        (zi.prototype.copy.call(this, t), (this.holes = []));
        for (let e = 0, i = t.holes.length; e < i; e++) {
          const n = t.holes[e];
          this.holes.push(n.clone());
        }
        return this;
      },
    })),
    Object.assign(Hi.prototype, {
      moveTo: function (t, e) {
        ((this.currentPath = new zi()), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e));
      },
      lineTo: function (t, e) {
        this.currentPath.lineTo(t, e);
      },
      quadraticCurveTo: function (t, e, i, n) {
        this.currentPath.quadraticCurveTo(t, e, i, n);
      },
      bezierCurveTo: function (t, e, i, n, r, a) {
        this.currentPath.bezierCurveTo(t, e, i, n, r, a);
      },
      splineThru: function (t) {
        this.currentPath.splineThru(t);
      },
      toShapes: function (t, e) {
        function i(t) {
          for (var e = [], i = 0, n = t.length; i < n; i++) {
            const r = t[i],
              a = new Gi();
            ((a.curves = r.curves), e.push(a));
          }
          return e;
        }
        const n = uo.isClockWise,
          r = this.subPaths;
        if (0 === r.length) return [];
        if (!0 === e) return i(r);
        let a,
          o,
          s,
          c = [];
        if (1 === r.length) return ((o = r[0]), (s = new Gi()), (s.curves = o.curves), c.push(s), c);
        let h = !n(r[0].getPoints());
        h = t ? !h : h;
        let l,
          u = [],
          p = [],
          d = [],
          f = 0;
        ((p[f] = void 0), (d[f] = []));
        for (var m = 0, v = r.length; m < v; m++)
          ((a = n((l = (o = r[m]).getPoints()))),
            (a = t ? !a : a)
              ? (!h && p[f] && f++, (p[f] = { s: new Gi(), p: l }), (p[f].s.curves = o.curves), h && f++, (d[f] = []))
              : d[f].push({ h: o, p: l[0] }));
        if (!p[0]) return i(r);
        if (p.length > 1) {
          for (var g = !1, y = [], x = 0, b = p.length; x < b; x++) u[x] = [];
          for (var x = 0, b = p.length; x < b; x++)
            for (let _ = d[x], w = 0; w < _.length; w++) {
              for (var E = _[w], M = !0, T = 0; T < p.length; T++)
                (function (t, e) {
                  for (var i = e.length, n = !1, r = i - 1, a = 0; a < i; r = a++) {
                    let o = e[r],
                      s = e[a],
                      c = s.x - o.x,
                      h = s.y - o.y;
                    if (Math.abs(h) > Number.EPSILON) {
                      if ((h < 0 && ((o = e[a]), (c = -c), (s = e[r]), (h = -h)), t.y < o.y || t.y > s.y)) continue;
                      if (t.y === o.y) {
                        if (t.x === o.x) return !0;
                      } else {
                        const l = h * (t.x - o.x) - c * (t.y - o.y);
                        if (0 === l) return !0;
                        if (l < 0) continue;
                        n = !n;
                      }
                    } else {
                      if (t.y !== o.y) continue;
                      if ((s.x <= t.x && t.x <= o.x) || (o.x <= t.x && t.x <= s.x)) return !0;
                    }
                  }
                  return n;
                })(E.p, p[T].p) &&
                  (x !== T && y.push({ froms: x, tos: T, hole: w }), M ? ((M = !1), u[T].push(E)) : (g = !0));
              M && u[x].push(E);
            }
          y.length > 0 && (g || (d = u));
        }
        for (var S, m = 0, A = p.length; m < A; m++) {
          ((s = p[m].s), c.push(s));
          for (let R = 0, L = (S = d[m]).length; R < L; R++) s.holes.push(S[R].h);
        }
        return c;
      },
    }),
    Object.assign(Vi.prototype, {
      isFont: !0,
      generateShapes: function (t, e, i) {
        (void 0 === e && (e = 100), void 0 === i && (i = 4));
        for (
          var n = this.data,
            r = (function (t) {
              for (
                var i = String(t).split(''),
                  r = e / n.resolution,
                  a = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r,
                  o = 0,
                  s = 0,
                  c = [],
                  h = 0;
                h < i.length;
                h++
              ) {
                const l = i[h];
                if ('\n' === l) ((o = 0), (s -= a));
                else {
                  const u = (function (t, e, i, r) {
                    const a = n.glyphs[t] || n.glyphs['?'];
                    if (a) {
                      let o,
                        s,
                        c,
                        h,
                        l,
                        u,
                        p,
                        d,
                        f,
                        m = new Hi(),
                        v = [];
                      if (a.o)
                        for (
                          let g = a._cachedOutline || (a._cachedOutline = a.o.split(' ')), y = 0, x = g.length;
                          y < x;
                        )
                          switch (g[y++]) {
                            case 'm':
                              ((o = g[y++] * e + i), (s = g[y++] * e + r), m.moveTo(o, s));
                              break;
                            case 'l':
                              ((o = g[y++] * e + i), (s = g[y++] * e + r), m.lineTo(o, s));
                              break;
                            case 'q':
                              ((c = g[y++] * e + i),
                                (h = g[y++] * e + r),
                                (l = g[y++] * e + i),
                                (u = g[y++] * e + r),
                                m.quadraticCurveTo(l, u, c, h),
                                (f = v[v.length - 1]) && (f.x, f.y));
                              break;
                            case 'b':
                              ((c = g[y++] * e + i),
                                (h = g[y++] * e + r),
                                (l = g[y++] * e + i),
                                (u = g[y++] * e + r),
                                (p = g[y++] * e + i),
                                (d = g[y++] * e + r),
                                m.bezierCurveTo(l, u, p, d, c, h),
                                (f = v[v.length - 1]) && (f.x, f.y));
                          }
                      return { offsetX: a.ha * e, path: m };
                    }
                  })(l, r, o, s);
                  ((o += u.offsetX), c.push(u.path));
                }
              }
              return c;
            })(t),
            a = [],
            o = 0,
            s = r.length;
          o < s;
          o++
        )
          Array.prototype.push.apply(a, r[o].toShapes());
        return a;
      },
    }),
    Object.assign(ki.prototype, {
      load: function (t, e, i, n) {
        const r = this,
          a = new Ye(this.manager);
        (a.setPath(this.path),
          a.load(
            t,
            function (t) {
              let i;
              try {
                i = JSON.parse(t);
              } catch (e) {
                (console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.'),
                  (i = JSON.parse(t.substring(65, t.length - 2))));
              }
              const n = r.parse(i);
              e && e(n);
            },
            i,
            n
          ));
      },
      parse: function (t) {
        return new Vi(t);
      },
      setPath: function (t) {
        return ((this.path = t), this);
      },
    }));
  var Eo,
    Mo = {
      getContext: function () {
        return (void 0 === Eo && (Eo = new (window.AudioContext || window.webkitAudioContext)()), Eo);
      },
      setContext: function (t) {
        Eo = t;
      },
    };
  (Object.assign(ji.prototype, {
    load: function (t, e, i, n) {
      const r = new Ye(this.manager);
      (r.setResponseType('arraybuffer'),
        r.load(
          t,
          function (t) {
            Mo.getContext().decodeAudioData(t, function (t) {
              e(t);
            });
          },
          i,
          n
        ));
    },
  }),
    Object.assign(Wi.prototype, {
      update: (function () {
        let t,
          e,
          i,
          r,
          a,
          o,
          s,
          c,
          h = new n(),
          l = new n();
        return function (n) {
          if (
            t !== this ||
            e !== n.focus ||
            i !== n.fov ||
            r !== n.aspect * this.aspect ||
            a !== n.near ||
            o !== n.far ||
            s !== n.zoom ||
            c !== this.eyeSep
          ) {
            ((t = this),
              (e = n.focus),
              (i = n.fov),
              (r = n.aspect * this.aspect),
              (a = n.near),
              (o = n.far),
              (s = n.zoom));
            let u,
              p,
              d = n.projectionMatrix.clone(),
              f = ((c = this.eyeSep / 2) * a) / e,
              m = (a * Math.tan(Wa.DEG2RAD * i * 0.5)) / s;
            ((l.elements[12] = -c),
              (h.elements[12] = c),
              (u = -m * r + f),
              (p = m * r + f),
              (d.elements[0] = (2 * a) / (p - u)),
              (d.elements[8] = (p + u) / (p - u)),
              this.cameraL.projectionMatrix.copy(d),
              (u = -m * r - f),
              (p = m * r - f),
              (d.elements[0] = (2 * a) / (p - u)),
              (d.elements[8] = (p + u) / (p - u)),
              this.cameraR.projectionMatrix.copy(d));
          }
          (this.cameraL.matrixWorld.copy(n.matrixWorld).multiply(l),
            this.cameraR.matrixWorld.copy(n.matrixWorld).multiply(h));
        };
      })(),
    }),
    ((Xi.prototype = Object.create(U.prototype)).constructor = Xi),
    (qi.prototype = Object.assign(Object.create(U.prototype), {
      constructor: qi,
      getInput: function () {
        return this.gain;
      },
      removeFilter: function () {
        null !== this.filter &&
          (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination),
          this.gain.connect(this.context.destination),
          (this.filter = null));
      },
      getFilter: function () {
        return this.filter;
      },
      setFilter: function (t) {
        (null !== this.filter
          ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination))
          : this.gain.disconnect(this.context.destination),
          (this.filter = t),
          this.gain.connect(this.filter),
          this.filter.connect(this.context.destination));
      },
      getMasterVolume: function () {
        return this.gain.gain.value;
      },
      setMasterVolume: function (t) {
        this.gain.gain.value = t;
      },
      updateMatrixWorld: (function () {
        const t = new a(),
          e = new r(),
          i = new a(),
          n = new a();
        return function (r) {
          U.prototype.updateMatrixWorld.call(this, r);
          const a = this.context.listener,
            o = this.up;
          (this.matrixWorld.decompose(t, e, i),
            n.set(0, 0, -1).applyQuaternion(e),
            a.positionX
              ? (a.positionX.setValueAtTime(t.x, this.context.currentTime),
                a.positionY.setValueAtTime(t.y, this.context.currentTime),
                a.positionZ.setValueAtTime(t.z, this.context.currentTime),
                a.forwardX.setValueAtTime(n.x, this.context.currentTime),
                a.forwardY.setValueAtTime(n.y, this.context.currentTime),
                a.forwardZ.setValueAtTime(n.z, this.context.currentTime),
                a.upX.setValueAtTime(o.x, this.context.currentTime),
                a.upY.setValueAtTime(o.y, this.context.currentTime),
                a.upZ.setValueAtTime(o.z, this.context.currentTime))
              : (a.setPosition(t.x, t.y, t.z), a.setOrientation(n.x, n.y, n.z, o.x, o.y, o.z)));
        };
      })(),
    })),
    (Yi.prototype = Object.assign(Object.create(U.prototype), {
      constructor: Yi,
      getOutput: function () {
        return this.gain;
      },
      setNodeSource: function (t) {
        return (
          (this.hasPlaybackControl = !1),
          (this.sourceType = 'audioNode'),
          (this.source = t),
          this.connect(),
          this
        );
      },
      setBuffer: function (t) {
        return ((this.buffer = t), (this.sourceType = 'buffer'), this.autoplay && this.play(), this);
      },
      play: function () {
        if (!0 !== this.isPlaying) {
          if (!1 !== this.hasPlaybackControl) {
            const t = this.context.createBufferSource();
            return (
              (t.buffer = this.buffer),
              (t.loop = this.loop),
              (t.onended = this.onEnded.bind(this)),
              t.playbackRate.setValueAtTime(this.playbackRate, this.startTime),
              (this.startTime = this.context.currentTime),
              t.start(this.startTime, this.offset),
              (this.isPlaying = !0),
              (this.source = t),
              this.connect()
            );
          }
          console.warn('THREE.Audio: this Audio has no playback control.');
        } else console.warn('THREE.Audio: Audio is already playing.');
      },
      pause: function () {
        if (!1 !== this.hasPlaybackControl)
          return (
            !0 === this.isPlaying &&
              (this.source.stop(),
              (this.offset += (this.context.currentTime - this.startTime) * this.playbackRate),
              (this.isPlaying = !1)),
            this
          );
        console.warn('THREE.Audio: this Audio has no playback control.');
      },
      stop: function () {
        if (!1 !== this.hasPlaybackControl) return (this.source.stop(), (this.offset = 0), (this.isPlaying = !1), this);
        console.warn('THREE.Audio: this Audio has no playback control.');
      },
      connect: function () {
        if (this.filters.length > 0) {
          this.source.connect(this.filters[0]);
          for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return this;
      },
      disconnect: function () {
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return this;
      },
      getFilters: function () {
        return this.filters;
      },
      setFilters: function (t) {
        return (
          t || (t = []),
          !0 === this.isPlaying ? (this.disconnect(), (this.filters = t), this.connect()) : (this.filters = t),
          this
        );
      },
      getFilter: function () {
        return this.getFilters()[0];
      },
      setFilter: function (t) {
        return this.setFilters(t ? [t] : []);
      },
      setPlaybackRate: function (t) {
        if (!1 !== this.hasPlaybackControl)
          return (
            (this.playbackRate = t),
            !0 === this.isPlaying &&
              this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime),
            this
          );
        console.warn('THREE.Audio: this Audio has no playback control.');
      },
      getPlaybackRate: function () {
        return this.playbackRate;
      },
      onEnded: function () {
        this.isPlaying = !1;
      },
      getLoop: function () {
        return !1 === this.hasPlaybackControl
          ? (console.warn('THREE.Audio: this Audio has no playback control.'), !1)
          : this.loop;
      },
      setLoop: function (t) {
        if (!1 !== this.hasPlaybackControl)
          return ((this.loop = t), !0 === this.isPlaying && (this.source.loop = this.loop), this);
        console.warn('THREE.Audio: this Audio has no playback control.');
      },
      getVolume: function () {
        return this.gain.gain.value;
      },
      setVolume: function (t) {
        return ((this.gain.gain.value = t), this);
      },
    })),
    (Zi.prototype = Object.assign(Object.create(Yi.prototype), {
      constructor: Zi,
      getOutput: function () {
        return this.panner;
      },
      getRefDistance: function () {
        return this.panner.refDistance;
      },
      setRefDistance: function (t) {
        this.panner.refDistance = t;
      },
      getRolloffFactor: function () {
        return this.panner.rolloffFactor;
      },
      setRolloffFactor: function (t) {
        this.panner.rolloffFactor = t;
      },
      getDistanceModel: function () {
        return this.panner.distanceModel;
      },
      setDistanceModel: function (t) {
        this.panner.distanceModel = t;
      },
      getMaxDistance: function () {
        return this.panner.maxDistance;
      },
      setMaxDistance: function (t) {
        this.panner.maxDistance = t;
      },
      updateMatrixWorld: (function () {
        const t = new a();
        return function (e) {
          (U.prototype.updateMatrixWorld.call(this, e),
            t.setFromMatrixPosition(this.matrixWorld),
            this.panner.setPosition(t.x, t.y, t.z));
        };
      })(),
    })),
    Object.assign(Qi.prototype, {
      getFrequencyData: function () {
        return (this.analyser.getByteFrequencyData(this.data), this.data);
      },
      getAverageFrequency: function () {
        for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[i];
        return t / e.length;
      },
    }),
    Object.assign(Ji.prototype, {
      accumulate: function (t, e) {
        let i = this.buffer,
          n = this.valueSize,
          r = t * n + n,
          a = this.cumulativeWeight;
        if (0 === a) {
          for (let o = 0; o !== n; ++o) i[r + o] = i[o];
          a = e;
        } else {
          const s = e / (a += e);
          this._mixBufferRegion(i, r, 0, s, n);
        }
        this.cumulativeWeight = a;
      },
      apply: function (t) {
        const e = this.valueSize,
          i = this.buffer,
          n = t * e + e,
          r = this.cumulativeWeight,
          a = this.binding;
        if (((this.cumulativeWeight = 0), r < 1)) {
          const o = 3 * e;
          this._mixBufferRegion(i, n, o, 1 - r, e);
        }
        for (let s = e, c = e + e; s !== c; ++s)
          if (i[s] !== i[s + e]) {
            a.setValue(i, n);
            break;
          }
      },
      saveOriginalState: function () {
        const t = this.binding,
          e = this.buffer,
          i = this.valueSize,
          n = 3 * i;
        t.getValue(e, n);
        for (let r = i, a = n; r !== a; ++r) e[r] = e[n + (r % i)];
        this.cumulativeWeight = 0;
      },
      restoreOriginalState: function () {
        const t = 3 * this.valueSize;
        this.binding.setValue(this.buffer, t);
      },
      _select: function (t, e, i, n, r) {
        if (n >= 0.5) for (let a = 0; a !== r; ++a) t[e + a] = t[i + a];
      },
      _slerp: function (t, e, i, n) {
        r.slerpFlat(t, e, t, e, t, i, n);
      },
      _lerp: function (t, e, i, n, r) {
        for (let a = 1 - n, o = 0; o !== r; ++o) {
          const s = e + o;
          t[s] = t[s] * a + t[i + o] * n;
        }
      },
    }),
    Object.assign(Ki.prototype, {
      getValue: function (t, e) {
        this.bind();
        const i = this._targetGroup.nCachedObjects_,
          n = this._bindings[i];
        void 0 !== n && n.getValue(t, e);
      },
      setValue: function (t, e) {
        for (let i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)
          i[n].setValue(t, e);
      },
      bind: function () {
        for (let t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind();
      },
      unbind: function () {
        for (let t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind();
      },
    }),
    Object.assign($i, {
      Composite: Ki,
      create: function (t, e, i) {
        return t && t.isAnimationObjectGroup ? new $i.Composite(t, e, i) : new $i(t, e, i);
      },
      sanitizeNodeName: function (t) {
        return t.replace(/\s/g, '_').replace(/[^\w-]/g, '');
      },
      parseTrackName: (function () {
        const t = new RegExp(
            '^' +
              /((?:[\w-]+[\/:])*)/.source +
              /([\w-\.]+)?/.source +
              /(?:\.([\w-]+)(?:\[(.+)\])?)?/.source +
              /\.([\w-]+)(?:\[(.+)\])?/.source +
              '$'
          ),
          e = ['material', 'materials', 'bones'];
        return function (i) {
          const n = t.exec(i);
          if (!n) throw new Error('PropertyBinding: Cannot parse trackName: ' + i);
          const r = { nodeName: n[2], objectName: n[3], objectIndex: n[4], propertyName: n[5], propertyIndex: n[6] },
            a = r.nodeName && r.nodeName.lastIndexOf('.');
          if (void 0 !== a && -1 !== a) {
            const o = r.nodeName.substring(a + 1);
            -1 !== e.indexOf(o) && ((r.nodeName = r.nodeName.substring(0, a)), (r.objectName = o));
          }
          if (null === r.propertyName || 0 === r.propertyName.length)
            throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + i);
          return r;
        };
      })(),
      findNode: function (t, e) {
        if (!e || '' === e || 'root' === e || '.' === e || -1 === e || e === t.name || e === t.uuid) return t;
        if (t.skeleton) {
          const i = (function (t) {
            for (let i = 0; i < t.bones.length; i++) {
              const n = t.bones[i];
              if (n.name === e) return n;
            }
            return null;
          })(t.skeleton);
          if (i) return i;
        }
        if (t.children) {
          const n = function (t) {
              for (let i = 0; i < t.length; i++) {
                const r = t[i];
                if (r.name === e || r.uuid === e) return r;
                const a = n(r.children);
                if (a) return a;
              }
              return null;
            },
            r = n(t.children);
          if (r) return r;
        }
        return null;
      },
    }),
    Object.assign($i.prototype, {
      _getValue_unavailable: function () {},
      _setValue_unavailable: function () {},
      BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 },
      Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
      GetterByBindingType: [
        function (t, e) {
          t[e] = this.node[this.propertyName];
        },
        function (t, e) {
          for (let i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) t[e++] = i[n];
        },
        function (t, e) {
          t[e] = this.resolvedProperty[this.propertyIndex];
        },
        function (t, e) {
          this.resolvedProperty.toArray(t, e);
        },
      ],
      SetterByBindingTypeAndVersioning: [
        [
          function (t, e) {
            this.targetObject[this.propertyName] = t[e];
          },
          function (t, e) {
            ((this.targetObject[this.propertyName] = t[e]), (this.targetObject.needsUpdate = !0));
          },
          function (t, e) {
            ((this.targetObject[this.propertyName] = t[e]), (this.targetObject.matrixWorldNeedsUpdate = !0));
          },
        ],
        [
          function (t, e) {
            for (let i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
          },
          function (t, e) {
            for (let i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
            this.targetObject.needsUpdate = !0;
          },
          function (t, e) {
            for (let i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
          },
        ],
        [
          function (t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e];
          },
          function (t, e) {
            ((this.resolvedProperty[this.propertyIndex] = t[e]), (this.targetObject.needsUpdate = !0));
          },
          function (t, e) {
            ((this.resolvedProperty[this.propertyIndex] = t[e]), (this.targetObject.matrixWorldNeedsUpdate = !0));
          },
        ],
        [
          function (t, e) {
            this.resolvedProperty.fromArray(t, e);
          },
          function (t, e) {
            (this.resolvedProperty.fromArray(t, e), (this.targetObject.needsUpdate = !0));
          },
          function (t, e) {
            (this.resolvedProperty.fromArray(t, e), (this.targetObject.matrixWorldNeedsUpdate = !0));
          },
        ],
      ],
      getValue: function (t, e) {
        (this.bind(), this.getValue(t, e));
      },
      setValue: function (t, e) {
        (this.bind(), this.setValue(t, e));
      },
      bind: function () {
        let t = this.node,
          e = this.parsedPath,
          i = e.objectName,
          n = e.propertyName,
          r = e.propertyIndex;
        if (
          (t || ((t = $i.findNode(this.rootNode, e.nodeName) || this.rootNode), (this.node = t)),
          (this.getValue = this._getValue_unavailable),
          (this.setValue = this._setValue_unavailable),
          t)
        ) {
          if (i) {
            let a = e.objectIndex;
            switch (i) {
              case 'materials':
                if (!t.material)
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
                    this
                  );
                if (!t.material.materials)
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
                    this
                  );
                t = t.material.materials;
                break;
              case 'bones':
                if (!t.skeleton)
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
                    this
                  );
                t = t.skeleton.bones;
                for (h = 0; h < t.length; h++)
                  if (t[h].name === a) {
                    a = h;
                    break;
                  }
                break;
              default:
                if (void 0 === t[i])
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
                    this
                  );
                t = t[i];
            }
            if (void 0 !== a) {
              if (void 0 === t[a])
                return void console.error(
                  'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
                  this,
                  t
                );
              t = t[a];
            }
          }
          const o = t[n];
          if (void 0 !== o) {
            let s = this.Versioning.None;
            void 0 !== t.needsUpdate
              ? ((s = this.Versioning.NeedsUpdate), (this.targetObject = t))
              : void 0 !== t.matrixWorldNeedsUpdate &&
                ((s = this.Versioning.MatrixWorldNeedsUpdate), (this.targetObject = t));
            let c = this.BindingType.Direct;
            if (void 0 !== r) {
              if ('morphTargetInfluences' === n) {
                if (!t.geometry)
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
                    this
                  );
                if (t.geometry.isBufferGeometry) {
                  if (!t.geometry.morphAttributes)
                    return void console.error(
                      'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
                      this
                    );
                  for (h = 0; h < this.node.geometry.morphAttributes.position.length; h++)
                    if (t.geometry.morphAttributes.position[h].name === r) {
                      r = h;
                      break;
                    }
                } else {
                  if (!t.geometry.morphTargets)
                    return void console.error(
                      'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.',
                      this
                    );
                  for (var h = 0; h < this.node.geometry.morphTargets.length; h++)
                    if (t.geometry.morphTargets[h].name === r) {
                      r = h;
                      break;
                    }
                }
              }
              ((c = this.BindingType.ArrayElement), (this.resolvedProperty = o), (this.propertyIndex = r));
            } else
              void 0 !== o.fromArray && void 0 !== o.toArray
                ? ((c = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
                : Array.isArray(o)
                  ? ((c = this.BindingType.EntireArray), (this.resolvedProperty = o))
                  : (this.propertyName = n);
            ((this.getValue = this.GetterByBindingType[c]),
              (this.setValue = this.SetterByBindingTypeAndVersioning[c][s]));
          } else {
            const l = e.nodeName;
            console.error(
              'THREE.PropertyBinding: Trying to update property for track: ' + l + '.' + n + " but it wasn't found.",
              t
            );
          }
        } else
          console.error(
            'THREE.PropertyBinding: Trying to update node for track: ' + this.path + " but it wasn't found."
          );
      },
      unbind: function () {
        ((this.node = null), (this.getValue = this._getValue_unbound), (this.setValue = this._setValue_unbound));
      },
    }),
    Object.assign($i.prototype, { _getValue_unbound: $i.prototype.getValue, _setValue_unbound: $i.prototype.setValue }),
    Object.assign(tn.prototype, {
      isAnimationObjectGroup: !0,
      add: function () {
        for (
          var t = this._objects,
            e = t.length,
            i = this.nCachedObjects_,
            n = this._indicesByUUID,
            r = this._paths,
            a = this._parsedPaths,
            o = this._bindings,
            s = o.length,
            c = 0,
            h = arguments.length;
          c !== h;
          ++c
        ) {
          let l = arguments[c],
            u = l.uuid,
            p = n[u],
            d = void 0;
          if (void 0 === p) {
            ((p = e++), (n[u] = p), t.push(l));
            for (var f = 0, m = s; f !== m; ++f) o[f].push(new $i(l, r[f], a[f]));
          } else if (p < i) {
            d = t[p];
            const v = --i,
              g = t[v];
            ((n[g.uuid] = p), (t[p] = g), (n[u] = v), (t[v] = l));
            for (var f = 0, m = s; f !== m; ++f) {
              let y = o[f],
                x = y[v],
                b = y[p];
              ((y[p] = x), void 0 === b && (b = new $i(l, r[f], a[f])), (y[v] = b));
            }
          } else
            t[p] !== d &&
              console.error(
                'THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.'
              );
        }
        this.nCachedObjects_ = i;
      },
      remove: function () {
        for (
          var t = this._objects,
            e = this.nCachedObjects_,
            i = this._indicesByUUID,
            n = this._bindings,
            r = n.length,
            a = 0,
            o = arguments.length;
          a !== o;
          ++a
        ) {
          const s = arguments[a],
            c = s.uuid,
            h = i[c];
          if (void 0 !== h && h >= e) {
            const l = e++,
              u = t[l];
            ((i[u.uuid] = h), (t[h] = u), (i[c] = l), (t[l] = s));
            for (let p = 0, d = r; p !== d; ++p) {
              const f = n[p],
                m = f[l],
                v = f[h];
              ((f[h] = m), (f[l] = v));
            }
          }
        }
        this.nCachedObjects_ = e;
      },
      uncache: function () {
        for (
          var t = this._objects,
            e = t.length,
            i = this.nCachedObjects_,
            n = this._indicesByUUID,
            r = this._bindings,
            a = r.length,
            o = 0,
            s = arguments.length;
          o !== s;
          ++o
        ) {
          const c = arguments[o].uuid,
            h = n[c];
          if (void 0 !== h)
            if ((delete n[c], h < i)) {
              var l = --i,
                u = t[l],
                p = t[(g = --e)];
              ((n[u.uuid] = h), (t[h] = u), (n[p.uuid] = l), (t[l] = p), t.pop());
              for (var d = 0, f = a; d !== f; ++d) {
                const m = (y = r[d])[l],
                  v = y[g];
                ((y[h] = m), (y[l] = v), y.pop());
              }
            } else {
              var g = --e;
              ((n[(p = t[g]).uuid] = h), (t[h] = p), t.pop());
              for (var d = 0, f = a; d !== f; ++d) {
                var y = r[d];
                ((y[h] = y[g]), y.pop());
              }
            }
        }
        this.nCachedObjects_ = i;
      },
      subscribe_: function (t, e) {
        let i = this._bindingsIndicesByPath,
          n = i[t],
          r = this._bindings;
        if (void 0 !== n) return r[n];
        const a = this._paths,
          o = this._parsedPaths,
          s = this._objects,
          c = s.length,
          h = this.nCachedObjects_,
          l = new Array(c);
        ((n = r.length), (i[t] = n), a.push(t), o.push(e), r.push(l));
        for (let u = h, p = s.length; u !== p; ++u) {
          const d = s[u];
          l[u] = new $i(d, t, e);
        }
        return l;
      },
      unsubscribe_: function (t) {
        const e = this._bindingsIndicesByPath,
          i = e[t];
        if (void 0 !== i) {
          const n = this._paths,
            r = this._parsedPaths,
            a = this._bindings,
            o = a.length - 1,
            s = a[o];
          ((e[t[o]] = i), (a[i] = s), a.pop(), (r[i] = r[o]), r.pop(), (n[i] = n[o]), n.pop());
        }
      },
    }),
    Object.assign(en.prototype, {
      play: function () {
        return (this._mixer._activateAction(this), this);
      },
      stop: function () {
        return (this._mixer._deactivateAction(this), this.reset());
      },
      reset: function () {
        return (
          (this.paused = !1),
          (this.enabled = !0),
          (this.time = 0),
          (this._loopCount = -1),
          (this._startTime = null),
          this.stopFading().stopWarping()
        );
      },
      isRunning: function () {
        return (
          this.enabled &&
          !this.paused &&
          0 !== this.timeScale &&
          null === this._startTime &&
          this._mixer._isActiveAction(this)
        );
      },
      isScheduled: function () {
        return this._mixer._isActiveAction(this);
      },
      startAt: function (t) {
        return ((this._startTime = t), this);
      },
      setLoop: function (t, e) {
        return ((this.loop = t), (this.repetitions = e), this);
      },
      setEffectiveWeight: function (t) {
        return ((this.weight = t), (this._effectiveWeight = this.enabled ? t : 0), this.stopFading());
      },
      getEffectiveWeight: function () {
        return this._effectiveWeight;
      },
      fadeIn: function (t) {
        return this._scheduleFading(t, 0, 1);
      },
      fadeOut: function (t) {
        return this._scheduleFading(t, 1, 0);
      },
      crossFadeFrom: function (t, e, i) {
        if ((t.fadeOut(e), this.fadeIn(e), i)) {
          const n = this._clip.duration,
            r = t._clip.duration,
            a = r / n,
            o = n / r;
          (t.warp(1, a, e), this.warp(o, 1, e));
        }
        return this;
      },
      crossFadeTo: function (t, e, i) {
        return t.crossFadeFrom(this, e, i);
      },
      stopFading: function () {
        const t = this._weightInterpolant;
        return (null !== t && ((this._weightInterpolant = null), this._mixer._takeBackControlInterpolant(t)), this);
      },
      setEffectiveTimeScale: function (t) {
        return ((this.timeScale = t), (this._effectiveTimeScale = this.paused ? 0 : t), this.stopWarping());
      },
      getEffectiveTimeScale: function () {
        return this._effectiveTimeScale;
      },
      setDuration: function (t) {
        return ((this.timeScale = this._clip.duration / t), this.stopWarping());
      },
      syncWith: function (t) {
        return ((this.time = t.time), (this.timeScale = t.timeScale), this.stopWarping());
      },
      halt: function (t) {
        return this.warp(this._effectiveTimeScale, 0, t);
      },
      warp: function (t, e, i) {
        let n = this._mixer,
          r = n.time,
          a = this._timeScaleInterpolant,
          o = this.timeScale;
        null === a && ((a = n._lendControlInterpolant()), (this._timeScaleInterpolant = a));
        const s = a.parameterPositions,
          c = a.sampleValues;
        return ((s[0] = r), (s[1] = r + i), (c[0] = t / o), (c[1] = e / o), this);
      },
      stopWarping: function () {
        const t = this._timeScaleInterpolant;
        return (null !== t && ((this._timeScaleInterpolant = null), this._mixer._takeBackControlInterpolant(t)), this);
      },
      getMixer: function () {
        return this._mixer;
      },
      getClip: function () {
        return this._clip;
      },
      getRoot: function () {
        return this._localRoot || this._mixer._root;
      },
      _update: function (t, e, i, n) {
        if (this.enabled) {
          const r = this._startTime;
          if (null !== r) {
            const a = (t - r) * i;
            if (a < 0 || 0 === i) return;
            ((this._startTime = null), (e = i * a));
          }
          e *= this._updateTimeScale(t);
          const o = this._updateTime(e),
            s = this._updateWeight(t);
          if (s > 0)
            for (let c = this._interpolants, h = this._propertyBindings, l = 0, u = c.length; l !== u; ++l)
              (c[l].evaluate(o), h[l].accumulate(n, s));
        } else this._updateWeight(t);
      },
      _updateWeight: function (t) {
        let e = 0;
        if (this.enabled) {
          e = this.weight;
          const i = this._weightInterpolant;
          if (null !== i) {
            const n = i.evaluate(t)[0];
            ((e *= n), t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1)));
          }
        }
        return ((this._effectiveWeight = e), e);
      },
      _updateTimeScale: function (t) {
        let e = 0;
        if (!this.paused) {
          e = this.timeScale;
          const i = this._timeScaleInterpolant;
          if (null !== i) {
            ((e *= i.evaluate(t)[0]),
              t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? (this.paused = !0) : (this.timeScale = e)));
          }
        }
        return ((this._effectiveTimeScale = e), e);
      },
      _updateTime: function (t) {
        let e = this.time + t;
        if (0 === t) return e;
        let i = this._clip.duration,
          n = this.loop,
          r = this._loopCount;
        if (2200 === n) {
          -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
          t: {
            if (e >= i) e = i;
            else {
              if (!(e < 0)) break t;
              e = 0;
            }
            (this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
              this._mixer.dispatchEvent({ type: 'finished', action: this, direction: t < 0 ? -1 : 1 }));
          }
        } else {
          const a = 2202 === n;
          if (
            (-1 === r &&
              (t >= 0
                ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, a))
                : this._setEndings(0 === this.repetitions, !0, a)),
            e >= i || e < 0)
          ) {
            const o = Math.floor(e / i);
            ((e -= i * o), (r += Math.abs(o)));
            const s = this.repetitions - r;
            if (s < 0)
              (this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (e = t > 0 ? i : 0),
                this._mixer.dispatchEvent({ type: 'finished', action: this, direction: t > 0 ? 1 : -1 }));
            else {
              if (0 === s) {
                const c = t < 0;
                this._setEndings(c, !c, a);
              } else this._setEndings(!1, !1, a);
              ((this._loopCount = r), this._mixer.dispatchEvent({ type: 'loop', action: this, loopDelta: o }));
            }
          }
          if (a && 1 == (1 & r)) return ((this.time = e), i - e);
        }
        return ((this.time = e), e);
      },
      _setEndings: function (t, e, i) {
        const n = this._interpolantSettings;
        i
          ? ((n.endingStart = 2401), (n.endingEnd = 2401))
          : ((n.endingStart = t ? (this.zeroSlopeAtStart ? 2401 : Ia) : 2402),
            (n.endingEnd = e ? (this.zeroSlopeAtEnd ? 2401 : Ia) : 2402));
      },
      _scheduleFading: function (t, e, i) {
        let n = this._mixer,
          r = n.time,
          a = this._weightInterpolant;
        null === a && ((a = n._lendControlInterpolant()), (this._weightInterpolant = a));
        const o = a.parameterPositions,
          s = a.sampleValues;
        return ((o[0] = r), (s[0] = e), (o[1] = r + t), (s[1] = i), this);
      },
    }),
    Object.assign(nn.prototype, e.prototype, {
      _bindAction: function (t, e) {
        let i = t._localRoot || this._root,
          n = t._clip.tracks,
          r = n.length,
          a = t._propertyBindings,
          o = t._interpolants,
          s = i.uuid,
          c = this._bindingsByRootAndName,
          h = c[s];
        void 0 === h && ((h = {}), (c[s] = h));
        for (let l = 0; l !== r; ++l) {
          let u = n[l],
            p = u.name,
            d = h[p];
          if (void 0 !== d) a[l] = d;
          else {
            if (void 0 !== (d = a[l])) {
              null === d._cacheIndex && (++d.referenceCount, this._addInactiveBinding(d, s, p));
              continue;
            }
            const f = e && e._propertyBindings[l].binding.parsedPath;
            (++(d = new Ji($i.create(i, p, f), u.ValueTypeName, u.getValueSize())).referenceCount,
              this._addInactiveBinding(d, s, p),
              (a[l] = d));
          }
          o[l].resultBuffer = d.buffer;
        }
      },
      _activateAction: function (t) {
        if (!this._isActiveAction(t)) {
          if (null === t._cacheIndex) {
            const e = (t._localRoot || this._root).uuid,
              i = t._clip.uuid,
              n = this._actionsByClip[i];
            (this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e));
          }
          for (let r = t._propertyBindings, a = 0, o = r.length; a !== o; ++a) {
            const s = r[a];
            0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState());
          }
          this._lendAction(t);
        }
      },
      _deactivateAction: function (t) {
        if (this._isActiveAction(t)) {
          for (let e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
            const r = e[i];
            0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r));
          }
          this._takeBackAction(t);
        }
      },
      _initMemoryManager: function () {
        ((this._actions = []),
          (this._nActiveActions = 0),
          (this._actionsByClip = {}),
          (this._bindings = []),
          (this._nActiveBindings = 0),
          (this._bindingsByRootAndName = {}),
          (this._controlInterpolants = []),
          (this._nActiveControlInterpolants = 0));
        const t = this;
        this.stats = {
          actions: {
            get total() {
              return t._actions.length;
            },
            get inUse() {
              return t._nActiveActions;
            },
          },
          bindings: {
            get total() {
              return t._bindings.length;
            },
            get inUse() {
              return t._nActiveBindings;
            },
          },
          controlInterpolants: {
            get total() {
              return t._controlInterpolants.length;
            },
            get inUse() {
              return t._nActiveControlInterpolants;
            },
          },
        };
      },
      _isActiveAction: function (t) {
        const e = t._cacheIndex;
        return null !== e && e < this._nActiveActions;
      },
      _addInactiveAction: function (t, e, i) {
        let n = this._actions,
          r = this._actionsByClip,
          a = r[e];
        if (void 0 === a) ((a = { knownActions: [t], actionByRoot: {} }), (t._byClipCacheIndex = 0), (r[e] = a));
        else {
          const o = a.knownActions;
          ((t._byClipCacheIndex = o.length), o.push(t));
        }
        ((t._cacheIndex = n.length), n.push(t), (a.actionByRoot[i] = t));
      },
      _removeInactiveAction: function (t) {
        const e = this._actions,
          i = e[e.length - 1],
          n = t._cacheIndex;
        ((i._cacheIndex = n), (e[n] = i), e.pop(), (t._cacheIndex = null));
        const r = t._clip.uuid,
          a = this._actionsByClip,
          o = a[r],
          s = o.knownActions,
          c = s[s.length - 1],
          h = t._byClipCacheIndex;
        ((c._byClipCacheIndex = h), (s[h] = c), s.pop(), (t._byClipCacheIndex = null));
        (delete o.actionByRoot[(t._localRoot || this._root).uuid],
          0 === s.length && delete a[r],
          this._removeInactiveBindingsForAction(t));
      },
      _removeInactiveBindingsForAction: function (t) {
        for (let e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
          const r = e[i];
          0 == --r.referenceCount && this._removeInactiveBinding(r);
        }
      },
      _lendAction: function (t) {
        const e = this._actions,
          i = t._cacheIndex,
          n = this._nActiveActions++,
          r = e[n];
        ((t._cacheIndex = n), (e[n] = t), (r._cacheIndex = i), (e[i] = r));
      },
      _takeBackAction: function (t) {
        const e = this._actions,
          i = t._cacheIndex,
          n = --this._nActiveActions,
          r = e[n];
        ((t._cacheIndex = n), (e[n] = t), (r._cacheIndex = i), (e[i] = r));
      },
      _addInactiveBinding: function (t, e, i) {
        let n = this._bindingsByRootAndName,
          r = n[e],
          a = this._bindings;
        (void 0 === r && ((r = {}), (n[e] = r)), (r[i] = t), (t._cacheIndex = a.length), a.push(t));
      },
      _removeInactiveBinding: function (t) {
        const e = this._bindings,
          i = t.binding,
          n = i.rootNode.uuid,
          r = i.path,
          a = this._bindingsByRootAndName,
          o = a[n],
          s = e[e.length - 1],
          c = t._cacheIndex;
        ((s._cacheIndex = c), (e[c] = s), e.pop(), delete o[r]);
        t: {
          for (const h in o) break t;
          delete a[n];
        }
      },
      _lendBinding: function (t) {
        const e = this._bindings,
          i = t._cacheIndex,
          n = this._nActiveBindings++,
          r = e[n];
        ((t._cacheIndex = n), (e[n] = t), (r._cacheIndex = i), (e[i] = r));
      },
      _takeBackBinding: function (t) {
        const e = this._bindings,
          i = t._cacheIndex,
          n = --this._nActiveBindings,
          r = e[n];
        ((t._cacheIndex = n), (e[n] = t), (r._cacheIndex = i), (e[i] = r));
      },
      _lendControlInterpolant: function () {
        let t = this._controlInterpolants,
          e = this._nActiveControlInterpolants++,
          i = t[e];
        return (
          void 0 === i &&
            (((i = new yi(
              new Float32Array(2),
              new Float32Array(2),
              1,
              this._controlInterpolantsResultBuffer
            )).__cacheIndex = e),
            (t[e] = i)),
          i
        );
      },
      _takeBackControlInterpolant: function (t) {
        const e = this._controlInterpolants,
          i = t.__cacheIndex,
          n = --this._nActiveControlInterpolants,
          r = e[n];
        ((t.__cacheIndex = n), (e[n] = t), (r.__cacheIndex = i), (e[i] = r));
      },
      _controlInterpolantsResultBuffer: new Float32Array(1),
      clipAction: function (t, e) {
        let i = e || this._root,
          n = i.uuid,
          r = 'string' == typeof t ? wi.findByName(i, t) : t,
          a = null !== r ? r.uuid : t,
          o = this._actionsByClip[a],
          s = null;
        if (void 0 !== o) {
          const c = o.actionByRoot[n];
          if (void 0 !== c) return c;
          ((s = o.knownActions[0]), null === r && (r = s._clip));
        }
        if (null === r) return null;
        const h = new en(this, r, e);
        return (this._bindAction(h, s), this._addInactiveAction(h, a, n), h);
      },
      existingAction: function (t, e) {
        const i = e || this._root,
          n = i.uuid,
          r = 'string' == typeof t ? wi.findByName(i, t) : t,
          a = r ? r.uuid : t,
          o = this._actionsByClip[a];
        return void 0 !== o ? o.actionByRoot[n] || null : null;
      },
      stopAllAction: function () {
        const t = this._actions,
          e = this._nActiveActions,
          i = this._bindings,
          n = this._nActiveBindings;
        ((this._nActiveActions = 0), (this._nActiveBindings = 0));
        for (r = 0; r !== e; ++r) t[r].reset();
        for (var r = 0; r !== n; ++r) i[r].useCount = 0;
        return this;
      },
      update: function (t) {
        t *= this.timeScale;
        for (
          var e = this._actions,
            i = this._nActiveActions,
            n = (this.time += t),
            r = Math.sign(t),
            a = (this._accuIndex ^= 1),
            o = 0;
          o !== i;
          ++o
        ) {
          e[o]._update(n, t, r, a);
        }
        for (var s = this._bindings, c = this._nActiveBindings, o = 0; o !== c; ++o) s[o].apply(a);
        return this;
      },
      getRoot: function () {
        return this._root;
      },
      uncacheClip: function (t) {
        const e = this._actions,
          i = t.uuid,
          n = this._actionsByClip,
          r = n[i];
        if (void 0 !== r) {
          for (let a = r.knownActions, o = 0, s = a.length; o !== s; ++o) {
            const c = a[o];
            this._deactivateAction(c);
            const h = c._cacheIndex,
              l = e[e.length - 1];
            ((c._cacheIndex = null),
              (c._byClipCacheIndex = null),
              (l._cacheIndex = h),
              (e[h] = l),
              e.pop(),
              this._removeInactiveBindingsForAction(c));
          }
          delete n[i];
        }
      },
      uncacheRoot: function (t) {
        const e = t.uuid,
          i = this._actionsByClip;
        for (const n in i) {
          const r = i[n].actionByRoot[e];
          void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r));
        }
        const a = this._bindingsByRootAndName[e];
        if (void 0 !== a)
          for (const o in a) {
            const s = a[o];
            (s.restoreOriginalState(), this._removeInactiveBinding(s));
          }
      },
      uncacheAction: function (t, e) {
        const i = this.existingAction(t, e);
        null !== i && (this._deactivateAction(i), this._removeInactiveAction(i));
      },
    }),
    (rn.prototype.clone = function () {
      return new rn(void 0 === this.value.clone ? this.value : this.value.clone());
    }),
    (an.prototype = Object.assign(Object.create(K.prototype), {
      constructor: an,
      isInstancedBufferGeometry: !0,
      copy: function (t) {
        return (K.prototype.copy.call(this, t), (this.maxInstancedCount = t.maxInstancedCount), this);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
    })),
    Object.defineProperties(on.prototype, {
      count: {
        get: function () {
          return this.data.count;
        },
      },
      array: {
        get: function () {
          return this.data.array;
        },
      },
    }),
    Object.assign(on.prototype, {
      isInterleavedBufferAttribute: !0,
      setX: function (t, e) {
        return ((this.data.array[t * this.data.stride + this.offset] = e), this);
      },
      setY: function (t, e) {
        return ((this.data.array[t * this.data.stride + this.offset + 1] = e), this);
      },
      setZ: function (t, e) {
        return ((this.data.array[t * this.data.stride + this.offset + 2] = e), this);
      },
      setW: function (t, e) {
        return ((this.data.array[t * this.data.stride + this.offset + 3] = e), this);
      },
      getX: function (t) {
        return this.data.array[t * this.data.stride + this.offset];
      },
      getY: function (t) {
        return this.data.array[t * this.data.stride + this.offset + 1];
      },
      getZ: function (t) {
        return this.data.array[t * this.data.stride + this.offset + 2];
      },
      getW: function (t) {
        return this.data.array[t * this.data.stride + this.offset + 3];
      },
      setXY: function (t, e, i) {
        return (
          (t = t * this.data.stride + this.offset),
          (this.data.array[t + 0] = e),
          (this.data.array[t + 1] = i),
          this
        );
      },
      setXYZ: function (t, e, i, n) {
        return (
          (t = t * this.data.stride + this.offset),
          (this.data.array[t + 0] = e),
          (this.data.array[t + 1] = i),
          (this.data.array[t + 2] = n),
          this
        );
      },
      setXYZW: function (t, e, i, n, r) {
        return (
          (t = t * this.data.stride + this.offset),
          (this.data.array[t + 0] = e),
          (this.data.array[t + 1] = i),
          (this.data.array[t + 2] = n),
          (this.data.array[t + 3] = r),
          this
        );
      },
    }),
    Object.defineProperty(sn.prototype, 'needsUpdate', {
      set: function (t) {
        !0 === t && this.version++;
      },
    }),
    Object.assign(sn.prototype, {
      isInterleavedBuffer: !0,
      setArray: function (t) {
        if (Array.isArray(t)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        ((this.count = void 0 !== t ? t.length / this.stride : 0), (this.array = t));
      },
      setDynamic: function (t) {
        return ((this.dynamic = t), this);
      },
      copy: function (t) {
        return (
          (this.array = new t.array.constructor(t.array)),
          (this.count = t.count),
          (this.stride = t.stride),
          (this.dynamic = t.dynamic),
          this
        );
      },
      copyAt: function (t, e, i) {
        ((t *= this.stride), (i *= e.stride));
        for (let n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
        return this;
      },
      set: function (t, e) {
        return (void 0 === e && (e = 0), this.array.set(t, e), this);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      onUpload: function (t) {
        return ((this.onUploadCallback = t), this);
      },
    }),
    (cn.prototype = Object.assign(Object.create(sn.prototype), {
      constructor: cn,
      isInstancedInterleavedBuffer: !0,
      copy: function (t) {
        return (sn.prototype.copy.call(this, t), (this.meshPerAttribute = t.meshPerAttribute), this);
      },
    })),
    (hn.prototype = Object.assign(Object.create(G.prototype), {
      constructor: hn,
      isInstancedBufferAttribute: !0,
      copy: function (t) {
        return (G.prototype.copy.call(this, t), (this.meshPerAttribute = t.meshPerAttribute), this);
      },
    })),
    Object.assign(ln.prototype, {
      linePrecision: 1,
      set: function (t, e) {
        this.ray.set(t, e);
      },
      setFromCamera: function (t, e) {
        e && e.isPerspectiveCamera
          ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
            this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize())
          : e && e.isOrthographicCamera
            ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
              this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld))
            : console.error('THREE.Raycaster: Unsupported camera type.');
      },
      intersectObject: function (t, e) {
        const i = [];
        return (pn(t, this, i, e), i.sort(un), i);
      },
      intersectObjects: function (t, e) {
        const i = [];
        if (!1 === Array.isArray(t))
          return (console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.'), i);
        for (let n = 0, r = t.length; n < r; n++) pn(t[n], this, i, e);
        return (i.sort(un), i);
      },
    }),
    Object.assign(dn.prototype, {
      start: function () {
        ((this.startTime = ('undefined' == typeof performance ? Date : performance).now()),
          (this.oldTime = this.startTime),
          (this.elapsedTime = 0),
          (this.running = !0));
      },
      stop: function () {
        (this.getElapsedTime(), (this.running = !1), (this.autoStart = !1));
      },
      getElapsedTime: function () {
        return (this.getDelta(), this.elapsedTime);
      },
      getDelta: function () {
        let t = 0;
        if (this.autoStart && !this.running) return (this.start(), 0);
        if (this.running) {
          const e = ('undefined' == typeof performance ? Date : performance).now();
          ((t = (e - this.oldTime) / 1e3), (this.oldTime = e), (this.elapsedTime += t));
        }
        return t;
      },
    }),
    Object.assign(fn.prototype, {
      set: function (t, e, i) {
        return ((this.radius = t), (this.phi = e), (this.theta = i), this);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return ((this.radius = t.radius), (this.phi = t.phi), (this.theta = t.theta), this);
      },
      makeSafe: function () {
        return ((this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this);
      },
      setFromVector3: function (t) {
        return (
          (this.radius = t.length()),
          0 === this.radius
            ? ((this.theta = 0), (this.phi = 0))
            : ((this.theta = Math.atan2(t.x, t.z)), (this.phi = Math.acos(Wa.clamp(t.y / this.radius, -1, 1)))),
          this
        );
      },
    }),
    Object.assign(mn.prototype, {
      set: function (t, e, i) {
        return ((this.radius = t), (this.theta = e), (this.y = i), this);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return ((this.radius = t.radius), (this.theta = t.theta), (this.y = t.y), this);
      },
      setFromVector3: function (t) {
        return (
          (this.radius = Math.sqrt(t.x * t.x + t.z * t.z)),
          (this.theta = Math.atan2(t.x, t.z)),
          (this.y = t.y),
          this
        );
      },
    }),
    ((vn.prototype = Object.create(U.prototype)).constructor = vn),
    (vn.prototype.isImmediateRenderObject = !0),
    ((gn.prototype = Object.create(Dt.prototype)).constructor = gn),
    (gn.prototype.update = (function () {
      const t = new a(),
        e = new a(),
        i = new o();
      return function () {
        const n = ['a', 'b', 'c'];
        (this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld));
        const r = this.object.matrixWorld,
          a = this.geometry.attributes.position,
          o = this.object.geometry;
        if (o && o.isGeometry)
          for (var s = o.vertices, c = o.faces, h = 0, l = 0, u = c.length; l < u; l++)
            for (var p = c[l], d = 0, f = p.vertexNormals.length; d < f; d++) {
              const m = s[p[n[d]]],
                v = p.vertexNormals[d];
              (t.copy(m).applyMatrix4(r),
                e.copy(v).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t),
                a.setXYZ(h, t.x, t.y, t.z),
                (h += 1),
                a.setXYZ(h, e.x, e.y, e.z),
                (h += 1));
            }
        else if (o && o.isBufferGeometry)
          for (var g = o.attributes.position, y = o.attributes.normal, h = 0, d = 0, f = g.count; d < f; d++)
            (t.set(g.getX(d), g.getY(d), g.getZ(d)).applyMatrix4(r),
              e.set(y.getX(d), y.getY(d), y.getZ(d)),
              e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t),
              a.setXYZ(h, t.x, t.y, t.z),
              (h += 1),
              a.setXYZ(h, e.x, e.y, e.z),
              (h += 1));
        a.needsUpdate = !0;
      };
    })()),
    ((yn.prototype = Object.create(U.prototype)).constructor = yn),
    (yn.prototype.dispose = function () {
      (this.cone.geometry.dispose(), this.cone.material.dispose());
    }),
    (yn.prototype.update = (function () {
      const t = new a(),
        e = new a();
      return function () {
        this.light.updateMatrixWorld();
        const i = this.light.distance ? this.light.distance : 1e3,
          n = i * Math.tan(this.light.angle);
        (this.cone.scale.set(n, n, i),
          t.setFromMatrixPosition(this.light.matrixWorld),
          e.setFromMatrixPosition(this.light.target.matrixWorld),
          this.cone.lookAt(e.sub(t)),
          void 0 !== this.color
            ? this.cone.material.color.set(this.color)
            : this.cone.material.color.copy(this.light.color));
      };
    })()),
    ((bn.prototype = Object.create(Dt.prototype)).constructor = bn),
    (bn.prototype.updateMatrixWorld = (function () {
      const t = new a(),
        e = new n(),
        i = new n();
      return function (n) {
        const r = this.bones,
          a = this.geometry,
          o = a.getAttribute('position');
        i.getInverse(this.root.matrixWorld);
        for (let s = 0, c = 0; s < r.length; s++) {
          const h = r[s];
          h.parent &&
            h.parent.isBone &&
            (e.multiplyMatrices(i, h.matrixWorld),
            t.setFromMatrixPosition(e),
            o.setXYZ(c, t.x, t.y, t.z),
            e.multiplyMatrices(i, h.parent.matrixWorld),
            t.setFromMatrixPosition(e),
            o.setXYZ(c + 1, t.x, t.y, t.z),
            (c += 2));
        }
        ((a.getAttribute('position').needsUpdate = !0), U.prototype.updateMatrixWorld.call(this, n));
      };
    })()),
    ((_n.prototype = Object.create(ct.prototype)).constructor = _n),
    (_n.prototype.dispose = function () {
      (this.geometry.dispose(), this.material.dispose());
    }),
    (_n.prototype.update = function () {
      void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
    }),
    ((wn.prototype = Object.create(U.prototype)).constructor = wn),
    (wn.prototype.dispose = function () {
      (this.children[0].geometry.dispose(), this.children[0].material.dispose());
    }),
    (wn.prototype.update = function () {
      const t = 0.5 * this.light.width,
        e = 0.5 * this.light.height,
        i = this.line.geometry.attributes.position,
        n = i.array;
      ((n[0] = t),
        (n[1] = -e),
        (n[2] = 0),
        (n[3] = t),
        (n[4] = e),
        (n[5] = 0),
        (n[6] = -t),
        (n[7] = e),
        (n[8] = 0),
        (n[9] = -t),
        (n[10] = -e),
        (n[11] = 0),
        (n[12] = t),
        (n[13] = -e),
        (n[14] = 0),
        (i.needsUpdate = !0),
        void 0 !== this.color
          ? this.line.material.color.set(this.color)
          : this.line.material.color.copy(this.light.color));
    }),
    ((En.prototype = Object.create(U.prototype)).constructor = En),
    (En.prototype.dispose = function () {
      (this.children[0].geometry.dispose(), this.children[0].material.dispose());
    }),
    (En.prototype.update = (function () {
      const t = new a(),
        e = new w(),
        i = new w();
      return function () {
        const n = this.children[0];
        if (void 0 !== this.color) this.material.color.set(this.color);
        else {
          const r = n.geometry.getAttribute('color');
          (e.copy(this.light.color), i.copy(this.light.groundColor));
          for (let a = 0, o = r.count; a < o; a++) {
            const s = a < o / 2 ? e : i;
            r.setXYZ(a, s.r, s.g, s.b);
          }
          r.needsUpdate = !0;
        }
        n.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate());
      };
    })()),
    ((Mn.prototype = Object.create(Dt.prototype)).constructor = Mn),
    ((Tn.prototype = Object.create(Dt.prototype)).constructor = Tn),
    ((Sn.prototype = Object.create(Dt.prototype)).constructor = Sn),
    (Sn.prototype.update = (function () {
      const t = new a(),
        e = new a(),
        i = new o();
      return function () {
        (this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld));
        for (
          var n = this.object.matrixWorld,
            r = this.geometry.attributes.position,
            a = this.object.geometry,
            o = a.vertices,
            s = a.faces,
            c = 0,
            h = 0,
            l = s.length;
          h < l;
          h++
        ) {
          const u = s[h],
            p = u.normal;
          (t.copy(o[u.a]).add(o[u.b]).add(o[u.c]).divideScalar(3).applyMatrix4(n),
            e.copy(p).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t),
            r.setXYZ(c, t.x, t.y, t.z),
            (c += 1),
            r.setXYZ(c, e.x, e.y, e.z),
            (c += 1));
        }
        r.needsUpdate = !0;
      };
    })()),
    ((An.prototype = Object.create(U.prototype)).constructor = An),
    (An.prototype.dispose = function () {
      (this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose());
    }),
    (An.prototype.update = (function () {
      const t = new a(),
        e = new a(),
        i = new a();
      return function () {
        (t.setFromMatrixPosition(this.light.matrixWorld),
          e.setFromMatrixPosition(this.light.target.matrixWorld),
          i.subVectors(e, t),
          this.lightPlane.lookAt(i),
          void 0 !== this.color
            ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color))
            : (this.lightPlane.material.color.copy(this.light.color),
              this.targetLine.material.color.copy(this.light.color)),
          this.targetLine.lookAt(i),
          (this.targetLine.scale.z = i.length()));
      };
    })()),
    ((Rn.prototype = Object.create(Dt.prototype)).constructor = Rn),
    (Rn.prototype.update = (function () {
      function t(t, a, o, s) {
        n.set(a, o, s).unproject(r);
        const c = i[t];
        if (void 0 !== c)
          for (let h = e.getAttribute('position'), l = 0, u = c.length; l < u; l++) h.setXYZ(c[l], n.x, n.y, n.z);
      }
      var e,
        i,
        n = new a(),
        r = new N();
      return function () {
        ((e = this.geometry), (i = this.pointMap));
        (r.projectionMatrix.copy(this.camera.projectionMatrix),
          t('c', 0, 0, -1),
          t('t', 0, 0, 1),
          t('n1', -1, -1, -1),
          t('n2', 1, -1, -1),
          t('n3', -1, 1, -1),
          t('n4', 1, 1, -1),
          t('f1', -1, -1, 1),
          t('f2', 1, -1, 1),
          t('f3', -1, 1, 1),
          t('f4', 1, 1, 1),
          t('u1', 0.7, 1.1, -1),
          t('u2', -0.7, 1.1, -1),
          t('u3', 0, 2, -1),
          t('cf1', -1, 0, 1),
          t('cf2', 1, 0, 1),
          t('cf3', 0, -1, 1),
          t('cf4', 0, 1, 1),
          t('cn1', -1, 0, -1),
          t('cn2', 1, 0, -1),
          t('cn3', 0, -1, -1),
          t('cn4', 0, 1, -1),
          (e.getAttribute('position').needsUpdate = !0));
      };
    })()),
    ((Ln.prototype = Object.create(Dt.prototype)).constructor = Ln),
    (Ln.prototype.update = (function () {
      const t = new R();
      return function (e) {
        if (
          (void 0 !== e && console.warn('THREE.BoxHelper: .update() has no longer arguments.'),
          void 0 !== this.object && t.setFromObject(this.object),
          !t.isEmpty())
        ) {
          const i = t.min,
            n = t.max,
            r = this.geometry.attributes.position,
            a = r.array;
          ((a[0] = n.x),
            (a[1] = n.y),
            (a[2] = n.z),
            (a[3] = i.x),
            (a[4] = n.y),
            (a[5] = n.z),
            (a[6] = i.x),
            (a[7] = i.y),
            (a[8] = n.z),
            (a[9] = n.x),
            (a[10] = i.y),
            (a[11] = n.z),
            (a[12] = n.x),
            (a[13] = n.y),
            (a[14] = i.z),
            (a[15] = i.x),
            (a[16] = n.y),
            (a[17] = i.z),
            (a[18] = i.x),
            (a[19] = i.y),
            (a[20] = i.z),
            (a[21] = n.x),
            (a[22] = i.y),
            (a[23] = i.z),
            (r.needsUpdate = !0),
            this.geometry.computeBoundingSphere());
        }
      };
    })()),
    (Ln.prototype.setFromObject = function (t) {
      return ((this.object = t), this.update(), this);
    }),
    ((Pn.prototype = Object.create(Dt.prototype)).constructor = Pn),
    (Pn.prototype.updateMatrixWorld = function (t) {
      const e = this.box;
      e.isEmpty() ||
        (e.getCenter(this.position),
        e.getSize(this.scale),
        this.scale.multiplyScalar(0.5),
        U.prototype.updateMatrixWorld.call(this, t));
    }),
    ((Cn.prototype = Object.create(It.prototype)).constructor = Cn),
    (Cn.prototype.updateMatrixWorld = function (t) {
      let e = -this.plane.constant;
      (Math.abs(e) < 1e-8 && (e = 1e-8),
        this.scale.set(0.5 * this.size, 0.5 * this.size, e),
        this.lookAt(this.plane.normal),
        U.prototype.updateMatrixWorld.call(this, t));
    }));
  let To, So;
  (((In.prototype = Object.create(U.prototype)).constructor = In),
    (In.prototype.setDirection = (function () {
      let t,
        e = new a();
      return function (i) {
        i.y > 0.99999
          ? this.quaternion.set(0, 0, 0, 1)
          : i.y < -0.99999
            ? this.quaternion.set(1, 0, 0, 0)
            : (e.set(i.z, 0, -i.x).normalize(), (t = Math.acos(i.y)), this.quaternion.setFromAxisAngle(e, t));
      };
    })()),
    (In.prototype.setLength = function (t, e, i) {
      (void 0 === e && (e = 0.2 * t),
        void 0 === i && (i = 0.2 * e),
        this.line.scale.set(1, Math.max(0, t - e), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(i, e, i),
        (this.cone.position.y = t),
        this.cone.updateMatrix());
    }),
    (In.prototype.setColor = function (t) {
      (this.line.material.color.copy(t), this.cone.material.color.copy(t));
    }),
    ((Dn.prototype = Object.create(Dt.prototype)).constructor = Dn));
  const Ao = new a(),
    Ro = new On(),
    Lo = new On(),
    Po = new On();
  (((Un.prototype = Object.create(Ii.prototype)).constructor = Un),
    (Un.prototype.isCatmullRomCurve3 = !0),
    (Un.prototype.getPoint = function (t, e) {
      let i = e || new a(),
        n = this.points,
        r = n.length,
        o = (r - (this.closed ? 0 : 1)) * t,
        s = Math.floor(o),
        c = o - s;
      this.closed
        ? (s += s > 0 ? 0 : (Math.floor(Math.abs(s) / n.length) + 1) * n.length)
        : 0 === c && s === r - 1 && ((s = r - 2), (c = 1));
      let h, l, u, p;
      if (
        (this.closed || s > 0 ? (h = n[(s - 1) % r]) : (Ao.subVectors(n[0], n[1]).add(n[0]), (h = Ao)),
        (l = n[s % r]),
        (u = n[(s + 1) % r]),
        this.closed || s + 2 < r ? (p = n[(s + 2) % r]) : (Ao.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), (p = Ao)),
        'centripetal' === this.curveType || 'chordal' === this.curveType)
      ) {
        let d = 'chordal' === this.curveType ? 0.5 : 0.25,
          f = Math.pow(h.distanceToSquared(l), d),
          m = Math.pow(l.distanceToSquared(u), d),
          v = Math.pow(u.distanceToSquared(p), d);
        (m < 1e-4 && (m = 1),
          f < 1e-4 && (f = m),
          v < 1e-4 && (v = m),
          Ro.initNonuniformCatmullRom(h.x, l.x, u.x, p.x, f, m, v),
          Lo.initNonuniformCatmullRom(h.y, l.y, u.y, p.y, f, m, v),
          Po.initNonuniformCatmullRom(h.z, l.z, u.z, p.z, f, m, v));
      } else
        'catmullrom' === this.curveType &&
          (Ro.initCatmullRom(h.x, l.x, u.x, p.x, this.tension),
          Lo.initCatmullRom(h.y, l.y, u.y, p.y, this.tension),
          Po.initCatmullRom(h.z, l.z, u.z, p.z, this.tension));
      return (i.set(Ro.calc(c), Lo.calc(c), Po.calc(c)), i);
    }),
    (Un.prototype.copy = function (t) {
      (Ii.prototype.copy.call(this, t), (this.points = []));
      for (let e = 0, i = t.points.length; e < i; e++) {
        const n = t.points[e];
        this.points.push(n.clone());
      }
      return ((this.closed = t.closed), (this.curveType = t.curveType), (this.tension = t.tension), this);
    }),
    ((Nn.prototype = Object.create(Ii.prototype)).constructor = Nn),
    (Nn.prototype.isCubicBezierCurve3 = !0),
    (Nn.prototype.getPoint = function (t, e) {
      const i = e || new a(),
        n = this.v0,
        r = this.v1,
        o = this.v2,
        s = this.v3;
      return (i.set(Ci(t, n.x, r.x, o.x, s.x), Ci(t, n.y, r.y, o.y, s.y), Ci(t, n.z, r.z, o.z, s.z)), i);
    }),
    (Nn.prototype.copy = function (t) {
      return (
        Ii.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
      );
    }),
    ((Bn.prototype = Object.create(Ii.prototype)).constructor = Bn),
    (Bn.prototype.isQuadraticBezierCurve3 = !0),
    (Bn.prototype.getPoint = function (t, e) {
      const i = e || new a(),
        n = this.v0,
        r = this.v1,
        o = this.v2;
      return (i.set(Pi(t, n.x, r.x, o.x), Pi(t, n.y, r.y, o.y), Pi(t, n.z, r.z, o.z)), i);
    }),
    (Bn.prototype.copy = function (t) {
      return (Ii.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this);
    }),
    ((Fn.prototype = Object.create(Ii.prototype)).constructor = Fn),
    (Fn.prototype.isLineCurve3 = !0),
    (Fn.prototype.getPoint = function (t, e) {
      const i = e || new a();
      return (1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i);
    }),
    (Fn.prototype.getPointAt = function (t, e) {
      return this.getPoint(t, e);
    }),
    (Fn.prototype.copy = function (t) {
      return (Ii.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this);
    }),
    ((zn.prototype = Object.create(Ui.prototype)).constructor = zn),
    (zn.prototype.isArcCurve = !0));
  const Co = {
    createMultiMaterialObject: function (t, e) {
      for (var i = new Bt(), n = 0, r = e.length; n < r; n++) i.add(new ct(t, e[n]));
      return i;
    },
    detach: function (t, e, i) {
      (t.applyMatrix(e.matrixWorld), e.remove(t), i.add(t));
    },
    attach: function (t, e, i) {
      (t.applyMatrix(new n().getInverse(i.matrixWorld)), e.remove(t), i.add(t));
    },
  };
  ((Ii.create = function (t, e) {
    return (
      console.log('THREE.Curve.create() has been deprecated'),
      (t.prototype = Object.create(Ii.prototype)),
      (t.prototype.constructor = t),
      (t.prototype.getPoint = e),
      t
    );
  }),
    Object.assign(Oi.prototype, {
      createPointsGeometry: function (t) {
        console.warn(
          'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.'
        );
        const e = this.getPoints(t);
        return this.createGeometry(e);
      },
      createSpacedPointsGeometry: function (t) {
        console.warn(
          'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.'
        );
        const e = this.getSpacedPoints(t);
        return this.createGeometry(e);
      },
      createGeometry: function (t) {
        console.warn(
          'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.'
        );
        for (var e = new z(), i = 0, n = t.length; i < n; i++) {
          const r = t[i];
          e.vertices.push(new a(r.x, r.y, r.z || 0));
        }
        return e;
      },
    }),
    Object.assign(zi.prototype, {
      fromPoints: function (t) {
        (console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().'), this.setFromPoints(t));
      },
    }),
    (Gn.prototype = Object.create(Un.prototype)),
    (Hn.prototype = Object.create(Un.prototype)),
    (Vn.prototype = Object.create(Un.prototype)),
    Object.assign(Vn.prototype, {
      initFromArray: function () {
        console.error('THREE.Spline: .initFromArray() has been removed.');
      },
      getControlPointsArray: function () {
        console.error('THREE.Spline: .getControlPointsArray() has been removed.');
      },
      reparametrizeByArcLength: function () {
        console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
      },
    }),
    (Mn.prototype.setColors = function () {
      console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
    }),
    (bn.prototype.update = function () {
      console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
    }),
    Object.assign(E.prototype, {
      center: function (t) {
        return (console.warn('THREE.Box2: .center() has been renamed to .getCenter().'), this.getCenter(t));
      },
      empty: function () {
        return (console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().'), this.isEmpty());
      },
      isIntersectionBox: function (t) {
        return (
          console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().'),
          this.intersectsBox(t)
        );
      },
      size: function (t) {
        return (console.warn('THREE.Box2: .size() has been renamed to .getSize().'), this.getSize(t));
      },
    }),
    Object.assign(R.prototype, {
      center: function (t) {
        return (console.warn('THREE.Box3: .center() has been renamed to .getCenter().'), this.getCenter(t));
      },
      empty: function () {
        return (console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().'), this.isEmpty());
      },
      isIntersectionBox: function (t) {
        return (
          console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().'),
          this.intersectsBox(t)
        );
      },
      isIntersectionSphere: function (t) {
        return (
          console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().'),
          this.intersectsSphere(t)
        );
      },
      size: function (t) {
        return (console.warn('THREE.Box3: .size() has been renamed to .getSize().'), this.getSize(t));
      },
    }),
    (ot.prototype.center = function (t) {
      return (console.warn('THREE.Line3: .center() has been renamed to .getCenter().'), this.getCenter(t));
    }),
    Object.assign(Wa, {
      random16: function () {
        return (console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.'), Math.random());
      },
      nearestPowerOfTwo: function (t) {
        return (
          console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().'),
          Wa.floorPowerOfTwo(t)
        );
      },
      nextPowerOfTwo: function (t) {
        return (
          console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().'),
          Wa.ceilPowerOfTwo(t)
        );
      },
    }),
    Object.assign(o.prototype, {
      flattenToArrayOffset: function (t, e) {
        return (
          console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.'),
          this.toArray(t, e)
        );
      },
      multiplyVector3: function (t) {
        return (
          console.warn(
            'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.'
          ),
          t.applyMatrix3(this)
        );
      },
      multiplyVector3Array: function () {
        console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
      },
      applyToBuffer: function (t) {
        return (
          console.warn(
            'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.'
          ),
          this.applyToBufferAttribute(t)
        );
      },
      applyToVector3Array: function () {
        console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
      },
    }),
    Object.assign(n.prototype, {
      extractPosition: function (t) {
        return (
          console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().'),
          this.copyPosition(t)
        );
      },
      flattenToArrayOffset: function (t, e) {
        return (
          console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.'),
          this.toArray(t, e)
        );
      },
      getPosition: (function () {
        let t;
        return function () {
          return (
            void 0 === t && (t = new a()),
            console.warn(
              'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.'
            ),
            t.setFromMatrixColumn(this, 3)
          );
        };
      })(),
      setRotationFromQuaternion: function (t) {
        return (
          console.warn(
            'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().'
          ),
          this.makeRotationFromQuaternion(t)
        );
      },
      multiplyToArray: function () {
        console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
      },
      multiplyVector3: function (t) {
        return (
          console.warn(
            'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.'
          ),
          t.applyMatrix4(this)
        );
      },
      multiplyVector4: function (t) {
        return (
          console.warn(
            'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.'
          ),
          t.applyMatrix4(this)
        );
      },
      multiplyVector3Array: function () {
        console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
      },
      rotateAxis: function (t) {
        (console.warn(
          'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.'
        ),
          t.transformDirection(this));
      },
      crossVector: function (t) {
        return (
          console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.'),
          t.applyMatrix4(this)
        );
      },
      translate: function () {
        console.error('THREE.Matrix4: .translate() has been removed.');
      },
      rotateX: function () {
        console.error('THREE.Matrix4: .rotateX() has been removed.');
      },
      rotateY: function () {
        console.error('THREE.Matrix4: .rotateY() has been removed.');
      },
      rotateZ: function () {
        console.error('THREE.Matrix4: .rotateZ() has been removed.');
      },
      rotateByAxis: function () {
        console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
      },
      applyToBuffer: function (t) {
        return (
          console.warn(
            'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.'
          ),
          this.applyToBufferAttribute(t)
        );
      },
      applyToVector3Array: function () {
        console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
      },
      makeFrustum: function (t, e, i, n, r, a) {
        return (
          console.warn(
            'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.'
          ),
          this.makePerspective(t, e, n, i, r, a)
        );
      },
    }),
    (P.prototype.isIntersectionLine = function (t) {
      return (
        console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().'),
        this.intersectsLine(t)
      );
    }),
    (r.prototype.multiplyVector3 = function (t) {
      return (
        console.warn(
          'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.'
        ),
        t.applyQuaternion(this)
      );
    }),
    Object.assign(at.prototype, {
      isIntersectionBox: function (t) {
        return (
          console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().'),
          this.intersectsBox(t)
        );
      },
      isIntersectionPlane: function (t) {
        return (
          console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().'),
          this.intersectsPlane(t)
        );
      },
      isIntersectionSphere: function (t) {
        return (
          console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().'),
          this.intersectsSphere(t)
        );
      },
    }),
    Object.assign(Gi.prototype, {
      extractAllPoints: function (t) {
        return (
          console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.'),
          this.extractPoints(t)
        );
      },
      extrude: function (t) {
        return (
          console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.'),
          new xe(this, t)
        );
      },
      makeGeometry: function (t) {
        return (
          console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.'),
          new Le(this, t)
        );
      },
    }),
    Object.assign(i.prototype, {
      fromAttribute: function (t, e, i) {
        return (
          console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().'),
          this.fromBufferAttribute(t, e, i)
        );
      },
      distanceToManhattan: function (t) {
        return (
          console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().'),
          this.manhattanDistanceTo(t)
        );
      },
      lengthManhattan: function () {
        return (
          console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().'),
          this.manhattanLength()
        );
      },
    }),
    Object.assign(a.prototype, {
      setEulerFromRotationMatrix: function () {
        console.error(
          'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.'
        );
      },
      setEulerFromQuaternion: function () {
        console.error(
          'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.'
        );
      },
      getPositionFromMatrix: function (t) {
        return (
          console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().'),
          this.setFromMatrixPosition(t)
        );
      },
      getScaleFromMatrix: function (t) {
        return (
          console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().'),
          this.setFromMatrixScale(t)
        );
      },
      getColumnFromMatrix: function (t, e) {
        return (
          console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().'),
          this.setFromMatrixColumn(e, t)
        );
      },
      applyProjection: function (t) {
        return (
          console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.'),
          this.applyMatrix4(t)
        );
      },
      fromAttribute: function (t, e, i) {
        return (
          console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().'),
          this.fromBufferAttribute(t, e, i)
        );
      },
      distanceToManhattan: function (t) {
        return (
          console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().'),
          this.manhattanDistanceTo(t)
        );
      },
      lengthManhattan: function () {
        return (
          console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().'),
          this.manhattanLength()
        );
      },
    }),
    Object.assign(c.prototype, {
      fromAttribute: function (t, e, i) {
        return (
          console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().'),
          this.fromBufferAttribute(t, e, i)
        );
      },
      lengthManhattan: function () {
        return (
          console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().'),
          this.manhattanLength()
        );
      },
    }),
    (z.prototype.computeTangents = function () {
      console.warn('THREE.Geometry: .computeTangents() has been removed.');
    }),
    Object.assign(U.prototype, {
      getChildByName: function (t) {
        return (
          console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().'),
          this.getObjectByName(t)
        );
      },
      renderDepth: function () {
        console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
      },
      translate: function (t, e) {
        return (
          console.warn(
            'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.'
          ),
          this.translateOnAxis(e, t)
        );
      },
    }),
    Object.defineProperties(U.prototype, {
      eulerOrder: {
        get: function () {
          return (console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.'), this.rotation.order);
        },
        set: function (t) {
          (console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.'), (this.rotation.order = t));
        },
      },
      useQuaternion: {
        get: function () {
          console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
        },
        set: function () {
          console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
        },
      },
    }),
    Object.defineProperties(At.prototype, {
      objects: {
        get: function () {
          return (console.warn('THREE.LOD: .objects has been renamed to .levels.'), this.levels);
        },
      },
    }),
    Object.defineProperty(Rt.prototype, 'useVertexTexture', {
      get: function () {
        console.warn('THREE.Skeleton: useVertexTexture has been removed.');
      },
      set: function () {
        console.warn('THREE.Skeleton: useVertexTexture has been removed.');
      },
    }),
    Object.defineProperty(Ii.prototype, '__arcLengthDivisions', {
      get: function () {
        return (
          console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.'),
          this.arcLengthDivisions
        );
      },
      set: function (t) {
        (console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.'), (this.arcLengthDivisions = t));
      },
    }),
    (vt.prototype.setLens = function (t, e) {
      (console.warn(
        'THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.'
      ),
        void 0 !== e && (this.filmGauge = e),
        this.setFocalLength(t));
    }),
    Object.defineProperties(ti.prototype, {
      onlyShadow: {
        set: function () {
          console.warn('THREE.Light: .onlyShadow has been removed.');
        },
      },
      shadowCameraFov: {
        set: function (t) {
          (console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.'), (this.shadow.camera.fov = t));
        },
      },
      shadowCameraLeft: {
        set: function (t) {
          (console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.'), (this.shadow.camera.left = t));
        },
      },
      shadowCameraRight: {
        set: function (t) {
          (console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.'),
            (this.shadow.camera.right = t));
        },
      },
      shadowCameraTop: {
        set: function (t) {
          (console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.'), (this.shadow.camera.top = t));
        },
      },
      shadowCameraBottom: {
        set: function (t) {
          (console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.'),
            (this.shadow.camera.bottom = t));
        },
      },
      shadowCameraNear: {
        set: function (t) {
          (console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.'), (this.shadow.camera.near = t));
        },
      },
      shadowCameraFar: {
        set: function (t) {
          (console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.'), (this.shadow.camera.far = t));
        },
      },
      shadowCameraVisible: {
        set: function () {
          console.warn(
            'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.'
          );
        },
      },
      shadowBias: {
        set: function (t) {
          (console.warn('THREE.Light: .shadowBias is now .shadow.bias.'), (this.shadow.bias = t));
        },
      },
      shadowDarkness: {
        set: function () {
          console.warn('THREE.Light: .shadowDarkness has been removed.');
        },
      },
      shadowMapWidth: {
        set: function (t) {
          (console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.'), (this.shadow.mapSize.width = t));
        },
      },
      shadowMapHeight: {
        set: function (t) {
          (console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.'),
            (this.shadow.mapSize.height = t));
        },
      },
    }),
    Object.defineProperties(G.prototype, {
      length: {
        get: function () {
          return (
            console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.'),
            this.array.length
          );
        },
      },
    }),
    Object.assign(K.prototype, {
      addIndex: function (t) {
        (console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().'), this.setIndex(t));
      },
      addDrawCall: function (t, e, i) {
        (void 0 !== i && console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.'),
          console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().'),
          this.addGroup(t, e));
      },
      clearDrawCalls: function () {
        (console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().'), this.clearGroups());
      },
      computeTangents: function () {
        console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
      },
      computeOffsets: function () {
        console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
      },
    }),
    Object.defineProperties(K.prototype, {
      drawcalls: {
        get: function () {
          return (console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.'), this.groups);
        },
      },
      offsets: {
        get: function () {
          return (console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.'), this.groups);
        },
      },
    }),
    Object.defineProperties(rn.prototype, {
      dynamic: {
        set: function () {
          console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
        },
      },
      onUpdate: {
        value: function () {
          return (
            console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.'),
            this
          );
        },
      },
    }),
    Object.defineProperties(T.prototype, {
      wrapAround: {
        get: function () {
          console.warn('THREE.Material: .wrapAround has been removed.');
        },
        set: function () {
          console.warn('THREE.Material: .wrapAround has been removed.');
        },
      },
      wrapRGB: {
        get: function () {
          return (console.warn('THREE.Material: .wrapRGB has been removed.'), new w());
        },
      },
      shading: {
        get: function () {
          console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
        },
        set: function (t) {
          (console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.'),
            (this.flatShading = 1 === t));
        },
      },
    }),
    Object.defineProperties(Ve.prototype, {
      metal: {
        get: function () {
          return (
            console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.'),
            !1
          );
        },
        set: function () {
          console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
        },
      },
    }),
    Object.defineProperties(rt.prototype, {
      derivatives: {
        get: function () {
          return (
            console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.'),
            this.extensions.derivatives
          );
        },
        set: function (t) {
          (console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.'),
            (this.extensions.derivatives = t));
        },
      },
    }),
    Object.assign(bt.prototype, {
      getCurrentRenderTarget: function () {
        return (
          console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().'),
          this.getRenderTarget()
        );
      },
      getMaxAnisotropy: function () {
        return (
          console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().'),
          this.capabilities.getMaxAnisotropy()
        );
      },
      getPrecision: function () {
        return (
          console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.'),
          this.capabilities.precision
        );
      },
      resetGLState: function () {
        return (console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().'), this.state.reset());
      },
      supportsFloatTextures: function () {
        return (
          console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
          this.extensions.get('OES_texture_float')
        );
      },
      supportsHalfFloatTextures: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
          ),
          this.extensions.get('OES_texture_half_float')
        );
      },
      supportsStandardDerivatives: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
          ),
          this.extensions.get('OES_standard_derivatives')
        );
      },
      supportsCompressedTextureS3TC: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
          ),
          this.extensions.get('WEBGL_compressed_texture_s3tc')
        );
      },
      supportsCompressedTexturePVRTC: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
          ),
          this.extensions.get('WEBGL_compressed_texture_pvrtc')
        );
      },
      supportsBlendMinMax: function () {
        return (
          console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
          this.extensions.get('EXT_blend_minmax')
        );
      },
      supportsVertexTextures: function () {
        return (
          console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.'),
          this.capabilities.vertexTextures
        );
      },
      supportsInstancedArrays: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
          ),
          this.extensions.get('ANGLE_instanced_arrays')
        );
      },
      enableScissorTest: function (t) {
        (console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().'), this.setScissorTest(t));
      },
      initMaterial: function () {
        console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
      },
      addPrePlugin: function () {
        console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
      },
      addPostPlugin: function () {
        console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
      },
      updateShadowMap: function () {
        console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
      },
    }),
    Object.defineProperties(bt.prototype, {
      shadowMapEnabled: {
        get: function () {
          return this.shadowMap.enabled;
        },
        set: function (t) {
          (console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.'),
            (this.shadowMap.enabled = t));
        },
      },
      shadowMapType: {
        get: function () {
          return this.shadowMap.type;
        },
        set: function (t) {
          (console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.'), (this.shadowMap.type = t));
        },
      },
      shadowMapCullFace: {
        get: function () {
          return this.shadowMap.cullFace;
        },
        set: function (t) {
          (console.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.'),
            (this.shadowMap.cullFace = t));
        },
      },
    }),
    Object.defineProperties(I.prototype, {
      cullFace: {
        get: function () {
          return this.renderReverseSided ? Xn : Wn;
        },
        set: function (t) {
          const e = t !== Wn;
          (console.warn(
            'WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to ' + e + '.'
          ),
            (this.renderReverseSided = e));
        },
      },
    }),
    Object.defineProperties(h.prototype, {
      wrapS: {
        get: function () {
          return (console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.'), this.texture.wrapS);
        },
        set: function (t) {
          (console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.'), (this.texture.wrapS = t));
        },
      },
      wrapT: {
        get: function () {
          return (console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.'), this.texture.wrapT);
        },
        set: function (t) {
          (console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.'), (this.texture.wrapT = t));
        },
      },
      magFilter: {
        get: function () {
          return (
            console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.'),
            this.texture.magFilter
          );
        },
        set: function (t) {
          (console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.'),
            (this.texture.magFilter = t));
        },
      },
      minFilter: {
        get: function () {
          return (
            console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.'),
            this.texture.minFilter
          );
        },
        set: function (t) {
          (console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.'),
            (this.texture.minFilter = t));
        },
      },
      anisotropy: {
        get: function () {
          return (
            console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.'),
            this.texture.anisotropy
          );
        },
        set: function (t) {
          (console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.'),
            (this.texture.anisotropy = t));
        },
      },
      offset: {
        get: function () {
          return (console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.'), this.texture.offset);
        },
        set: function (t) {
          (console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.'), (this.texture.offset = t));
        },
      },
      repeat: {
        get: function () {
          return (console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.'), this.texture.repeat);
        },
        set: function (t) {
          (console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.'), (this.texture.repeat = t));
        },
      },
      format: {
        get: function () {
          return (console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.'), this.texture.format);
        },
        set: function (t) {
          (console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.'), (this.texture.format = t));
        },
      },
      type: {
        get: function () {
          return (console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.'), this.texture.type);
        },
        set: function (t) {
          (console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.'), (this.texture.type = t));
        },
      },
      generateMipmaps: {
        get: function () {
          return (
            console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.'),
            this.texture.generateMipmaps
          );
        },
        set: function (t) {
          (console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.'),
            (this.texture.generateMipmaps = t));
        },
      },
    }),
    Object.assign(yt.prototype, {
      getStandingMatrix: function () {
        console.warn('THREE.WebVRManager: .getStandingMatrix() has been removed.');
      },
    }),
    Object.defineProperties(yt.prototype, {
      standing: {
        set: function (t) {
          console.warn('THREE.WebVRManager: .standing has been removed.');
        },
      },
    }),
    (Yi.prototype.load = function (t) {
      console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
      const e = this;
      return (
        new ji().load(t, function (t) {
          e.setBuffer(t);
        }),
        this
      );
    }),
    (Qi.prototype.getData = function () {
      return (console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().'), this.getFrequencyData());
    }),
    (Xi.prototype.updateCubeMap = function (t, e) {
      return (console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().'), this.update(t, e));
    }));
  const Io = {
      merge: function (t, e, i) {
        console.warn(
          'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.'
        );
        let n;
        (e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), (n = e.matrix), (e = e.geometry)), t.merge(e, n, i));
      },
      center: function (t) {
        return (
          console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.'),
          t.center()
        );
      },
    },
    Do = {
      crossOrigin: void 0,
      loadTexture: function (t, e, i, n) {
        console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
        const r = new $e();
        r.setCrossOrigin(this.crossOrigin);
        const a = r.load(t, i, void 0, n);
        return (e && (a.mapping = e), a);
      },
      loadTextureCube: function (t, e, i, n) {
        console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
        const r = new Ke();
        r.setCrossOrigin(this.crossOrigin);
        const a = r.load(t, i, void 0, n);
        return (e && (a.mapping = e), a);
      },
      loadCompressedTexture: function () {
        console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
      },
      loadCompressedTextureCube: function () {
        console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
      },
    };
  ((t.WebGLRenderTargetCube = l),
    (t.WebGLRenderTarget = h),
    (t.WebGLRenderer = bt),
    (t.ShaderLib = ro),
    (t.UniformsLib = eo),
    (t.UniformsUtils = io),
    (t.ShaderChunk = no),
    (t.FogExp2 = _t),
    (t.Fog = wt),
    (t.Scene = Et),
    (t.LensFlare = Mt),
    (t.Sprite = St),
    (t.LOD = At),
    (t.SkinnedMesh = Pt),
    (t.Skeleton = Rt),
    (t.Bone = Lt),
    (t.Mesh = ct),
    (t.LineSegments = Dt),
    (t.LineLoop = Ot),
    (t.Line = It),
    (t.Points = Nt),
    (t.Group = Bt),
    (t.VideoTexture = Ft),
    (t.DataTexture = u),
    (t.CompressedTexture = zt),
    (t.CubeTexture = p),
    (t.CanvasTexture = M),
    (t.DepthTexture = Gt),
    (t.Texture = s),
    (t.CompressedTextureLoader = Ze),
    (t.DataTextureLoader = Qe),
    (t.CubeTextureLoader = Ke),
    (t.TextureLoader = $e),
    (t.ObjectLoader = Ai),
    (t.MaterialLoader = Ei),
    (t.BufferGeometryLoader = Mi),
    (t.DefaultLoadingManager = vo),
    (t.LoadingManager = qe),
    (t.JSONLoader = Si),
    (t.ImageLoader = Je),
    (t.ImageBitmapLoader = Ri),
    (t.FontLoader = ki),
    (t.FileLoader = Ye),
    (t.Loader = Ti),
    (t.Cache = mo),
    (t.AudioLoader = ji),
    (t.SpotLightShadow = ni),
    (t.SpotLight = ri),
    (t.PointLight = ai),
    (t.RectAreaLight = hi),
    (t.HemisphereLight = ei),
    (t.DirectionalLightShadow = oi),
    (t.DirectionalLight = si),
    (t.AmbientLight = ci),
    (t.LightShadow = ii),
    (t.Light = ti),
    (t.StereoCamera = Wi),
    (t.PerspectiveCamera = vt),
    (t.OrthographicCamera = B),
    (t.CubeCamera = Xi),
    (t.ArrayCamera = gt),
    (t.Camera = N),
    (t.AudioListener = qi),
    (t.PositionalAudio = Zi),
    (t.AudioContext = Mo),
    (t.AudioAnalyser = Qi),
    (t.Audio = Yi),
    (t.VectorKeyframeTrack = _i),
    (t.StringKeyframeTrack = li),
    (t.QuaternionKeyframeTrack = fi),
    (t.NumberKeyframeTrack = vi),
    (t.ColorKeyframeTrack = mi),
    (t.BooleanKeyframeTrack = ui),
    (t.PropertyMixer = Ji),
    (t.PropertyBinding = $i),
    (t.KeyframeTrack = bi),
    (t.AnimationUtils = yo),
    (t.AnimationObjectGroup = tn),
    (t.AnimationMixer = nn),
    (t.AnimationClip = wi),
    (t.Uniform = rn),
    (t.InstancedBufferGeometry = an),
    (t.BufferGeometry = K),
    (t.Geometry = z),
    (t.InterleavedBufferAttribute = on),
    (t.InstancedInterleavedBuffer = cn),
    (t.InterleavedBuffer = sn),
    (t.InstancedBufferAttribute = hn),
    (t.Face3 = F),
    (t.Object3D = U),
    (t.Raycaster = ln),
    (t.Layers = O),
    (t.EventDispatcher = e),
    (t.Clock = dn),
    (t.QuaternionLinearInterpolant = di),
    (t.LinearInterpolant = yi),
    (t.DiscreteInterpolant = xi),
    (t.CubicInterpolant = gi),
    (t.Interpolant = pi),
    (t.Triangle = st),
    (t.Math = Wa),
    (t.Spherical = fn),
    (t.Cylindrical = mn),
    (t.Plane = P),
    (t.Frustum = C),
    (t.Sphere = L),
    (t.Ray = at),
    (t.Matrix4 = n),
    (t.Matrix3 = o),
    (t.Box3 = R),
    (t.Box2 = E),
    (t.Line3 = ot),
    (t.Euler = D),
    (t.Vector4 = c),
    (t.Vector3 = a),
    (t.Vector2 = i),
    (t.Quaternion = r),
    (t.Color = w),
    (t.ImmediateRenderObject = vn),
    (t.VertexNormalsHelper = gn),
    (t.SpotLightHelper = yn),
    (t.SkeletonHelper = bn),
    (t.PointLightHelper = _n),
    (t.RectAreaLightHelper = wn),
    (t.HemisphereLightHelper = En),
    (t.GridHelper = Mn),
    (t.PolarGridHelper = Tn),
    (t.FaceNormalsHelper = Sn),
    (t.DirectionalLightHelper = An),
    (t.CameraHelper = Rn),
    (t.BoxHelper = Ln),
    (t.Box3Helper = Pn),
    (t.PlaneHelper = Cn),
    (t.ArrowHelper = In),
    (t.AxesHelper = Dn),
    (t.CatmullRomCurve3 = Un),
    (t.CubicBezierCurve3 = Nn),
    (t.QuadraticBezierCurve3 = Bn),
    (t.LineCurve3 = Fn),
    (t.ArcCurve = zn),
    (t.EllipseCurve = Ui),
    (t.SplineCurve = Ni),
    (t.CubicBezierCurve = Bi),
    (t.QuadraticBezierCurve = Fi),
    (t.LineCurve = Di),
    (t.Shape = Gi),
    (t.Path = zi),
    (t.ShapePath = Hi),
    (t.Font = Vi),
    (t.CurvePath = Oi),
    (t.Curve = Ii),
    (t.ShapeUtils = uo),
    (t.SceneUtils = Co),
    (t.WebGLUtils = xt),
    (t.WireframeGeometry = Ht),
    (t.ParametricGeometry = Vt),
    (t.ParametricBufferGeometry = kt),
    (t.TetrahedronGeometry = Xt),
    (t.TetrahedronBufferGeometry = qt),
    (t.OctahedronGeometry = Yt),
    (t.OctahedronBufferGeometry = Zt),
    (t.IcosahedronGeometry = Qt),
    (t.IcosahedronBufferGeometry = Jt),
    (t.DodecahedronGeometry = Kt),
    (t.DodecahedronBufferGeometry = $t),
    (t.PolyhedronGeometry = jt),
    (t.PolyhedronBufferGeometry = Wt),
    (t.TubeGeometry = te),
    (t.TubeBufferGeometry = ee),
    (t.TorusKnotGeometry = ie),
    (t.TorusKnotBufferGeometry = ne),
    (t.TorusGeometry = re),
    (t.TorusBufferGeometry = ae),
    (t.TextGeometry = _e),
    (t.TextBufferGeometry = we),
    (t.SphereGeometry = Ee),
    (t.SphereBufferGeometry = Me),
    (t.RingGeometry = Te),
    (t.RingBufferGeometry = Se),
    (t.PlaneGeometry = et),
    (t.PlaneBufferGeometry = it),
    (t.LatheGeometry = Ae),
    (t.LatheBufferGeometry = Re),
    (t.ShapeGeometry = Le),
    (t.ShapeBufferGeometry = Pe),
    (t.ExtrudeGeometry = xe),
    (t.ExtrudeBufferGeometry = be),
    (t.EdgesGeometry = Ce),
    (t.ConeGeometry = Oe),
    (t.ConeBufferGeometry = Ue),
    (t.CylinderGeometry = Ie),
    (t.CylinderBufferGeometry = De),
    (t.CircleGeometry = Ne),
    (t.CircleBufferGeometry = Be),
    (t.BoxGeometry = $),
    (t.BoxBufferGeometry = tt),
    (t.ShadowMaterial = Fe),
    (t.SpriteMaterial = Tt),
    (t.RawShaderMaterial = ze),
    (t.ShaderMaterial = rt),
    (t.PointsMaterial = Ut),
    (t.MeshPhysicalMaterial = He),
    (t.MeshStandardMaterial = Ge),
    (t.MeshPhongMaterial = Ve),
    (t.MeshToonMaterial = ke),
    (t.MeshNormalMaterial = je),
    (t.MeshLambertMaterial = We),
    (t.MeshDepthMaterial = S),
    (t.MeshDistanceMaterial = A),
    (t.MeshBasicMaterial = nt),
    (t.LineDashedMaterial = Xe),
    (t.LineBasicMaterial = Ct),
    (t.Material = T),
    (t.Float64BufferAttribute = Z),
    (t.Float32BufferAttribute = Y),
    (t.Uint32BufferAttribute = q),
    (t.Int32BufferAttribute = X),
    (t.Uint16BufferAttribute = W),
    (t.Int16BufferAttribute = j),
    (t.Uint8ClampedBufferAttribute = k),
    (t.Uint8BufferAttribute = V),
    (t.Int8BufferAttribute = H),
    (t.BufferAttribute = G),
    (t.REVISION = kn),
    (t.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }),
    (t.CullFaceNone = jn),
    (t.CullFaceBack = Wn),
    (t.CullFaceFront = Xn),
    (t.CullFaceFrontBack = 3),
    (t.FrontFaceDirectionCW = qn),
    (t.FrontFaceDirectionCCW = 1),
    (t.BasicShadowMap = 0),
    (t.PCFShadowMap = Yn),
    (t.PCFSoftShadowMap = Zn),
    (t.FrontSide = Qn),
    (t.BackSide = Jn),
    (t.DoubleSide = Kn),
    (t.FlatShading = 1),
    (t.SmoothShading = 2),
    (t.NoColors = $n),
    (t.FaceColors = tr),
    (t.VertexColors = er),
    (t.NoBlending = ir),
    (t.NormalBlending = nr),
    (t.AdditiveBlending = rr),
    (t.SubtractiveBlending = ar),
    (t.MultiplyBlending = or),
    (t.CustomBlending = sr),
    (t.AddEquation = cr),
    (t.SubtractEquation = hr),
    (t.ReverseSubtractEquation = lr),
    (t.MinEquation = ur),
    (t.MaxEquation = pr),
    (t.ZeroFactor = dr),
    (t.OneFactor = fr),
    (t.SrcColorFactor = mr),
    (t.OneMinusSrcColorFactor = vr),
    (t.SrcAlphaFactor = gr),
    (t.OneMinusSrcAlphaFactor = yr),
    (t.DstAlphaFactor = xr),
    (t.OneMinusDstAlphaFactor = br),
    (t.DstColorFactor = _r),
    (t.OneMinusDstColorFactor = wr),
    (t.SrcAlphaSaturateFactor = Er),
    (t.NeverDepth = Mr),
    (t.AlwaysDepth = Tr),
    (t.LessDepth = Sr),
    (t.LessEqualDepth = Ar),
    (t.EqualDepth = Rr),
    (t.GreaterEqualDepth = Lr),
    (t.GreaterDepth = Pr),
    (t.NotEqualDepth = Cr),
    (t.MultiplyOperation = Ir),
    (t.MixOperation = Dr),
    (t.AddOperation = Or),
    (t.NoToneMapping = Ur),
    (t.LinearToneMapping = Nr),
    (t.ReinhardToneMapping = Br),
    (t.Uncharted2ToneMapping = Fr),
    (t.CineonToneMapping = zr),
    (t.UVMapping = 300),
    (t.CubeReflectionMapping = Gr),
    (t.CubeRefractionMapping = Hr),
    (t.EquirectangularReflectionMapping = Vr),
    (t.EquirectangularRefractionMapping = kr),
    (t.SphericalReflectionMapping = jr),
    (t.CubeUVReflectionMapping = Wr),
    (t.CubeUVRefractionMapping = Xr),
    (t.RepeatWrapping = qr),
    (t.ClampToEdgeWrapping = Yr),
    (t.MirroredRepeatWrapping = Zr),
    (t.NearestFilter = Qr),
    (t.NearestMipMapNearestFilter = Jr),
    (t.NearestMipMapLinearFilter = Kr),
    (t.LinearFilter = $r),
    (t.LinearMipMapNearestFilter = ta),
    (t.LinearMipMapLinearFilter = ea),
    (t.UnsignedByteType = ia),
    (t.ByteType = na),
    (t.ShortType = ra),
    (t.UnsignedShortType = aa),
    (t.IntType = oa),
    (t.UnsignedIntType = sa),
    (t.FloatType = ca),
    (t.HalfFloatType = ha),
    (t.UnsignedShort4444Type = la),
    (t.UnsignedShort5551Type = ua),
    (t.UnsignedShort565Type = pa),
    (t.UnsignedInt248Type = da),
    (t.AlphaFormat = fa),
    (t.RGBFormat = ma),
    (t.RGBAFormat = va),
    (t.LuminanceFormat = ga),
    (t.LuminanceAlphaFormat = ya),
    (t.RGBEFormat = xa),
    (t.DepthFormat = ba),
    (t.DepthStencilFormat = _a),
    (t.RGB_S3TC_DXT1_Format = wa),
    (t.RGBA_S3TC_DXT1_Format = Ea),
    (t.RGBA_S3TC_DXT3_Format = Ma),
    (t.RGBA_S3TC_DXT5_Format = Ta),
    (t.RGB_PVRTC_4BPPV1_Format = Sa),
    (t.RGB_PVRTC_2BPPV1_Format = Aa),
    (t.RGBA_PVRTC_4BPPV1_Format = Ra),
    (t.RGBA_PVRTC_2BPPV1_Format = La),
    (t.RGB_ETC1_Format = Pa),
    (t.LoopOnce = 2200),
    (t.LoopRepeat = Ca),
    (t.LoopPingPong = 2202),
    (t.InterpolateDiscrete = 2300),
    (t.InterpolateLinear = 2301),
    (t.InterpolateSmooth = 2302),
    (t.ZeroCurvatureEnding = Ia),
    (t.ZeroSlopeEnding = 2401),
    (t.WrapAroundEnding = 2402),
    (t.TrianglesDrawMode = Da),
    (t.TriangleStripDrawMode = Oa),
    (t.TriangleFanDrawMode = Ua),
    (t.LinearEncoding = Na),
    (t.sRGBEncoding = Ba),
    (t.GammaEncoding = Fa),
    (t.RGBEEncoding = za),
    (t.LogLuvEncoding = 3003),
    (t.RGBM7Encoding = Ga),
    (t.RGBM16Encoding = Ha),
    (t.RGBDEncoding = Va),
    (t.BasicDepthPacking = ka),
    (t.RGBADepthPacking = ja),
    (t.CubeGeometry = $),
    (t.Face4 = function (t, e, i, n, r, a, o) {
      return (
        console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.'),
        new F(t, e, i, r, a, o)
      );
    }),
    (t.LineStrip = 0),
    (t.LinePieces = 1),
    (t.MeshFaceMaterial = function (t) {
      return (console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.'), t);
    }),
    (t.MultiMaterial = function (t) {
      return (
        void 0 === t && (t = []),
        console.warn('THREE.MultiMaterial has been removed. Use an Array instead.'),
        (t.isMultiMaterial = !0),
        (t.materials = t),
        (t.clone = function () {
          return t.slice();
        }),
        t
      );
    }),
    (t.PointCloud = function (t, e) {
      return (console.warn('THREE.PointCloud has been renamed to THREE.Points.'), new Nt(t, e));
    }),
    (t.Particle = function (t) {
      return (console.warn('THREE.Particle has been renamed to THREE.Sprite.'), new St(t));
    }),
    (t.ParticleSystem = function (t, e) {
      return (console.warn('THREE.ParticleSystem has been renamed to THREE.Points.'), new Nt(t, e));
    }),
    (t.PointCloudMaterial = function (t) {
      return (console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.'), new Ut(t));
    }),
    (t.ParticleBasicMaterial = function (t) {
      return (console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.'), new Ut(t));
    }),
    (t.ParticleSystemMaterial = function (t) {
      return (console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.'), new Ut(t));
    }),
    (t.Vertex = function (t, e, i) {
      return (console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.'), new a(t, e, i));
    }),
    (t.DynamicBufferAttribute = function (t, e) {
      return (
        console.warn(
          'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.'
        ),
        new G(t, e).setDynamic(!0)
      );
    }),
    (t.Int8Attribute = function (t, e) {
      return (
        console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.'),
        new H(t, e)
      );
    }),
    (t.Uint8Attribute = function (t, e) {
      return (
        console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.'),
        new V(t, e)
      );
    }),
    (t.Uint8ClampedAttribute = function (t, e) {
      return (
        console.warn(
          'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.'
        ),
        new k(t, e)
      );
    }),
    (t.Int16Attribute = function (t, e) {
      return (
        console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.'),
        new j(t, e)
      );
    }),
    (t.Uint16Attribute = function (t, e) {
      return (
        console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.'),
        new W(t, e)
      );
    }),
    (t.Int32Attribute = function (t, e) {
      return (
        console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.'),
        new X(t, e)
      );
    }),
    (t.Uint32Attribute = function (t, e) {
      return (
        console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.'),
        new q(t, e)
      );
    }),
    (t.Float32Attribute = function (t, e) {
      return (
        console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.'),
        new Y(t, e)
      );
    }),
    (t.Float64Attribute = function (t, e) {
      return (
        console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.'),
        new Z(t, e)
      );
    }),
    (t.ClosedSplineCurve3 = Gn),
    (t.SplineCurve3 = Hn),
    (t.Spline = Vn),
    (t.AxisHelper = function (t) {
      return (console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.'), new Dn(t));
    }),
    (t.BoundingBoxHelper = function (t, e) {
      return (
        console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.'),
        new Ln(t, e)
      );
    }),
    (t.EdgesHelper = function (t, e) {
      return (
        console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.'),
        new Dt(new Ce(t.geometry), new Ct({ color: void 0 !== e ? e : 16777215 }))
      );
    }),
    (t.WireframeHelper = function (t, e) {
      return (
        console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.'),
        new Dt(new Ht(t.geometry), new Ct({ color: void 0 !== e ? e : 16777215 }))
      );
    }),
    (t.XHRLoader = function (t) {
      return (console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.'), new Ye(t));
    }),
    (t.BinaryTextureLoader = function (t) {
      return (console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.'), new Qe(t));
    }),
    (t.GeometryUtils = Io),
    (t.ImageUtils = Do),
    (t.Projector = function () {
      (console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.'),
        (this.projectVector = function (t, e) {
          (console.warn('THREE.Projector: .projectVector() is now vector.project().'), t.project(e));
        }),
        (this.unprojectVector = function (t, e) {
          (console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().'), t.unproject(e));
        }),
        (this.pickingRay = function () {
          console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
        }));
    }),
    (t.CanvasRenderer = function () {
      (console.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js'),
        (this.domElement = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')),
        (this.clear = function () {}),
        (this.render = function () {}),
        (this.setClearColor = function () {}),
        (this.setSize = function () {}));
    }),
    Object.defineProperty(t, '__esModule', { value: !0 }));
}),
  (function (t) {
    if ('object' == typeof exports && 'undefined' != typeof module) module.exports = t();
    else if ('function' == typeof define && define.amd) define([], t);
    else {
      ('undefined' != typeof window
        ? window
        : 'undefined' != typeof global
          ? global
          : 'undefined' != typeof self
            ? self
            : this
      ).RayInput = t();
    }
  })(function () {
    return (function t(e, i, n) {
      function r(o, s) {
        if (!i[o]) {
          if (!e[o]) {
            const c = 'function' == typeof require && require;
            if (!s && c) return c(o, !0);
            if (a) return a(o, !0);
            const h = new Error("Cannot find module '" + o + "'");
            throw ((h.code = 'MODULE_NOT_FOUND'), h);
          }
          const l = (i[o] = { exports: {} });
          e[o][0].call(
            l.exports,
            function (t) {
              const i = e[o][1][t];
              return r(i || t);
            },
            l,
            l.exports,
            t,
            e,
            i,
            n
          );
        }
        return i[o].exports;
      }
      for (var a = 'function' == typeof require && require, o = 0; o < n.length; o++) r(n[o]);
      return r;
    })(
      {
        1: [
          function (t, e, i) {
            'use strict';
            function n(t, e, i) {
              ((this.fn = t), (this.context = e), (this.once = i || !1));
            }
            function r() {}
            const a = Object.prototype.hasOwnProperty,
              o = 'function' != typeof Object.create && '~';
            ((r.prototype._events = void 0),
              (r.prototype.eventNames = function () {
                let t,
                  e = this._events,
                  i = [];
                if (!e) return i;
                for (t in e) a.call(e, t) && i.push(o ? t.slice(1) : t);
                return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(e)) : i;
              }),
              (r.prototype.listeners = function (t, e) {
                const i = o ? o + t : t,
                  n = this._events && this._events[i];
                if (e) return !!n;
                if (!n) return [];
                if (n.fn) return [n.fn];
                for (var r = 0, a = n.length, s = new Array(a); r < a; r++) s[r] = n[r].fn;
                return s;
              }),
              (r.prototype.emit = function (t, e, i, n, r, a) {
                const s = o ? o + t : t;
                if (!this._events || !this._events[s]) return !1;
                let c,
                  h,
                  l = this._events[s],
                  u = arguments.length;
                if ('function' == typeof l.fn) {
                  switch ((l.once && this.removeListener(t, l.fn, void 0, !0), u)) {
                    case 1:
                      return (l.fn.call(l.context), !0);
                    case 2:
                      return (l.fn.call(l.context, e), !0);
                    case 3:
                      return (l.fn.call(l.context, e, i), !0);
                    case 4:
                      return (l.fn.call(l.context, e, i, n), !0);
                    case 5:
                      return (l.fn.call(l.context, e, i, n, r), !0);
                    case 6:
                      return (l.fn.call(l.context, e, i, n, r, a), !0);
                  }
                  for (h = 1, c = new Array(u - 1); h < u; h++) c[h - 1] = arguments[h];
                  l.fn.apply(l.context, c);
                } else {
                  let p,
                    d = l.length;
                  for (h = 0; h < d; h++)
                    switch ((l[h].once && this.removeListener(t, l[h].fn, void 0, !0), u)) {
                      case 1:
                        l[h].fn.call(l[h].context);
                        break;
                      case 2:
                        l[h].fn.call(l[h].context, e);
                        break;
                      case 3:
                        l[h].fn.call(l[h].context, e, i);
                        break;
                      default:
                        if (!c) for (p = 1, c = new Array(u - 1); p < u; p++) c[p - 1] = arguments[p];
                        l[h].fn.apply(l[h].context, c);
                    }
                }
                return !0;
              }),
              (r.prototype.on = function (t, e, i) {
                const r = new n(e, i || this),
                  a = o ? o + t : t;
                return (
                  this._events || (this._events = o ? {} : Object.create(null)),
                  this._events[a]
                    ? this._events[a].fn
                      ? (this._events[a] = [this._events[a], r])
                      : this._events[a].push(r)
                    : (this._events[a] = r),
                  this
                );
              }),
              (r.prototype.once = function (t, e, i) {
                const r = new n(e, i || this, !0),
                  a = o ? o + t : t;
                return (
                  this._events || (this._events = o ? {} : Object.create(null)),
                  this._events[a]
                    ? this._events[a].fn
                      ? (this._events[a] = [this._events[a], r])
                      : this._events[a].push(r)
                    : (this._events[a] = r),
                  this
                );
              }),
              (r.prototype.removeListener = function (t, e, i, n) {
                const r = o ? o + t : t;
                if (!this._events || !this._events[r]) return this;
                const a = this._events[r],
                  s = [];
                if (e)
                  if (a.fn) (a.fn !== e || (n && !a.once) || (i && a.context !== i)) && s.push(a);
                  else
                    for (let c = 0, h = a.length; c < h; c++)
                      (a[c].fn !== e || (n && !a[c].once) || (i && a[c].context !== i)) && s.push(a[c]);
                return (s.length ? (this._events[r] = 1 === s.length ? s[0] : s) : delete this._events[r], this);
              }),
              (r.prototype.removeAllListeners = function (t) {
                return this._events
                  ? (t ? delete this._events[o ? o + t : t] : (this._events = o ? {} : Object.create(null)), this)
                  : this;
              }),
              (r.prototype.off = r.prototype.removeListener),
              (r.prototype.addListener = r.prototype.on),
              (r.prototype.setMaxListeners = function () {
                return this;
              }),
              (r.prefixed = o),
              void 0 !== e && (e.exports = r));
          },
          {},
        ],
        2: [
          function (t, e, i) {
            'use strict';
            Object.defineProperty(i, '__esModule', { value: !0 });
            const n = (function () {
                function t(t, e) {
                  for (let i = 0; i < e.length; i++) {
                    const n = e[i];
                    ((n.enumerable = n.enumerable || !1),
                      (n.configurable = !0),
                      'value' in n && (n.writable = !0),
                      Object.defineProperty(t, n.key, n));
                  }
                }
                return function (e, i, n) {
                  return (i && t(e.prototype, i), n && t(e, n), e);
                };
              })(),
              r = new THREE.Vector3(0.155, -0.465, -0.15),
              a = new THREE.Vector3(0, 0, -0.25),
              o = new THREE.Vector3(0, 0, 0.05),
              s = new THREE.Vector3(-0.08, 0.14, 0.08),
              c = (function () {
                function t() {
                  (!(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function');
                  })(this, t),
                    (this.isLeftHanded = !1),
                    (this.controllerQ = new THREE.Quaternion()),
                    (this.lastControllerQ = new THREE.Quaternion()),
                    (this.headQ = new THREE.Quaternion()),
                    (this.headPos = new THREE.Vector3()),
                    (this.elbowPos = new THREE.Vector3()),
                    (this.wristPos = new THREE.Vector3()),
                    (this.time = null),
                    (this.lastTime = null),
                    (this.rootQ = new THREE.Quaternion()),
                    (this.pose = { orientation: new THREE.Quaternion(), position: new THREE.Vector3() }));
                }
                return (
                  n(t, [
                    {
                      key: 'setControllerOrientation',
                      value: function (t) {
                        (this.lastControllerQ.copy(this.controllerQ), this.controllerQ.copy(t));
                      },
                    },
                    {
                      key: 'setHeadOrientation',
                      value: function (t) {
                        this.headQ.copy(t);
                      },
                    },
                    {
                      key: 'setHeadPosition',
                      value: function (t) {
                        this.headPos.copy(t);
                      },
                    },
                    {
                      key: 'setLeftHanded',
                      value: function (t) {
                        this.isLeftHanded = t;
                      },
                    },
                    {
                      key: 'update',
                      value: function () {
                        this.time = performance.now();
                        const t = this.getHeadYawOrientation_(),
                          e = (this.time - this.lastTime) / 1e3,
                          i = this.quatAngle_(this.lastControllerQ, this.controllerQ);
                        i / e > 0.61 ? this.rootQ.slerp(t, i / 10) : this.rootQ.copy(t);
                        const n = new THREE.Euler().setFromQuaternion(this.controllerQ, 'YXZ'),
                          c = THREE.Math.radToDeg(n.x),
                          h = this.clamp_((c - 11) / 39, 0, 1),
                          l = this.rootQ.clone().inverse();
                        l.multiply(this.controllerQ);
                        const u = this.elbowPos;
                        u.copy(this.headPos).add(r);
                        const p = new THREE.Vector3().copy(s);
                        (p.multiplyScalar(h), u.add(p));
                        const d = this.quatAngle_(l, new THREE.Quaternion()),
                          f = THREE.Math.radToDeg(d),
                          m = (1 - Math.pow(f / 180, 4)) * (0.4 + 0.6 * h * 0.4),
                          v = new THREE.Quaternion().slerp(l, m),
                          g = v.inverse(),
                          y = l.clone().multiply(g),
                          x = this.wristPos;
                        (x.copy(o), x.applyQuaternion(v), x.add(a), x.applyQuaternion(y), x.add(this.elbowPos));
                        const b = new THREE.Vector3().copy(s);
                        b.multiplyScalar(h);
                        const _ = new THREE.Vector3().copy(this.wristPos);
                        (_.add(b), _.applyQuaternion(this.rootQ));
                        const w = new THREE.Quaternion().copy(this.controllerQ);
                        (this.pose.orientation.copy(w), this.pose.position.copy(_), (this.lastTime = this.time));
                      },
                    },
                    {
                      key: 'getPose',
                      value: function () {
                        return this.pose;
                      },
                    },
                    {
                      key: 'getForearmLength',
                      value: function () {
                        return a.length();
                      },
                    },
                    {
                      key: 'getElbowPosition',
                      value: function () {
                        return this.elbowPos.clone().applyQuaternion(this.rootQ);
                      },
                    },
                    {
                      key: 'getWristPosition',
                      value: function () {
                        return this.wristPos.clone().applyQuaternion(this.rootQ);
                      },
                    },
                    {
                      key: 'getHeadYawOrientation_',
                      value: function () {
                        const t = new THREE.Euler().setFromQuaternion(this.headQ, 'YXZ');
                        ((t.x = 0), (t.z = 0));
                        return new THREE.Quaternion().setFromEuler(t);
                      },
                    },
                    {
                      key: 'clamp_',
                      value: function (t, e, i) {
                        return Math.min(Math.max(t, e), i);
                      },
                    },
                    {
                      key: 'quatAngle_',
                      value: function (t, e) {
                        const i = new THREE.Vector3(0, 0, -1),
                          n = new THREE.Vector3(0, 0, -1);
                        return (i.applyQuaternion(t), n.applyQuaternion(e), i.angleTo(n));
                      },
                    },
                  ]),
                  t
                );
              })();
            i.default = c;
          },
          {},
        ],
        3: [
          function (t, e, i) {
            'use strict';
            function n(t) {
              return t && t.__esModule ? t : { default: t };
            }
            Object.defineProperty(i, '__esModule', { value: !0 });
            const r = (function () {
                function t(t, e) {
                  for (let i = 0; i < e.length; i++) {
                    const n = e[i];
                    ((n.enumerable = n.enumerable || !1),
                      (n.configurable = !0),
                      'value' in n && (n.writable = !0),
                      Object.defineProperty(t, n.key, n));
                  }
                }
                return function (e, i, n) {
                  return (i && t(e.prototype, i), n && t(e, n), e);
                };
              })(),
              a = n(t('eventemitter3')),
              o = n(t('./ray-interaction-modes')),
              s = t('./util'),
              c = (function (t) {
                function e(t) {
                  !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function');
                  })(this, e);
                  const i = (function (t, e) {
                      if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      return !e || ('object' != typeof e && 'function' != typeof e) ? t : e;
                    })(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this)),
                    n = t || window;
                  return (
                    n.addEventListener('mousedown', i.onMouseDown_.bind(i)),
                    n.addEventListener('mousemove', i.onMouseMove_.bind(i)),
                    n.addEventListener('mouseup', i.onMouseUp_.bind(i)),
                    n.addEventListener('touchstart', i.onTouchStart_.bind(i)),
                    n.addEventListener('touchmove', i.onTouchMove_.bind(i)),
                    n.addEventListener('touchend', i.onTouchEnd_.bind(i)),
                    (i.pointer = new THREE.Vector2()),
                    (i.lastPointer = new THREE.Vector2()),
                    (i.pointerNdc = new THREE.Vector2()),
                    (i.dragDistance = 0),
                    (i.isDragging = !1),
                    (i.isTouchActive = !1),
                    (i.isSyntheticMouseEvent = !1),
                    (i.gamepad = null),
                    navigator.getVRDisplays
                      ? navigator.getVRDisplays().then(function (t) {
                          i.vrDisplay = t[0];
                        })
                      : console.warn('WebVR API not available! Consider using the webvr-polyfill.'),
                    i
                  );
                }
                return (
                  (function (t, e) {
                    if ('function' != typeof e && null !== e)
                      throw new TypeError('Super expression must either be null or a function, not ' + typeof e);
                    ((t.prototype = Object.create(e && e.prototype, {
                      constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 },
                    })),
                      e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : (t.__proto__ = e)));
                  })(e, a.default),
                  r(e, [
                    {
                      key: 'getInteractionMode',
                      value: function () {
                        const t = this.getVRGamepad_();
                        if (!t)
                          return (0, s.isMobile)()
                            ? this.vrDisplay && this.vrDisplay.isPresenting
                              ? o.default.VR_0DOF
                              : o.default.TOUCH
                            : o.default.MOUSE;
                        const e = t.pose;
                        return e
                          ? e.hasPosition
                            ? o.default.VR_6DOF
                            : e.hasOrientation
                              ? o.default.VR_3DOF
                              : o.default.TOUCH
                          : o.default.VR_0DOF;
                      },
                    },
                    {
                      key: 'getGamepadPose',
                      value: function () {
                        return this.getVRGamepad_().pose || {};
                      },
                    },
                    {
                      key: 'getIsTouchActive',
                      value: function () {
                        return this.isTouchActive;
                      },
                    },
                    {
                      key: 'isCardboardCompatClick',
                      value: function (t) {
                        const e = this.getInteractionMode();
                        return (e == o.default.VR_0DOF || e == o.default.VR_3DOF) && 0 == t.screenX && 0 == t.screenY;
                      },
                    },
                    {
                      key: 'setSize',
                      value: function (t) {
                        this.size = t;
                      },
                    },
                    {
                      key: 'update',
                      value: function () {
                        const t = this.getInteractionMode();
                        if (t == o.default.VR_0DOF || t == o.default.VR_3DOF || t == o.default.VR_6DOF) {
                          const e = this.getGamepadButtonPressed_();
                          (e && !this.wasGamepadPressed && this.emit('raydown'),
                            !e && this.wasGamepadPressed && this.emit('rayup'),
                            (this.wasGamepadPressed = e));
                        }
                      },
                    },
                    {
                      key: 'getGamepadButtonPressed_',
                      value: function () {
                        const t = this.getVRGamepad_();
                        if (!t) return !1;
                        for (let e = 0; e < t.buttons.length; ++e) if (t.buttons[e].pressed) return !0;
                        return !1;
                      },
                    },
                    {
                      key: 'onMouseDown_',
                      value: function (t) {
                        this.isSyntheticMouseEvent ||
                          this.isCardboardCompatClick(t) ||
                          (this.startDragging_(t), this.emit('raydown'));
                      },
                    },
                    {
                      key: 'onMouseMove_',
                      value: function (t) {
                        this.isSyntheticMouseEvent ||
                          (this.updatePointer_(t),
                          this.updateDragDistance_(),
                          this.emit('pointermove', this.pointerNdc));
                      },
                    },
                    {
                      key: 'onMouseUp_',
                      value: function (t) {
                        const e = this.isSyntheticMouseEvent;
                        ((this.isSyntheticMouseEvent = !1), e || this.isCardboardCompatClick(t) || this.endDragging_());
                      },
                    },
                    {
                      key: 'onTouchStart_',
                      value: function (t) {
                        this.isTouchActive = !0;
                        const e = t.touches[0];
                        (this.startDragging_(e),
                          this.updateTouchPointer_(t),
                          this.emit('pointermove', this.pointerNdc),
                          this.emit('raydown'));
                      },
                    },
                    {
                      key: 'onTouchMove_',
                      value: function (t) {
                        (this.updateTouchPointer_(t), this.updateDragDistance_());
                      },
                    },
                    {
                      key: 'onTouchEnd_',
                      value: function (t) {
                        (this.endDragging_(), (this.isSyntheticMouseEvent = !0), (this.isTouchActive = !1));
                      },
                    },
                    {
                      key: 'updateTouchPointer_',
                      value: function (t) {
                        if (0 !== t.touches.length) {
                          const e = t.touches[0];
                          this.updatePointer_(e);
                        } else console.warn('Received touch event with no touches.');
                      },
                    },
                    {
                      key: 'updatePointer_',
                      value: function (t) {
                        (this.pointer.set(t.clientX, t.clientY),
                          (this.pointerNdc.x = (t.clientX / this.size.width) * 2 - 1),
                          (this.pointerNdc.y = (-t.clientY / this.size.height) * 2 + 1));
                      },
                    },
                    {
                      key: 'updateDragDistance_',
                      value: function () {
                        if (this.isDragging) {
                          const t = this.lastPointer.sub(this.pointer).length();
                          ((this.dragDistance += t),
                            this.lastPointer.copy(this.pointer),
                            this.dragDistance > 10 && (this.emit('raycancel'), (this.isDragging = !1)));
                        }
                      },
                    },
                    {
                      key: 'startDragging_',
                      value: function (t) {
                        ((this.isDragging = !0), this.lastPointer.set(t.clientX, t.clientY));
                      },
                    },
                    {
                      key: 'endDragging_',
                      value: function () {
                        (this.dragDistance < 10 && this.emit('rayup'), (this.dragDistance = 0), (this.isDragging = !1));
                      },
                    },
                    {
                      key: 'getVRGamepad_',
                      value: function () {
                        if (!navigator.getGamepads) return null;
                        for (let t = navigator.getGamepads(), e = 0; e < t.length; ++e) {
                          const i = t[e];
                          if (i && (i.pose || i.displayId)) return i;
                        }
                        return null;
                      },
                    },
                  ]),
                  e
                );
              })();
            i.default = c;
          },
          { './ray-interaction-modes': 5, './util': 7, eventemitter3: 1 },
        ],
        4: [
          function (t, e, i) {
            'use strict';
            function n(t) {
              return t && t.__esModule ? t : { default: t };
            }
            Object.defineProperty(i, '__esModule', { value: !0 });
            const r = (function () {
                function t(t, e) {
                  for (let i = 0; i < e.length; i++) {
                    const n = e[i];
                    ((n.enumerable = n.enumerable || !1),
                      (n.configurable = !0),
                      'value' in n && (n.writable = !0),
                      Object.defineProperty(t, n.key, n));
                  }
                }
                return function (e, i, n) {
                  return (i && t(e.prototype, i), n && t(e, n), e);
                };
              })(),
              a = n(t('./orientation-arm-model')),
              o = n(t('eventemitter3')),
              s = n(t('./ray-renderer')),
              c = n(t('./ray-controller')),
              h = n(t('./ray-interaction-modes')),
              l = (function (t) {
                function e(t, i) {
                  !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function');
                  })(this, e);
                  const n = (function (t, e) {
                    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !e || ('object' != typeof e && 'function' != typeof e) ? t : e;
                  })(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
                  return (
                    (n.camera = t),
                    (n.renderer = new s.default(t)),
                    (n.controller = new c.default(i)),
                    (n.armModel = new a.default()),
                    n.controller.on('raydown', n.onRayDown_.bind(n)),
                    n.controller.on('rayup', n.onRayUp_.bind(n)),
                    n.controller.on('raycancel', n.onRayCancel_.bind(n)),
                    n.controller.on('pointermove', n.onPointerMove_.bind(n)),
                    n.renderer.on('rayover', function (t) {
                      n.emit('rayover', t);
                    }),
                    n.renderer.on('rayout', function (t) {
                      n.emit('rayout', t);
                    }),
                    (n.pointerNdc = new THREE.Vector2(1, 1)),
                    (n.handlers = {}),
                    n
                  );
                }
                return (
                  (function (t, e) {
                    if ('function' != typeof e && null !== e)
                      throw new TypeError('Super expression must either be null or a function, not ' + typeof e);
                    ((t.prototype = Object.create(e && e.prototype, {
                      constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 },
                    })),
                      e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : (t.__proto__ = e)));
                  })(e, o.default),
                  r(e, [
                    {
                      key: 'add',
                      value: function (t, e) {
                        (this.renderer.add(t, e), (this.handlers[t.id] = e));
                      },
                    },
                    {
                      key: 'remove',
                      value: function (t) {
                        (this.renderer.remove(t), delete this.handlers[t.id]);
                      },
                    },
                    {
                      key: 'update',
                      value: function () {
                        new THREE.Vector3(0, 0, -1).applyQuaternion(this.camera.quaternion);
                        switch (this.controller.getInteractionMode()) {
                          case h.default.MOUSE:
                            (this.renderer.setPointer(this.pointerNdc),
                              this.renderer.setRayVisibility(!1),
                              this.renderer.setReticleVisibility(!1),
                              this.renderer.setActive(!0));
                            break;
                          case h.default.TOUCH:
                            (this.renderer.setPointer(this.pointerNdc),
                              this.renderer.setRayVisibility(!1),
                              this.renderer.setReticleVisibility(!1),
                              this.renderer.setActive(this.controller.getIsTouchActive()));
                            break;
                          case h.default.VR_0DOF:
                            (this.renderer.setPosition(this.camera.position),
                              this.renderer.setOrientation(this.camera.quaternion),
                              this.renderer.setRayVisibility(!1),
                              this.renderer.setReticleVisibility(!0),
                              this.renderer.setActive(!0));
                            break;
                          case h.default.VR_3DOF:
                            var t = this.controller.getGamepadPose(),
                              e = new THREE.Quaternion().fromArray(t.orientation);
                            (this.armModel.setHeadOrientation(this.camera.quaternion),
                              this.armModel.setHeadPosition(this.camera.position),
                              this.armModel.setControllerOrientation(e),
                              this.armModel.update());
                            var i = this.armModel.getPose();
                            (this.renderer.setPosition(i.position),
                              this.renderer.setOrientation(i.orientation),
                              this.renderer.setRayVisibility(!0),
                              this.renderer.setReticleVisibility(!0),
                              this.renderer.setActive(!0));
                            break;
                          case h.default.VR_6DOF:
                            if (!(t = this.controller.getGamepadPose()).orientation || !t.position) {
                              console.warn("Invalid gamepad pose. Can't update ray.");
                              break;
                            }
                            var n = new THREE.Quaternion().fromArray(t.orientation),
                              r = new THREE.Vector3().fromArray(t.position);
                            (this.renderer.setOrientation(n),
                              this.renderer.setPosition(r),
                              this.renderer.setRayVisibility(!0),
                              this.renderer.setReticleVisibility(!0),
                              this.renderer.setActive(!0));
                            break;
                          default:
                            console.error('Unknown interaction mode.');
                        }
                        (this.renderer.update(), this.controller.update());
                      },
                    },
                    {
                      key: 'setSize',
                      value: function (t) {
                        this.controller.setSize(t);
                      },
                    },
                    {
                      key: 'getMesh',
                      value: function () {
                        return this.renderer.getReticleRayMesh();
                      },
                    },
                    {
                      key: 'getOrigin',
                      value: function () {
                        return this.renderer.getOrigin();
                      },
                    },
                    {
                      key: 'getDirection',
                      value: function () {
                        return this.renderer.getDirection();
                      },
                    },
                    {
                      key: 'getRightDirection',
                      value: function () {
                        const t = new THREE.Vector3(0, 0, -1);
                        return (
                          t.applyQuaternion(this.camera.quaternion),
                          new THREE.Vector3().crossVectors(t, this.camera.up)
                        );
                      },
                    },
                    {
                      key: 'onRayDown_',
                      value: function (t) {
                        this.renderer.update();
                        const e = this.renderer.getSelectedMesh();
                        (this.emit('raydown', e), this.renderer.setActive(!0));
                      },
                    },
                    {
                      key: 'onRayUp_',
                      value: function (t) {
                        const e = this.renderer.getSelectedMesh();
                        (this.emit('rayup', e), this.renderer.setActive(!1));
                      },
                    },
                    {
                      key: 'onRayCancel_',
                      value: function (t) {
                        const e = this.renderer.getSelectedMesh();
                        this.emit('raycancel', e);
                      },
                    },
                    {
                      key: 'onPointerMove_',
                      value: function (t) {
                        this.pointerNdc.copy(t);
                      },
                    },
                  ]),
                  e
                );
              })();
            i.default = l;
          },
          {
            './orientation-arm-model': 2,
            './ray-controller': 3,
            './ray-interaction-modes': 5,
            './ray-renderer': 6,
            eventemitter3: 1,
          },
        ],
        5: [
          function (t, e, i) {
            'use strict';
            Object.defineProperty(i, '__esModule', { value: !0 });
            i.default = { MOUSE: 1, TOUCH: 2, VR_0DOF: 3, VR_3DOF: 4, VR_6DOF: 5 };
          },
          {},
        ],
        6: [
          function (t, e, i) {
            'use strict';
            Object.defineProperty(i, '__esModule', { value: !0 });
            const n = (function () {
                function t(t, e) {
                  for (let i = 0; i < e.length; i++) {
                    const n = e[i];
                    ((n.enumerable = n.enumerable || !1),
                      (n.configurable = !0),
                      'value' in n && (n.writable = !0),
                      Object.defineProperty(t, n.key, n));
                  }
                }
                return function (e, i, n) {
                  return (i && t(e.prototype, i), n && t(e, n), e);
                };
              })(),
              r = t('./util'),
              a = (function (t) {
                return t && t.__esModule ? t : { default: t };
              })(t('eventemitter3')),
              o = 3,
              s = (0, r.base64)(
                'image/png',
                'iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAABdklEQVR4nO3WwXHEQAwDQcin/FOWw+BjuiPYB2q4G2nP933P9SO4824zgDADiDOAuHfb3/UjuKMAcQYQZwBx/gBxChCnAHEKEKcAcQoQpwBxChCnAHEGEGcAcf4AcQoQZwBxBhBnAHEGEGcAcQYQZwBxBhBnAHEGEGcAcQYQZwBxBhBnAHHvtt/1I7ijAHEGEGcAcf4AcQoQZwBxTkCcAsQZQJwTEKcAcQoQpwBxBhDnBMQpQJwCxClAnALEKUCcAsQpQJwCxClAnALEKUCcAsQpQJwBxDkBcQoQpwBxChCnAHEKEKcAcQoQpwBxChCnAHEKEGcAcU5AnALEKUCcAsQZQJwTEKcAcQYQ5wTEKUCcAcQZQJw/QJwCxBlAnAHEGUCcAcQZQJwBxBlAnAHEGUCcAcQZQJwBxBlAnAHEGUDcu+25fgR3FCDOAOIMIM4fIE4B4hQgTgHiFCBOAeIUIE4B4hQgzgDiDCDOHyBOAeIMIM4A4v4B/5IF9eD6QxgAAAAASUVORK5CYII='
              ),
              c = (function (t) {
                function e(t, i) {
                  !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function');
                  })(this, e);
                  const n = (function (t, e) {
                    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !e || ('object' != typeof e && 'function' != typeof e) ? t : e;
                  })(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
                  n.camera = t;
                  return (
                    (n.meshes = {}),
                    (n.selected = {}),
                    (n.raycaster = new THREE.Raycaster()),
                    (n.position = new THREE.Vector3()),
                    (n.orientation = new THREE.Quaternion()),
                    (n.root = new THREE.Object3D()),
                    (n.reticle = n.createReticle_()),
                    n.root.add(n.reticle),
                    (n.ray = n.createRay_()),
                    n.root.add(n.ray),
                    (n.reticleDistance = o),
                    n
                  );
                }
                return (
                  (function (t, e) {
                    if ('function' != typeof e && null !== e)
                      throw new TypeError('Super expression must either be null or a function, not ' + typeof e);
                    ((t.prototype = Object.create(e && e.prototype, {
                      constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 },
                    })),
                      e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : (t.__proto__ = e)));
                  })(e, a.default),
                  n(e, [
                    {
                      key: 'add',
                      value: function (t) {
                        this.meshes[t.id] = t;
                      },
                    },
                    {
                      key: 'remove',
                      value: function (t) {
                        const e = t.id;
                        (this.meshes[e] && delete this.meshes[e], this.selected[e] && delete this.selected[t.id]);
                      },
                    },
                    {
                      key: 'update',
                      value: function () {
                        for (const t in this.meshes) {
                          const e = this.meshes[t],
                            i = this.raycaster.intersectObject(e, !0);
                          i.length > 1 && console.warn('Unexpected: multiple meshes intersected.');
                          const n = i.length > 0,
                            r = this.selected[t];
                          (n && !r && ((this.selected[t] = !0), this.isActive && this.emit('rayover', e)),
                            !n &&
                              r &&
                              (delete this.selected[t],
                              this.moveReticle_(null),
                              this.isActive && this.emit('rayout', e)),
                            n && this.moveReticle_(i));
                        }
                      },
                    },
                    {
                      key: 'setPosition',
                      value: function (t) {
                        (this.position.copy(t), this.raycaster.ray.origin.copy(t), this.updateRaycaster_());
                      },
                    },
                    {
                      key: 'getOrigin',
                      value: function () {
                        return this.raycaster.ray.origin;
                      },
                    },
                    {
                      key: 'setOrientation',
                      value: function (t) {
                        this.orientation.copy(t);
                        const e = new THREE.Vector3(0, 0, -1).applyQuaternion(t);
                        (this.raycaster.ray.direction.copy(e), this.updateRaycaster_());
                      },
                    },
                    {
                      key: 'getDirection',
                      value: function () {
                        return this.raycaster.ray.direction;
                      },
                    },
                    {
                      key: 'setPointer',
                      value: function (t) {
                        (this.raycaster.setFromCamera(t, this.camera), this.updateRaycaster_());
                      },
                    },
                    {
                      key: 'getReticleRayMesh',
                      value: function () {
                        return this.root;
                      },
                    },
                    {
                      key: 'getSelectedMesh',
                      value: function () {
                        let t = 0,
                          e = null;
                        for (const i in this.selected) ((t += 1), (e = this.meshes[i]));
                        return (t > 1 && console.warn('More than one mesh selected.'), e);
                      },
                    },
                    {
                      key: 'setReticleVisibility',
                      value: function (t) {
                        this.reticle.visible = t;
                      },
                    },
                    {
                      key: 'setRayVisibility',
                      value: function (t) {
                        this.ray.visible = t;
                      },
                    },
                    {
                      key: 'setActive',
                      value: function (t) {
                        if (this.isActive != t && ((this.isActive = t), !t)) {
                          this.moveReticle_(null);
                          for (const e in this.selected) {
                            const i = this.meshes[e];
                            (delete this.selected[e], this.emit('rayout', i));
                          }
                        }
                      },
                    },
                    {
                      key: 'updateRaycaster_',
                      value: function () {
                        const t = this.raycaster.ray,
                          e = this.reticle.position;
                        (e.copy(t.direction), e.multiplyScalar(this.reticleDistance), e.add(t.origin));
                        const i = new THREE.Vector3().copy(t.direction);
                        (i.multiplyScalar(this.reticleDistance), (this.ray.scale.y = i.length()));
                        const n = new THREE.ArrowHelper(t.direction, t.origin);
                        (this.ray.rotation.copy(n.rotation),
                          this.ray.position.addVectors(t.origin, i.multiplyScalar(0.5)));
                      },
                    },
                    {
                      key: 'createReticle_',
                      value: function () {
                        const t = new THREE.SphereGeometry(0.02, 32, 32),
                          e = new THREE.MeshBasicMaterial({ color: 16777215, transparent: !0, opacity: 0.9 }),
                          i = new THREE.Mesh(t, e),
                          n = new THREE.SphereGeometry(0.04, 32, 32),
                          r = new THREE.MeshBasicMaterial({ color: 3355443, transparent: !0, opacity: 0.3 }),
                          a = new THREE.Mesh(n, r),
                          o = new THREE.Group();
                        return (o.add(i), o.add(a), o);
                      },
                    },
                    {
                      key: 'moveReticle_',
                      value: function (t) {
                        let e = o;
                        if (t) {
                          e = t[0].distance;
                        }
                        ((this.reticleDistance = e), this.updateRaycaster_());
                      },
                    },
                    {
                      key: 'createRay_',
                      value: function () {
                        const t = new THREE.CylinderGeometry(0.02, 0.02, 1, 32),
                          e = new THREE.MeshBasicMaterial({
                            map: THREE.ImageUtils.loadTexture(s),
                            transparent: !0,
                            opacity: 0.3,
                          });
                        return new THREE.Mesh(t, e);
                      },
                    },
                  ]),
                  e
                );
              })();
            i.default = c;
          },
          { './util': 7, eventemitter3: 1 },
        ],
        7: [
          function (t, e, i) {
            'use strict';
            (Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.isMobile = function () {
                let t = !1;
                return (
                  (function (e) {
                    (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
                      e
                    ) ||
                      /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
                        e.substr(0, 4)
                      )) &&
                      (t = !0);
                  })(navigator.userAgent || navigator.vendor || window.opera),
                  t
                );
              }),
              (i.base64 = function (t, e) {
                return 'data:' + t + ';base64,' + e;
              }));
          },
          {},
        ],
      },
      {},
      [4]
    )(4);
  }));
const WEBVR = {
  createButton: function (t) {
    function e(e) {
      ((r.style.display = ''),
        (r.style.cursor = 'pointer'),
        (r.style.left = 'calc(50% - 50px)'),
        (r.style.width = '100px'),
        (r.textContent = 'ENTER VR'),
        (r.onmouseenter = function () {
          r.style.opacity = '1.0';
        }),
        (r.onmouseleave = function () {
          r.style.opacity = '0.5';
        }),
        (r.onclick = function () {
          e.isPresenting ? e.exitPresent() : e.requestPresent([{ source: t.domElement }]);
        }),
        t.vr.setDevice(e));
    }
    function i() {
      ((r.style.display = ''),
        (r.style.cursor = 'auto'),
        (r.style.left = 'calc(50% - 75px)'),
        (r.style.width = '150px'),
        (r.textContent = 'VR NOT FOUND'),
        (r.onmouseenter = null),
        (r.onmouseleave = null),
        (r.onclick = null),
        t.vr.setDevice(null));
    }
    function n(t) {
      ((t.style.position = 'absolute'),
        (t.style.bottom = '20px'),
        (t.style.padding = '12px 6px'),
        (t.style.border = '1px solid #fff'),
        (t.style.borderRadius = '4px'),
        (t.style.background = 'transparent'),
        (t.style.color = '#fff'),
        (t.style.font = 'normal 13px sans-serif'),
        (t.style.textAlign = 'center'),
        (t.style.opacity = '0.5'),
        (t.style.outline = 'none'),
        (t.style.zIndex = '999'));
    }
    if ('getVRDisplays' in navigator) {
      var r = document.createElement('button');
      return (
        (r.style.display = 'none'),
        n(r),
        window.addEventListener(
          'vrdisplayconnect',
          function (t) {
            e(t.display);
          },
          !1
        ),
        window.addEventListener(
          'vrdisplaydisconnect',
          function (t) {
            i();
          },
          !1
        ),
        window.addEventListener(
          'vrdisplaypresentchange',
          function (t) {
            r.textContent = t.display.isPresenting ? 'EXIT VR' : 'ENTER VR';
          },
          !1
        ),
        navigator.getVRDisplays().then(function (t) {
          t.length > 0 ? e(t[0]) : i();
        }),
        r
      );
    }
    const a = document.createElement('a');
    return (
      (a.href = 'https://webvr.info'),
      (a.innerHTML = 'WEBVR NOT SUPPORTED'),
      (a.style.left = 'calc(50% - 90px)'),
      (a.style.width = '180px'),
      (a.style.textDecoration = 'none'),
      n(a),
      a
    );
  },
  checkAvailability: function () {
    return (console.warn('WEBVR.checkAvailability has been deprecated.'), new Promise(function () {}));
  },
  getMessageContainer: function () {
    return (console.warn('WEBVR.getMessageContainer has been deprecated.'), document.createElement('div'));
  },
  getButton: function () {
    return (console.warn('WEBVR.getButton has been deprecated.'), document.createElement('div'));
  },
  getVRDisplay: function () {
    console.warn('WEBVR.getVRDisplay has been deprecated.');
  },
};
