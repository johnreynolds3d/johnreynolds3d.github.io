!(function () {
  function e(e) {
    (THREE.Geometry.call(this),
      (this.type = 'ConvexGeometry'),
      this.fromBufferGeometry(new t(e)),
      this.mergeVertices());
  }
  function t(e) {
    (THREE.BufferGeometry.call(this), (this.type = 'ConvexBufferGeometry'));
    const t = [],
      o = [];
    void 0 === THREE.QuickHull &&
      console.error('THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on THREE.QuickHull');
    for (let r = new THREE.QuickHull().setFromPoints(e).faces, n = 0; n < r.length; n++) {
      let i = r[n],
        u = i.edge;
      do {
        const f = u.head().point;
        (t.push(f.x, f.y, f.z), o.push(i.normal.x, i.normal.y, i.normal.z), (u = u.next));
      } while (u !== i.edge);
    }
    (this.addAttribute('position', new THREE.Float32BufferAttribute(t, 3)),
      this.addAttribute('normal', new THREE.Float32BufferAttribute(o, 3)));
  }
  (((e.prototype = Object.create(THREE.Geometry.prototype)).constructor = e),
    ((t.prototype = Object.create(THREE.BufferGeometry.prototype)).constructor = t),
    (THREE.ConvexGeometry = e),
    (THREE.ConvexBufferGeometry = t));
})();
