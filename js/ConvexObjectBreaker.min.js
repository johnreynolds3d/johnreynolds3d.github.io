((THREE.ConvexObjectBreaker = function (e, t) {
  ((this.minSizeForBreak = e || 1.4),
    (this.smallDelta = t || 1e-4),
    (this.tempLine1 = new THREE.Line3()),
    (this.tempPlane1 = new THREE.Plane()),
    (this.tempPlane2 = new THREE.Plane()),
    (this.tempCM1 = new THREE.Vector3()),
    (this.tempCM2 = new THREE.Vector3()),
    (this.tempVector3 = new THREE.Vector3()),
    (this.tempVector3_2 = new THREE.Vector3()),
    (this.tempVector3_3 = new THREE.Vector3()),
    (this.tempResultObjects = { object1: null, object2: null }),
    (this.segments = []));
  for (let r = 0; r < 900; r++) this.segments[r] = !1;
}),
  (THREE.ConvexObjectBreaker.prototype = {
    constructor: THREE.ConvexObjectBreaker,
    prepareBreakableObject: function (e, t, r, a, n) {
      for (let o = e.geometry.vertices, s = 0, i = o.length; s < i; s++) o[s].mark = 0;
      const m = e.userData;
      ((m.mass = t), (m.velocity = r.clone()), (m.angularVelocity = a.clone()), (m.breakable = n));
    },
    subdivideByImpact: function (e, t, r, a, n, o) {
      function s(n, o, h, u) {
        if (Math.random() < 0.05 * u || u > p) i.push(n);
        else {
          let v = Math.PI;
          (0 === u
            ? (c.normal.copy(m.normal), (c.constant = m.constant))
            : u <= a
              ? ((v = (h - o) * (0.2 + 0.6 * Math.random()) + o),
                l.tempVector3_2.copy(e.position).sub(t).applyAxisAngle(r, v).add(t),
                c.setFromCoplanarPoints(t, l.tempVector3, l.tempVector3_2))
              : ((v = (0.5 * (1 & u) + 0.2 * (2 - Math.random())) * Math.PI),
                l.tempVector3_2.copy(t).sub(n.position).applyAxisAngle(r, v).add(n.position),
                l.tempVector3_3.copy(r).add(n.position),
                c.setFromCoplanarPoints(n.position, l.tempVector3_3, l.tempVector3_2)),
            l.cutByPlane(n, c, l.tempResultObjects));
          const E = l.tempResultObjects.object1,
            f = l.tempResultObjects.object2;
          (E && s(E, o, v, u + 1), f && s(f, v, h, u + 1));
        }
      }
      var i = [],
        m = this.tempPlane1,
        c = this.tempPlane2;
      (this.tempVector3.addVectors(t, r), m.setFromCoplanarPoints(t, e.position, this.tempVector3));
      var p = n + a,
        l = this;
      return (s(e, 0, 2 * Math.PI, 0), i);
    },
    cutByPlane: function (e, t, r) {
      for (
        var a = e.geometry, n = a.vertices, o = a.faces, s = n.length, i = [], m = [], c = this.smallDelta, p = 0;
        p < s;
        p++
      )
        n[p].mark = 0;
      for (var l = s * s, p = 0; p < l; p++) this.segments[p] = !1;
      for (var p = 0, h = o.length - 1; p < h; p++)
        for (let u = o[p], v = p + 1, E = o.length; v < E; v++) {
          const f = o[v];
          if (1 - u.normal.dot(f.normal) < c) {
            const b = u.a,
              d = u.b,
              y = u.c,
              k = f.a,
              T = f.b,
              g = f.c;
            b === k || b === T || b === g
              ? d === k || d === T || d === g
                ? ((this.segments[b * s + d] = !0), (this.segments[d * s + b] = !0))
                : ((this.segments[y * s + b] = !0), (this.segments[b * s + y] = !0))
              : (d !== k && d !== T && d !== g) || ((this.segments[y * s + d] = !0), (this.segments[d * s + y] = !0));
          }
        }
      const C = this.tempPlane1;
      (e.updateMatrix(), THREE.ConvexObjectBreaker.transformPlaneToLocalSpace(t, e.matrix, C));
      for (var p = 0, h = o.length; p < h; p++)
        for (let R = o[p], x = 0; x < 3; x++) {
          const V = 0 === x ? R.a : 1 === x ? R.b : R.c,
            M = 0 === x ? R.b : 1 === x ? R.c : R.a;
          if (!this.segments[V * s + M]) {
            ((this.segments[V * s + M] = !0), (this.segments[M * s + V] = !0));
            const j = n[V],
              H = n[M];
            if (0 === j.mark) {
              if ((B = C.distanceToPoint(j)) > c) ((j.mark = 2), m.push(j));
              else if (B < -c) ((j.mark = 1), i.push(j));
              else {
                ((j.mark = 3), i.push(j));
                const P = j.clone();
                ((P.mark = 3), m.push(P));
              }
            }
            if (0 === H.mark) {
              var B = C.distanceToPoint(H);
              if (B > c) ((H.mark = 2), m.push(H));
              else if (B < -c) ((H.mark = 1), i.push(H));
              else {
                ((H.mark = 3), i.push(H));
                const O = H.clone();
                ((O.mark = 3), m.push(O));
              }
            }
            const w = j.mark,
              z = H.mark;
            if ((1 === w && 2 === z) || (2 === w && 1 === z)) {
              (this.tempLine1.start.copy(j), this.tempLine1.end.copy(H));
              const F = C.intersectLine(this.tempLine1);
              if (void 0 === F)
                return (
                  console.error('Internal error: segment does not intersect plane.'),
                  (r.segmentedObject1 = null),
                  (r.segmentedObject2 = null),
                  0
                );
              ((F.mark = 1), i.push(F));
              const I = F.clone();
              ((I.mark = 2), m.push(I));
            }
          }
        }
      const D = 0.5 * e.userData.mass;
      this.tempCM1.set(0, 0, 0);
      let L = 0,
        _ = i.length;
      if (_ > 0) {
        for (p = 0; p < _; p++) this.tempCM1.add(i[p]);
        this.tempCM1.divideScalar(_);
        for (p = 0; p < _; p++) {
          ((A = i[p]).sub(this.tempCM1), (L = Math.max(L, A.x, A.y, A.z)));
        }
        this.tempCM1.add(e.position);
      }
      this.tempCM2.set(0, 0, 0);
      let S = 0,
        q = m.length;
      if (q > 0) {
        for (p = 0; p < q; p++) this.tempCM2.add(m[p]);
        this.tempCM2.divideScalar(q);
        for (p = 0; p < q; p++) {
          var A = m[p];
          (A.sub(this.tempCM2), (S = Math.max(S, A.x, A.y, A.z)));
        }
        this.tempCM2.add(e.position);
      }
      let G = null,
        J = null,
        K = 0;
      return (
        _ > 4 &&
          ((G = new THREE.Mesh(new THREE.ConvexGeometry(i), e.material)).position.copy(this.tempCM1),
          G.quaternion.copy(e.quaternion),
          this.prepareBreakableObject(
            G,
            D,
            e.userData.velocity,
            e.userData.angularVelocity,
            2 * L > this.minSizeForBreak
          ),
          K++),
        q > 4 &&
          ((J = new THREE.Mesh(new THREE.ConvexGeometry(m), e.material)).position.copy(this.tempCM2),
          J.quaternion.copy(e.quaternion),
          this.prepareBreakableObject(
            J,
            D,
            e.userData.velocity,
            e.userData.angularVelocity,
            2 * S > this.minSizeForBreak
          ),
          K++),
        (r.object1 = G),
        (r.object2 = J),
        K
      );
    },
  }),
  (THREE.ConvexObjectBreaker.transformFreeVector = function (e, t) {
    const r = e.x,
      a = e.y,
      n = e.z,
      o = t.elements;
    return (
      (e.x = o[0] * r + o[4] * a + o[8] * n),
      (e.y = o[1] * r + o[5] * a + o[9] * n),
      (e.z = o[2] * r + o[6] * a + o[10] * n),
      e
    );
  }),
  (THREE.ConvexObjectBreaker.transformFreeVectorInverse = function (e, t) {
    const r = e.x,
      a = e.y,
      n = e.z,
      o = t.elements;
    return (
      (e.x = o[0] * r + o[1] * a + o[2] * n),
      (e.y = o[4] * r + o[5] * a + o[6] * n),
      (e.z = o[8] * r + o[9] * a + o[10] * n),
      e
    );
  }),
  (THREE.ConvexObjectBreaker.transformTiedVectorInverse = function (e, t) {
    const r = e.x,
      a = e.y,
      n = e.z,
      o = t.elements;
    return (
      (e.x = o[0] * r + o[1] * a + o[2] * n - o[12]),
      (e.y = o[4] * r + o[5] * a + o[6] * n - o[13]),
      (e.z = o[8] * r + o[9] * a + o[10] * n - o[14]),
      e
    );
  }),
  (THREE.ConvexObjectBreaker.transformPlaneToLocalSpace = (function () {
    const e = new THREE.Vector3();
    new THREE.Matrix3();
    return function (t, r, a) {
      (a.normal.copy(t.normal), (a.constant = t.constant));
      const n = THREE.ConvexObjectBreaker.transformTiedVectorInverse(t.coplanarPoint(e), r);
      (THREE.ConvexObjectBreaker.transformFreeVectorInverse(a.normal, r), (a.constant = -n.dot(a.normal)));
    };
  })()));
